/**
 * @tanstack/react-store/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';
export * from '@tanstack/store';

function useStore(store, selector = d => d) {
  // const isMountedRef = React.useRef(false)
  // const [state, setState] = React.useState<{ ref: TSelected }>({
  //   ref: undefined!,
  // })

  const slice = useSyncExternalStoreWithSelector(store.subscribe, () => store.state, () => store.state, selector, shallow);

  // if (!isMountedRef.current) {
  //   state.ref = slice
  // }

  // if (slice !== state.ref) {
  //   setState({ ref: slice })
  // }

  // React.useEffect(() => {
  //   isMountedRef.current = true
  //   return () => {
  //     isMountedRef.current = false
  //   }
  // }, [])

  // return state.ref

  return slice;
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}

export { shallow, useStore };
//# sourceMappingURL=index.js.map
