{"version":3,"file":"index.production.js","sources":["../../../react-store/build/esm/index.js","../../../router/build/esm/index.js","../../src/useLocalStorage.ts","../../src/theme.tsx","../../src/utils.ts","../../src/useMediaQuery.ts","../../src/styledComponents.ts","../../src/Explorer.tsx","../../src/devtools.tsx","../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js"],"sourcesContent":["/**\n * @tanstack/react-store/src/index.tsx\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';\nexport * from '@tanstack/store';\n\nfunction useStore(store, selector = d => d) {\n  // const isMountedRef = React.useRef(false)\n  // const [state, setState] = React.useState<{ ref: TSelected }>({\n  //   ref: undefined!,\n  // })\n\n  const slice = useSyncExternalStoreWithSelector(store.subscribe, () => store.state, () => store.state, selector, shallow);\n\n  // if (!isMountedRef.current) {\n  //   state.ref = slice\n  // }\n\n  // if (slice !== state.ref) {\n  //   setState({ ref: slice })\n  // }\n\n  // React.useEffect(() => {\n  //   isMountedRef.current = true\n  //   return () => {\n  //     isMountedRef.current = false\n  //   }\n  // }, [])\n\n  // return state.ref\n\n  return slice;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { shallow, useStore };\n//# sourceMappingURL=index.js.map\n","/**\n * @tanstack/router/src/index.ts\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport invariant from 'tiny-invariant';\nexport { default as invariant } from 'tiny-invariant';\nimport warning from 'tiny-warning';\nexport { default as warning } from 'tiny-warning';\nimport * as React from 'react';\nimport { useStore, Store } from '@tanstack/react-store';\nexport { useStore } from '@tanstack/react-store';\n\n// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nconst popStateEvent = 'popstate';\nconst beforeUnloadEvent = 'beforeunload';\nconst beforeUnloadListener = event => {\n  event.preventDefault();\n  // @ts-ignore\n  return event.returnValue = '';\n};\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true\n  });\n};\nfunction createHistory(opts) {\n  let location = opts.getLocation();\n  let unsub = () => {};\n  let listeners = new Set();\n  let blockers = [];\n  let queue = [];\n  const tryFlush = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryFlush, () => {\n        blockers = [];\n        stopBlocking();\n      });\n      return;\n    }\n    while (queue.length) {\n      queue.shift()?.();\n    }\n    onUpdate();\n  };\n  const queueTask = task => {\n    queue.push(task);\n    tryFlush();\n  };\n  const onUpdate = () => {\n    location = opts.getLocation();\n    listeners.forEach(listener => listener());\n  };\n  return {\n    get location() {\n      return location;\n    },\n    listen: cb => {\n      if (listeners.size === 0) {\n        unsub = opts.listener(onUpdate);\n      }\n      listeners.add(cb);\n      return () => {\n        listeners.delete(cb);\n        if (listeners.size === 0) {\n          unsub();\n        }\n      };\n    },\n    push: (path, state) => {\n      queueTask(() => {\n        opts.pushState(path, state);\n      });\n    },\n    replace: (path, state) => {\n      queueTask(() => {\n        opts.replaceState(path, state);\n      });\n    },\n    go: index => {\n      queueTask(() => {\n        opts.go(index);\n      });\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back();\n      });\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward();\n      });\n    },\n    createHref: str => opts.createHref(str),\n    block: cb => {\n      blockers.push(cb);\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true\n        });\n      }\n      return () => {\n        blockers = blockers.filter(b => b !== cb);\n        if (!blockers.length) {\n          stopBlocking();\n        }\n      };\n    }\n  };\n}\nfunction createBrowserHistory(opts) {\n  const getHref = opts?.getHref ?? (() => `${window.location.pathname}${window.location.search}${window.location.hash}`);\n  const createHref = opts?.createHref ?? (path => path);\n  const getLocation = () => parseLocation(getHref(), history.state);\n  return createHistory({\n    getLocation,\n    listener: onUpdate => {\n      window.addEventListener(popStateEvent, onUpdate);\n      return () => {\n        window.removeEventListener(popStateEvent, onUpdate);\n      };\n    },\n    pushState: (path, state) => {\n      window.history.pushState({\n        ...state,\n        key: createRandomKey()\n      }, '', createHref(path));\n    },\n    replaceState: (path, state) => {\n      window.history.replaceState({\n        ...state,\n        key: createRandomKey()\n      }, '', createHref(path));\n    },\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: n => window.history.go(n),\n    createHref: path => createHref(path)\n  });\n}\nfunction createHashHistory() {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: path => `#${path}`\n  });\n}\nfunction createMemoryHistory(opts = {\n  initialEntries: ['/']\n}) {\n  const entries = opts.initialEntries;\n  let index = opts.initialIndex ?? entries.length - 1;\n  let currentState = {};\n  const getLocation = () => parseLocation(entries[index], currentState);\n  return createHistory({\n    getLocation,\n    listener: () => {\n      return () => {};\n    },\n    pushState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey()\n      };\n      entries.push(path);\n      index++;\n    },\n    replaceState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey()\n      };\n      entries[index] = path;\n    },\n    back: () => {\n      index--;\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1);\n    },\n    go: n => window.history.go(n),\n    createHref: path => path\n  });\n}\nfunction parseLocation(href, state) {\n  let hashIndex = href.indexOf('#');\n  let searchIndex = href.indexOf('?');\n  return {\n    href,\n    pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex) : '',\n    state\n  };\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7);\n}\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\nfunction isFunction(d) {\n  return typeof d === 'function';\n}\nfunction functionalUpdate(updater, previous) {\n  if (isFunction(updater)) {\n    return updater(previous);\n  }\n  return updater;\n}\nfunction pick(parent, keys) {\n  return keys.reduce((obj, key) => {\n    obj[key] = parent[key];\n    return obj;\n  }, {});\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nfunction replaceEqualDeep(prev, _next) {\n  if (prev === _next) {\n    return prev;\n  }\n  const next = _next;\n  const array = Array.isArray(prev) && Array.isArray(next);\n  if (array || isPlainObject(prev) && isPlainObject(next)) {\n    const prevSize = array ? prev.length : Object.keys(prev).length;\n    const nextItems = array ? next : Object.keys(next);\n    const nextSize = nextItems.length;\n    const copy = array ? [] : {};\n    let equalItems = 0;\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i];\n      copy[key] = replaceEqualDeep(prev[key], next[key]);\n      if (copy[key] === prev[key]) {\n        equalItems++;\n      }\n    }\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy;\n  }\n  return next;\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor;\n  if (typeof ctor === 'undefined') {\n    return true;\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => partialDeepEqual(item, b[index]));\n  }\n  return false;\n}\n\nfunction joinPaths(paths) {\n  return cleanPath(paths.filter(Boolean).join('/'));\n}\nfunction cleanPath(path) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/');\n}\nfunction trimPathLeft(path) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '');\n}\nfunction trimPathRight(path) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '');\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction resolvePath(basepath, base, to) {\n  base = base.replace(new RegExp(`^${basepath}`), '/');\n  to = to.replace(new RegExp(`^${basepath}`), '/');\n  let baseSegments = parsePathname(base);\n  const toSegments = parsePathname(to);\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment];\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop();\n      }\n      baseSegments.pop();\n    } else if (toSegment.value === '.') {\n      return;\n    } else {\n      baseSegments.push(toSegment);\n    }\n  });\n  const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);\n  return cleanPath(joined);\n}\nfunction parsePathname(pathname) {\n  if (!pathname) {\n    return [];\n  }\n  pathname = cleanPath(pathname);\n  const segments = [];\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  if (!pathname) {\n    return segments;\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean);\n  segments.push(...split.map(part => {\n    if (part === '$' || part === '*') {\n      return {\n        type: 'wildcard',\n        value: part\n      };\n    }\n    if (part.charAt(0) === '$') {\n      return {\n        type: 'param',\n        value: part\n      };\n    }\n    return {\n      type: 'pathname',\n      value: part\n    };\n  }));\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  return segments;\n}\nfunction interpolatePath(path, params, leaveWildcards = false) {\n  const interpolatedPathSegments = parsePathname(path);\n  return joinPaths(interpolatedPathSegments.map(segment => {\n    if (segment.type === 'wildcard') {\n      const value = params[segment.value];\n      if (leaveWildcards) return `${segment.value}${value ?? ''}`;\n      return value;\n    }\n    if (segment.type === 'param') {\n      return params[segment.value.substring(1)] ?? '';\n    }\n    return segment.value;\n  }));\n}\nfunction matchPathname(basepath, currentPathname, matchLocation) {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation);\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n  return pathParams ?? {};\n}\nfunction matchByPath(basepath, from, matchLocation) {\n  // Remove the base path from the pathname\n  from = basepath != '/' ? from.substring(basepath.length) : from;\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`;\n  // Parse the from and to\n  const baseSegments = parsePathname(from);\n  const routeSegments = parsePathname(to);\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/'\n    });\n  }\n  const params = {};\n  let isMatch = (() => {\n    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {\n      const baseSegment = baseSegments[i];\n      const routeSegment = routeSegments[i];\n      const isLastBaseSegment = i >= baseSegments.length - 1;\n      const isLastRouteSegment = i >= routeSegments.length - 1;\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));\n            return true;\n          }\n          return false;\n        }\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true;\n          }\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false;\n              }\n            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n              return false;\n            }\n          }\n        }\n        if (!baseSegment) {\n          return false;\n        }\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false;\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value;\n          }\n        }\n      }\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        return !!matchLocation.fuzzy;\n      }\n    }\n    return true;\n  })();\n  return isMatch ? params : undefined;\n}\n\n// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nfunction encode(obj, pfx) {\n  var k,\n    i,\n    tmp,\n    str = '';\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&');\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);\n        }\n      } else {\n        str && (str += '&');\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);\n      }\n    }\n  }\n  return (pfx || '') + str;\n}\nfunction toValue(mix) {\n  if (!mix) return '';\n  var str = decodeURIComponent(mix);\n  if (str === 'false') return false;\n  if (str === 'true') return true;\n  if (str.charAt(0) === '0') return str;\n  return +str * 0 === 0 ? +str : str;\n}\nfunction decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&');\n  while (tmp = arr.shift()) {\n    tmp = tmp.split('=');\n    k = tmp.shift();\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()));\n    } else {\n      out[k] = toValue(tmp.shift());\n    }\n  }\n  return out;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n//\n\nfunction lazy(importer, exportName = 'default') {\n  const lazyComp = /*#__PURE__*/React.lazy(async () => {\n    const moduleExports = await importer();\n    const component = moduleExports[exportName];\n    return {\n      default: component\n    };\n  });\n  const finalComp = lazyComp;\n  finalComp.preload = async () => {\n    {\n      await importer();\n    }\n  };\n  return finalComp;\n}\n//\n\nfunction useLinkProps(options) {\n  const router = useRouterContext();\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({\n      className: 'active'\n    }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    // fromCurrent,\n    hash,\n    search,\n    params,\n    to = '.',\n    preload,\n    preloadDelay,\n    replace,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options;\n  const linkInfo = router.buildLink(options);\n  if (linkInfo.type === 'external') {\n    const {\n      href\n    } = linkInfo;\n    return {\n      href\n    };\n  }\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next\n  } = linkInfo;\n  const reactHandleClick = e => {\n    if (React.startTransition) {\n      // This is a hack for react < 18\n      React.startTransition(() => {\n        handleClick(e);\n      });\n    } else {\n      handleClick(e);\n    }\n  };\n  const composeHandlers = handlers => e => {\n    if (e.persist) e.persist();\n    handlers.filter(Boolean).forEach(handler => {\n      if (e.defaultPrevented) return;\n      handler(e);\n    });\n  };\n\n  // Get the active props\n  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};\n\n  // Get the inactive props\n  const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? undefined : next.href,\n    onClick: composeHandlers([onClick, reactHandleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style\n    },\n    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,\n    ...(disabled ? {\n      role: 'link',\n      'aria-disabled': true\n    } : undefined),\n    ['data-status']: isActive ? 'active' : undefined\n  };\n}\nconst Link = /*#__PURE__*/React.forwardRef((props, ref) => {\n  const linkProps = useLinkProps(props);\n  return /*#__PURE__*/React.createElement(\"a\", _extends({\n    ref: ref\n  }, linkProps, {\n    children: typeof props.children === 'function' ? props.children({\n      isActive: linkProps['data-status'] === 'active'\n    }) : props.children\n  }));\n});\nfunction Navigate(props) {\n  const router = useRouterContext();\n  React.useLayoutEffect(() => {\n    router.navigate(props);\n  }, []);\n  return null;\n}\nconst matchesContext = /*#__PURE__*/React.createContext(null);\nconst routerContext = /*#__PURE__*/React.createContext(null);\n// const useDeferredValue = React.useDeferredValue || ((d) => d)\nconst useDeferredValue = d => d;\nfunction RouterProvider({\n  router,\n  ...rest\n}) {\n  router.update(rest);\n  const matches = useDeferredValue(useStore(router.__store, s => {\n    return s.matches;\n  }));\n  React.useEffect(router.mount, [router]);\n  return /*#__PURE__*/React.createElement(routerContext.Provider, {\n    value: {\n      router: router\n    }\n  }, /*#__PURE__*/React.createElement(matchesContext.Provider, {\n    value: [undefined, ...matches]\n  }, /*#__PURE__*/React.createElement(CatchBoundary, {\n    errorComponent: ErrorComponent,\n    onCatch: () => {\n      warning(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`);\n    }\n  }, /*#__PURE__*/React.createElement(Outlet, null))));\n}\nfunction useRouterContext() {\n  const value = React.useContext(routerContext);\n  warning(value, 'useRouter must be used inside a <Router> component!');\n  useStore(value.router.__store);\n  return value.router;\n}\nfunction useRouter(track) {\n  const router = useRouterContext();\n  useStore(router.__store, track);\n  return router;\n}\nfunction useMatches() {\n  return React.useContext(matchesContext);\n}\nfunction useMatch(opts) {\n  const router = useRouterContext();\n  const nearestMatch = useMatches()[0];\n  const matches = useDeferredValue(router.state.matches);\n  const match = opts?.from ? matches.find(d => d.route.id === opts?.from) : nearestMatch;\n  invariant(match, `Could not find ${opts?.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`);\n  if (opts?.strict ?? true) {\n    invariant(nearestMatch.route.id == match?.route.id, `useMatch(\"${match?.route.id}\") is being called in a component that is meant to render the '${nearestMatch.route.id}' route. Did you mean to 'useMatch(\"${match?.route.id}\", { strict: false })' or 'useRoute(\"${match?.route.id}\")' instead?`);\n  }\n  useStore(match.__store, d => opts?.track?.(match) ?? match);\n  return match;\n}\nfunction useLoader(opts) {\n  const {\n    track,\n    ...matchOpts\n  } = opts;\n  const match = useMatch(matchOpts);\n  useStore(match.__store, d => opts?.track?.(d.loader) ?? d.loader);\n  return match.state.loader;\n}\nfunction useSearch(opts) {\n  const {\n    track,\n    ...matchOpts\n  } = opts ?? {};\n  const match = useMatch(matchOpts);\n  useStore(match.__store, d => opts?.track?.(d.search) ?? d.search);\n  return match.state.search;\n}\nfunction useParams(opts) {\n  const router = useRouterContext();\n  return useStore(router.__store, d => {\n    const params = last(d.matches)?.params;\n    return opts?.track?.(params) ?? params;\n  });\n\n  // return last(router.state.matches)?.params as any\n}\n\nfunction useNavigate(defaultOpts) {\n  const router = useRouterContext();\n  return React.useCallback(opts => {\n    return router.navigate({\n      ...defaultOpts,\n      ...opts\n    });\n  }, []);\n}\nfunction useMatchRoute() {\n  const router = useRouterContext();\n  return React.useCallback(opts => {\n    const {\n      pending,\n      caseSensitive,\n      ...rest\n    } = opts;\n    return router.matchRoute(rest, {\n      pending,\n      caseSensitive\n    });\n  }, []);\n}\nfunction MatchRoute(props) {\n  const matchRoute = useMatchRoute();\n  const params = matchRoute(props);\n  if (!params) {\n    return null;\n  }\n  if (typeof props.children === 'function') {\n    return props.children(params);\n  }\n  return params ? props.children : null;\n}\nfunction Outlet() {\n  const matches = useMatches().slice(1);\n  const match = matches[0];\n  if (!match) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(SubOutlet, {\n    matches: matches,\n    match: match\n  });\n}\nfunction SubOutlet({\n  matches,\n  match\n}) {\n  const router = useRouterContext();\n  useStore(match.__store, store => [store.status, store.error]);\n  const defaultPending = React.useCallback(() => null, []);\n  const PendingComponent = match.pendingComponent ?? router.options.defaultPendingComponent ?? defaultPending;\n  const errorComponent = match.errorComponent ?? router.options.defaultErrorComponent;\n  const ResolvedSuspenseBoundary = match.route.options.wrapInSuspense ?? !match.route.isRoot ? React.Suspense : SafeFragment;\n  const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment;\n\n  // if (typeof document === 'undefined') {\n  //   if (match.state.loader) {\n  //     Object.keys(match.state.loader).forEach((key) => {\n  //       let value = match.state.loader[key]\n\n  //       if (value instanceof Promise || value.then) {\n  //         value = {\n  //           __isPromise: true,\n  //           key: key,\n  //         }\n  //       }\n\n  //       dehydrated[key] = value\n  //     })\n  //   }\n  // } else {\n  // }\n\n  return /*#__PURE__*/React.createElement(matchesContext.Provider, {\n    value: matches\n  }, /*#__PURE__*/React.createElement(ResolvedSuspenseBoundary, {\n    fallback: /*#__PURE__*/React.createElement(PendingComponent, null)\n  }, /*#__PURE__*/React.createElement(ResolvedCatchBoundary, {\n    key: match.route.id,\n    errorComponent: errorComponent,\n    onCatch: () => {\n      warning(false, `Error in route match: ${match.id}`);\n    }\n  }, /*#__PURE__*/React.createElement(Inner, {\n    match: match\n  }))));\n}\nfunction useInjectHtml() {\n  const router = useRouterContext();\n  return React.useCallback(html => {\n    router.injectHtml(html);\n  }, []);\n}\nfunction useDehydrate() {\n  const router = useRouterContext();\n  return React.useCallback(function dehydrate(key, data) {\n    return router.dehydrateData(key, data);\n  }, []);\n}\nfunction useHydrate() {\n  const router = useRouterContext();\n  return function hydrate(key) {\n    return router.hydrateData(key);\n  };\n}\nfunction Inner(props) {\n  const router = useRouterContext();\n  if (props.match.state.status === 'error') {\n    throw props.match.state.error;\n  }\n  if (props.match.state.status === 'pending') {\n    throw props.match.__loadPromise;\n  }\n  if (props.match.state.status === 'success') {\n    let comp = props.match.component ?? router.options.defaultComponent;\n    if (comp) {\n      return /*#__PURE__*/React.createElement(comp, {\n        useLoader: props.match.route.useLoader,\n        useMatch: props.match.route.useMatch,\n        useContext: props.match.route.useContext,\n        useSearch: props.match.route.useSearch,\n        useParams: props.match.route.useParams\n      });\n    }\n    return /*#__PURE__*/React.createElement(Outlet, null);\n  }\n  invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');\n}\nfunction SafeFragment(props) {\n  return /*#__PURE__*/React.createElement(React.Fragment, null, props.children);\n}\n\n// This is the messiest thing ever... I'm either seriously tired (likely) or\n// there has to be a better way to reset error boundaries when the\n// router's location key changes.\n\nclass CatchBoundary extends React.Component {\n  state = {\n    error: false,\n    info: undefined\n  };\n  componentDidCatch(error, info) {\n    this.props.onCatch(error, info);\n    console.error(error);\n    this.setState({\n      error,\n      info\n    });\n  }\n  render() {\n    return /*#__PURE__*/React.createElement(CatchBoundaryInner, _extends({}, this.props, {\n      errorState: this.state,\n      reset: () => this.setState({})\n    }));\n  }\n}\nfunction CatchBoundaryInner(props) {\n  const [activeErrorState, setActiveErrorState] = React.useState(props.errorState);\n  const router = useRouterContext();\n  const errorComponent = props.errorComponent ?? ErrorComponent;\n  const prevKeyRef = React.useRef('');\n  React.useEffect(() => {\n    if (activeErrorState) {\n      if (router.state.location.key !== prevKeyRef.current) ;\n    }\n    prevKeyRef.current = router.state.location.key;\n  }, [activeErrorState, router.state.location.key]);\n  React.useEffect(() => {\n    if (props.errorState.error) ;\n    // props.reset()\n  }, [props.errorState.error]);\n  if (props.errorState.error && activeErrorState.error) {\n    return /*#__PURE__*/React.createElement(errorComponent, activeErrorState);\n  }\n  return props.children;\n}\nfunction ErrorComponent({\n  error\n}) {\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: '.5rem',\n      maxWidth: '100%'\n    }\n  }, /*#__PURE__*/React.createElement(\"strong\", {\n    style: {\n      fontSize: '1.2rem'\n    }\n  }, \"Something went wrong!\"), /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      height: '.5rem'\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", null, /*#__PURE__*/React.createElement(\"pre\", {\n    style: {\n      fontSize: '.7em',\n      border: '1px solid red',\n      borderRadius: '.25rem',\n      padding: '.5rem',\n      color: 'red',\n      overflow: 'auto'\n    }\n  }, error.message ? /*#__PURE__*/React.createElement(\"code\", null, error.message) : null)));\n}\nfunction useBlocker(message, condition = true) {\n  const router = useRouter();\n  React.useEffect(() => {\n    if (!condition) return;\n    let unblock = router.history.block((retry, cancel) => {\n      if (window.confirm(message)) {\n        unblock();\n        retry();\n      }\n    });\n    return unblock;\n  });\n}\nfunction Block({\n  message,\n  condition,\n  children\n}) {\n  useBlocker(message, condition);\n  return children ?? null;\n}\n\nconst rootRouteId = '__root__';\nclass Route {\n  // Set up in this.init()\n\n  // customId!: TCustomId\n\n  // Optional\n\n  constructor(options) {\n    this.options = options || {};\n    this.isRoot = !options?.getParentRoute;\n  }\n  init = opts => {\n    this.originalIndex = opts.originalIndex;\n    this.router = opts.router;\n    const allOptions = this.options;\n    const isRoot = !allOptions?.path && !allOptions?.id;\n    this.parentRoute = this.options?.getParentRoute?.();\n    if (isRoot) {\n      this.path = rootRouteId;\n    } else {\n      invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);\n    }\n    let path = isRoot ? rootRouteId : allOptions.path;\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path);\n    }\n    const customId = allOptions?.id || path;\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);\n    if (path === rootRouteId) {\n      path = '/';\n    }\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id]);\n    }\n    const fullPath = id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path]);\n    this.path = path;\n    this.id = id;\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath;\n    this.to = fullPath;\n  };\n  addChildren = children => {\n    this.children = children;\n    return this;\n  };\n  useMatch = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useLoader = opts => {\n    return useLoader({\n      ...opts,\n      from: this.id\n    });\n  };\n  useContext = opts => {\n    return useMatch({\n      ...opts,\n      from: this.id\n    }).context;\n  };\n  useSearch = opts => {\n    return useSearch({\n      ...opts,\n      from: this.id\n    });\n  };\n  useParams = opts => {\n    return useParams({\n      ...opts,\n      from: this.id\n    });\n  };\n}\nclass RootRoute extends Route {\n  constructor(options) {\n    super(options);\n  }\n  static withRouterContext = () => {\n    return options => new RootRoute(options);\n  };\n}\n\n// const rootRoute = new RootRoute({\n//   validateSearch: () => null as unknown as { root?: boolean },\n// })\n\n// const aRoute = new Route({\n//   getParentRoute: () => rootRoute,\n//   path: 'a',\n//   validateSearch: () => null as unknown as { a?: string },\n// })\n\n// const bRoute = new Route({\n//   getParentRoute: () => aRoute,\n//   path: 'b',\n// })\n\n// const rootIsRoot = rootRoute.isRoot\n// //    ^?\n// const aIsRoot = aRoute.isRoot\n// //    ^?\n\n// const rId = rootRoute.id\n// //    ^?\n// const aId = aRoute.id\n// //    ^?\n// const bId = bRoute.id\n// //    ^?\n\n// const rPath = rootRoute.fullPath\n// //    ^?\n// const aPath = aRoute.fullPath\n// //    ^?\n// const bPath = bRoute.fullPath\n// //    ^?\n\n// const rSearch = rootRoute.__types.fullSearchSchema\n// //    ^?\n// const aSearch = aRoute.__types.fullSearchSchema\n// //    ^?\n// const bSearch = bRoute.__types.fullSearchSchema\n// //    ^?\n\n// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])\n// //    ^?\n\nconst defaultParseSearch = parseSearchWith(JSON.parse);\nconst defaultStringifySearch = stringifySearchWith(JSON.stringify);\nfunction parseSearchWith(parser) {\n  return searchStr => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1);\n    }\n    let query = decode(searchStr);\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key];\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value);\n        } catch (err) {\n          //\n        }\n      }\n    }\n    return query;\n  };\n}\nfunction stringifySearchWith(stringify) {\n  return search => {\n    search = {\n      ...search\n    };\n    if (search) {\n      Object.keys(search).forEach(key => {\n        const val = search[key];\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key];\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val);\n          } catch (err) {\n            // silent\n          }\n        }\n      });\n    }\n    const searchStr = encode(search).toString();\n    return searchStr ? `?${searchStr}` : '';\n  };\n}\n\nconst defaultFetchServerDataFn = async ({\n  router,\n  routeMatch\n}) => {\n  const next = router.buildNext({\n    to: '.',\n    search: d => ({\n      ...(d ?? {}),\n      __data: {\n        matchId: routeMatch.id\n      }\n    })\n  });\n  const res = await fetch(next.href, {\n    method: 'GET',\n    signal: routeMatch.abortController.signal\n  });\n  if (res.ok) {\n    return res.json();\n  }\n  throw new Error('Failed to fetch match data');\n};\nclass Router {\n  #unsubHistory;\n  startedLoadingAt = Date.now();\n  resolveNavigation = () => {};\n  constructor(options) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn\n    };\n    this.__store = new Store(getInitialRouterState(), {\n      onUpdate: () => {\n        this.state = this.__store.state;\n      }\n    });\n    this.state = this.__store.state;\n    this.update(options);\n    const next = this.buildNext({\n      hash: true,\n      fromCurrent: true,\n      search: true,\n      state: true\n    });\n    if (this.state.location.href !== next.href) {\n      this.#commitLocation({\n        ...next,\n        replace: true\n      });\n    }\n  }\n  reset = () => {\n    this.__store.setState(s => Object.assign(s, getInitialRouterState()));\n  };\n  mount = () => {\n    // Mount only does anything on the client\n    if (!isServer) {\n      // If the router matches are empty, start loading the matches\n      if (!this.state.matches.length) {\n        this.safeLoad();\n      }\n    }\n    return () => {};\n  };\n  update = opts => {\n    Object.assign(this.options, opts);\n    this.context = this.options.context;\n    if (!this.history || this.options.history && this.options.history !== this.history) {\n      if (this.#unsubHistory) {\n        this.#unsubHistory();\n      }\n      this.history = this.options.history ?? (isServer ? createMemoryHistory() : createBrowserHistory());\n      const parsedLocation = this.#parseLocation();\n      this.__store.setState(s => ({\n        ...s,\n        resolvedLocation: parsedLocation,\n        location: parsedLocation\n      }));\n      this.#unsubHistory = this.history.listen(() => {\n        this.safeLoad({\n          next: this.#parseLocation(this.state.location)\n        });\n      });\n    }\n    const {\n      basepath,\n      routeTree\n    } = this.options;\n    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`;\n    if (routeTree && routeTree !== this.routeTree) {\n      this.#buildRouteTree(routeTree);\n    }\n    return this;\n  };\n  buildNext = opts => {\n    const next = this.#buildLocation(opts);\n    const __matches = this.matchRoutes(next.pathname, next.search);\n    return this.#buildLocation({\n      ...opts,\n      __matches\n    });\n  };\n  cancelMatches = () => {\n    [...this.state.matches].forEach(match => {\n      match.cancel();\n    });\n  };\n  safeLoad = opts => {\n    this.load(opts).catch(err => {\n      console.warn(err);\n      invariant(false, 'Encountered an error during router.load()! ☝️.');\n    });\n  };\n  load = async opts => {\n    this.#createNavigationPromise();\n    let now = Date.now();\n    const startedAt = now;\n    this.startedLoadingAt = startedAt;\n\n    // Cancel any pending matches\n    this.cancelMatches();\n    let matches;\n    this.__store.batch(() => {\n      if (opts?.next) {\n        // Ingest the new location\n        this.__store.setState(s => ({\n          ...s,\n          location: opts.next\n        }));\n      }\n\n      // Match the routes\n      matches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {\n        strictParseParams: true,\n        debug: true\n      });\n      this.__store.setState(s => ({\n        ...s,\n        status: 'pending',\n        matches\n      }));\n    });\n    matches.forEach(match => {\n      match.__commit();\n    });\n\n    // Load the matches\n    await this.loadMatches(matches, this.state.location);\n    if (this.startedLoadingAt !== startedAt) {\n      // Ignore side-effects of outdated side-effects\n      return this.navigationPromise;\n    }\n    const previousMatches = this.state.matches;\n    const exiting = [],\n      staying = [];\n    previousMatches.forEach(d => {\n      if (matches.find(dd => dd.id === d.id)) {\n        staying.push(d);\n      } else {\n        exiting.push(d);\n      }\n    });\n    const entering = matches.filter(d => {\n      return !previousMatches.find(dd => dd.id === d.id);\n    });\n    now = Date.now();\n    exiting.forEach(d => {\n      d.__onExit?.({\n        params: d.params,\n        search: d.state.routeSearch\n      });\n\n      // Clear non-loading error states when match leaves\n      if (d.state.status === 'error') {\n        this.__store.setState(s => ({\n          ...s,\n          status: 'idle',\n          error: undefined\n        }));\n      }\n    });\n    staying.forEach(d => {\n      d.route.options.onTransition?.({\n        params: d.params,\n        search: d.state.routeSearch\n      });\n    });\n    entering.forEach(d => {\n      d.__onExit = d.route.options.onLoaded?.({\n        params: d.params,\n        search: d.state.search\n      });\n    });\n    const prevLocation = this.state.location;\n    this.__store.setState(s => ({\n      ...s,\n      status: 'idle',\n      resolvedLocation: s.location,\n      matches\n    }));\n    if (prevLocation.href !== this.state.location.href) {\n      this.options.onRouteChange?.();\n    }\n    this.resolveNavigation();\n  };\n  getRoute = id => {\n    const route = this.routesById[id];\n    invariant(route, `Route with id \"${id}\" not found`);\n    return route;\n  };\n  loadRoute = async (navigateOpts = this.state.location) => {\n    const next = this.buildNext(navigateOpts);\n    const matches = this.matchRoutes(next.pathname, next.search, {\n      strictParseParams: true\n    });\n    await this.loadMatches(matches, next);\n    return matches;\n  };\n  preloadRoute = async (navigateOpts = this.state.location) => {\n    const next = this.buildNext(navigateOpts);\n    const matches = this.matchRoutes(next.pathname, next.search, {\n      strictParseParams: true\n    });\n    await this.loadMatches(matches, next, {\n      preload: true\n    });\n    return matches;\n  };\n  matchRoutes = (pathname, search, opts) => {\n    // If there's no route tree, we can't match anything\n    if (!this.flatRoutes.length) {\n      return [];\n    }\n    let routeParams = {};\n    let foundRoute = this.flatRoutes.find(route => {\n      const matchedParams = matchPathname(this.basepath, pathname, {\n        to: route.fullPath,\n        caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive\n      });\n      if (matchedParams) {\n        routeParams = matchedParams;\n        return true;\n      }\n      return false;\n    });\n    if (!foundRoute) {\n      return [];\n    }\n    let matchedRoutes = [foundRoute];\n    while (foundRoute?.parentRoute) {\n      foundRoute = foundRoute.parentRoute;\n      if (foundRoute) matchedRoutes.unshift(foundRoute);\n    }\n\n    // Alright, by now we should have all of our\n    // matching routes and their param pairs, let's\n    // Turn them into actual `Match` objects and\n    // accumulate the params into a single params bag\n    let allParams = {};\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n    const existingMatches = [...this.state.matches];\n    const matches = matchedRoutes.map(route => {\n      let parsedParams;\n      try {\n        parsedParams = route.options.parseParams?.(routeParams) ?? routeParams;\n      } catch (err) {\n        if (opts?.strictParseParams) {\n          throw err;\n        }\n      }\n\n      // Add the parsed params to the accumulated params bag\n      Object.assign(allParams, parsedParams);\n      const interpolatedPath = interpolatePath(route.path, allParams);\n      const matchId = interpolatePath(route.id, allParams, true) + (route.options.getKey?.({\n        params: allParams,\n        search\n      }) ?? '');\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n      const existingMatch = existingMatches.find(d => d.id === matchId);\n      if (existingMatch) {\n        return existingMatch;\n      }\n      return new RouteMatch(this, route, {\n        id: matchId,\n        params: allParams,\n        pathname: joinPaths([this.basepath, interpolatedPath])\n      });\n    }).filter((d, i, all) => {\n      // Filter out any duplicate matches\n      // I honesty don't know why this is necessary, but it is and it's safe for now\n      // Someday someone will figure out why my logic is wrong and fix it to just\n      // not create duplicate matches in the first place\n      return all.findIndex(dd => dd.id === d.id) === i;\n    });\n    return matches;\n  };\n  loadMatches = async (resolvedMatches, location, opts) => {\n    let firstBadMatchIndex;\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      await Promise.all(resolvedMatches.map(async (match, index) => {\n        try {\n          await match.route.options.beforeLoad?.({\n            router: this,\n            match\n          });\n        } catch (err) {\n          if (isRedirect(err)) {\n            throw err;\n          }\n          firstBadMatchIndex = firstBadMatchIndex ?? index;\n          const errorHandler = match.route.options.onBeforeLoadError ?? match.route.options.onError;\n          try {\n            errorHandler?.(err);\n          } catch (errorHandlerErr) {\n            if (isRedirect(errorHandlerErr)) {\n              throw errorHandlerErr;\n            }\n            match.__store.setState(s => ({\n              ...s,\n              error: errorHandlerErr,\n              status: 'error',\n              updatedAt: Date.now()\n            }));\n            return;\n          }\n          match.__store.setState(s => ({\n            ...s,\n            error: err,\n            status: 'error',\n            updatedAt: Date.now()\n          }));\n        }\n      }));\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.navigate(err);\n        }\n        return;\n      }\n      throw err; // we should never end up here\n    }\n\n    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex);\n    const matchPromises = validResolvedMatches.map(async (match, index) => {\n      const parentMatch = validResolvedMatches[index - 1];\n      match.__load({\n        preload: opts?.preload,\n        location,\n        parentMatch\n      });\n      await match.__loadPromise;\n      if (parentMatch) {\n        await parentMatch.__loadPromise;\n      }\n    });\n    await Promise.all(matchPromises);\n  };\n  reload = () => {\n    this.navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true\n    });\n  };\n  resolvePath = (from, path) => {\n    return resolvePath(this.basepath, from, cleanPath(path));\n  };\n  navigate = async ({\n    from,\n    to = '',\n    search,\n    hash,\n    replace,\n    params\n  }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to);\n    const fromString = typeof from === 'undefined' ? from : String(from);\n    let isExternal;\n    try {\n      new URL(`${toString}`);\n      isExternal = true;\n    } catch (e) {}\n    invariant(!isExternal, 'Attempting to navigate to external url with this.navigate!');\n    return this.#commitLocation({\n      from: fromString,\n      to: toString,\n      search,\n      hash,\n      replace,\n      params\n    });\n  };\n  matchRoute = (location, opts) => {\n    location = {\n      ...location,\n      to: location.to ? this.resolvePath(location.from ?? '', location.to) : undefined\n    };\n    const next = this.buildNext(location);\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false;\n    }\n    const baseLocation = opts?.pending ? this.state.location : this.state.resolvedLocation;\n    if (!baseLocation) {\n      return false;\n    }\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname\n    });\n    if (!match) {\n      return false;\n    }\n    if (opts?.includeSearch ?? true) {\n      return partialDeepEqual(baseLocation.search, next.search) ? match : false;\n    }\n    return match;\n  };\n  buildLink = ({\n    from,\n    to = '.',\n    search,\n    params,\n    hash,\n    target,\n    replace,\n    activeOptions,\n    preload,\n    preloadDelay: userPreloadDelay,\n    disabled\n  }) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    try {\n      new URL(`${to}`);\n      return {\n        type: 'external',\n        href: to\n      };\n    } catch (e) {}\n    const nextOpts = {\n      from,\n      to,\n      search,\n      params,\n      hash,\n      replace\n    };\n    const next = this.buildNext(nextOpts);\n    preload = preload ?? this.options.defaultPreload;\n    const preloadDelay = userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0;\n\n    // Compare path/hash for matches\n    const currentPathSplit = this.state.location.pathname.split('/');\n    const nextPathSplit = next.pathname.split('/');\n    const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact ? this.state.location.pathname === next.pathname : pathIsFuzzyEqual;\n    const hashTest = activeOptions?.includeHash ? this.state.location.hash === next.hash : true;\n    const searchTest = activeOptions?.includeSearch ?? true ? partialDeepEqual(this.state.location.search, next.search) : true;\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest;\n\n    // The click handler\n    const handleClick = e => {\n      if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {\n        e.preventDefault();\n\n        // All is well? Navigate!\n        this.#commitLocation(nextOpts);\n      }\n    };\n\n    // The click handler\n    const handleFocus = e => {\n      if (preload) {\n        this.preloadRoute(nextOpts).catch(err => {\n          console.warn(err);\n          console.warn('Error preloading route! ☝️');\n        });\n      }\n    };\n    const handleTouchStart = e => {\n      this.preloadRoute(nextOpts).catch(err => {\n        console.warn(err);\n        console.warn('Error preloading route! ☝️');\n      });\n    };\n    const handleEnter = e => {\n      const target = e.target || {};\n      if (preload) {\n        if (target.preloadTimeout) {\n          return;\n        }\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null;\n          this.preloadRoute(nextOpts).catch(err => {\n            console.warn(err);\n            console.warn('Error preloading route! ☝️');\n          });\n        }, preloadDelay);\n      }\n    };\n    const handleLeave = e => {\n      const target = e.target || {};\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout);\n        target.preloadTimeout = null;\n      }\n    };\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled\n    };\n  };\n  dehydrate = () => {\n    return {\n      state: {\n        ...pick(this.state, ['location', 'status', 'lastUpdated'])\n        // matches: this.state.matches.map((m) => ({\n        //   id: m.id,\n        //   promiseKeys: Object.keys(m.__promisesByKey),\n        // })),\n      }\n    };\n  };\n\n  hydrate = async __do_not_use_server_ctx => {\n    let _ctx = __do_not_use_server_ctx;\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__;\n    }\n    invariant(_ctx, 'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?');\n    const ctx = _ctx;\n    this.options.hydrate?.(ctx.payload);\n    this.__store.setState(s => {\n      return {\n        ...s,\n        ...ctx.router.state,\n        matches: s.matches,\n        resolvedLocation: ctx.router.state.location\n      };\n    });\n    await this.load();\n\n    // this.state.matches.forEach((m) => {\n    //   m.__promiseKeys =\n    //     ctx.router.state.matches.find((d) => d.id === m.id)?.promiseKeys ?? []\n    // })\n\n    return;\n  };\n  injectedHtml = [];\n  injectHtml = async html => {\n    this.injectedHtml.push(html);\n  };\n  dehydrateData = (key, getData) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key);\n      this.injectHtml(async () => {\n        const data = typeof getData === 'function' ? await getData() : getData;\n        return `<script>window[\"__TSR__DEHYRATED__${escapeJSON(strKey)}\"] = ${JSON.stringify(data)}</script>`;\n      });\n      return () => this.hydrateData(key);\n    }\n    return () => undefined;\n  };\n  hydrateData = key => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key);\n      return window[`__TSR__DEHYRATED__${strKey}`];\n    }\n    return undefined;\n  };\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   this.state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n\n  #buildRouteTree = routeTree => {\n    this.routeTree = routeTree;\n    this.routesById = {};\n    this.routesByPath = {};\n    this.flatRoutes = [];\n    const recurseRoutes = routes => {\n      routes.forEach((route, i) => {\n        route.init({\n          originalIndex: i,\n          router: this\n        });\n        const existingRoute = this.routesById[route.id];\n        invariant(!existingRoute, `Duplicate routes found with id: ${String(route.id)}`);\n        this.routesById[route.id] = route;\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath);\n          if (!this.routesByPath[trimmedFullPath] || route.fullPath.endsWith('/')) {\n            this.routesByPath[trimmedFullPath] = route;\n          }\n        }\n        const children = route.children;\n        if (children?.length) {\n          recurseRoutes(children);\n        }\n      });\n    };\n    recurseRoutes([routeTree]);\n    this.flatRoutes = Object.values(this.routesByPath).map((d, i) => {\n      const trimmed = trimPath(d.fullPath);\n      const parsed = parsePathname(trimmed);\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift();\n      }\n      const score = parsed.map(d => {\n        if (d.type === 'param') {\n          return 0.5;\n        }\n        if (d.type === 'wildcard') {\n          return 0.25;\n        }\n        return 1;\n      });\n      return {\n        child: d,\n        trimmed,\n        parsed,\n        index: i,\n        score\n      };\n    }).sort((a, b) => {\n      let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0;\n      if (isIndex !== 0) return isIndex;\n      const length = Math.min(a.score.length, b.score.length);\n\n      // Sort by length of score\n      if (a.score.length !== b.score.length) {\n        return b.score.length - a.score.length;\n      }\n\n      // Sort by min available score\n      for (let i = 0; i < length; i++) {\n        if (a.score[i] !== b.score[i]) {\n          return b.score[i] - a.score[i];\n        }\n      }\n\n      // Sort by min available parsed value\n      for (let i = 0; i < length; i++) {\n        if (a.parsed[i].value !== b.parsed[i].value) {\n          return a.parsed[i].value > b.parsed[i].value ? 1 : -1;\n        }\n      }\n\n      // Sort by length of trimmed full path\n      if (a.trimmed !== b.trimmed) {\n        return a.trimmed > b.trimmed ? 1 : -1;\n      }\n\n      // Sort by original index\n      return a.index - b.index;\n    }).map((d, i) => {\n      d.child.rank = i;\n      return d.child;\n    });\n  };\n  #parseLocation = previousLocation => {\n    let {\n      pathname,\n      search,\n      hash,\n      state\n    } = this.history.location;\n    const parsedSearch = this.options.parseSearch(search);\n    return {\n      pathname: pathname,\n      searchStr: search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: hash.split('#').reverse()[0] ?? '',\n      href: `${pathname}${search}${hash}`,\n      state: state,\n      key: state?.key || '__init__'\n    };\n  };\n  #buildLocation = (dest = {}) => {\n    dest.fromCurrent = dest.fromCurrent ?? dest.to === '';\n    const fromPathname = dest.fromCurrent ? this.state.location.pathname : dest.from ?? this.state.location.pathname;\n    let pathname = resolvePath(this.basepath ?? '/', fromPathname, `${dest.to ?? ''}`);\n    const fromMatches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {\n      strictParseParams: true\n    });\n    const prevParams = {\n      ...last(fromMatches)?.params\n    };\n    let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);\n    if (nextParams) {\n      dest.__matches?.map(d => d.route.options.stringifyParams).filter(Boolean).forEach(fn => {\n        nextParams = {\n          ...nextParams,\n          ...fn(nextParams)\n        };\n      });\n    }\n    pathname = interpolatePath(pathname, nextParams ?? {});\n    const preSearchFilters = dest.__matches?.map(match => match.route.options.preSearchFilters ?? []).flat().filter(Boolean) ?? [];\n    const postSearchFilters = dest.__matches?.map(match => match.route.options.postSearchFilters ?? []).flat().filter(Boolean) ?? [];\n\n    // Pre filters first\n    const preFilteredSearch = preSearchFilters?.length ? preSearchFilters?.reduce((prev, next) => next(prev), this.state.location.search) : this.state.location.search;\n\n    // Then the link/navigate function\n    const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true\n    : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n    : preSearchFilters?.length ? preFilteredSearch // Preserve resolvedFrom filters\n    : {};\n\n    // Then post filters\n    const postFilteredSearch = postSearchFilters?.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;\n    const search = replaceEqualDeep(this.state.location.search, postFilteredSearch);\n    const searchStr = this.options.stringifySearch(search);\n    const hash = dest.hash === true ? this.state.location.hash : functionalUpdate(dest.hash, this.state.location.hash);\n    const hashStr = hash ? `#${hash}` : '';\n    const nextState = dest.state === true ? this.state.location.state : functionalUpdate(dest.state, this.state.location.state);\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: nextState,\n      hash,\n      href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),\n      key: dest.key\n    };\n  };\n  #commitLocation = async location => {\n    const next = this.buildNext(location);\n    const id = '' + Date.now() + Math.random();\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout);\n    let nextAction = 'replace';\n    if (!location.replace) {\n      nextAction = 'push';\n    }\n    const isSameUrl = this.state.location.href === next.href;\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace';\n    }\n    const href = `${next.pathname}${next.searchStr}${next.hash ? `#${next.hash}` : ''}`;\n    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {\n      id,\n      ...next.state\n    });\n    return this.#createNavigationPromise();\n  };\n  #createNavigationPromise = () => {\n    const previousNavigationResolve = this.resolveNavigation;\n    this.navigationPromise = new Promise(resolve => {\n      this.resolveNavigation = () => {\n        resolve();\n        previousNavigationResolve();\n      };\n    });\n    return this.navigationPromise;\n  };\n}\n\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !window.document.createElement;\nfunction getInitialRouterState() {\n  return {\n    status: 'idle',\n    resolvedLocation: null,\n    location: null,\n    matches: [],\n    lastUpdated: Date.now()\n  };\n}\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\nfunction redirect(opts) {\n  opts.isRedirect = true;\n  return opts;\n}\nfunction isRedirect(obj) {\n  return !!obj?.isRedirect;\n}\nfunction escapeJSON(jsonString) {\n  return jsonString.replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n  .replace(/'/g, \"\\\\'\") // Escape single quotes\n  .replace(/\"/g, '\\\\\"'); // Escape double quotes\n}\n\nconst componentTypes = ['component', 'errorComponent', 'pendingComponent'];\nclass RouteMatch {\n  abortController = new AbortController();\n  constructor(router, route, opts) {\n    Object.assign(this, {\n      route,\n      router,\n      id: opts.id,\n      pathname: opts.pathname,\n      params: opts.params,\n      __store: new Store({\n        updatedAt: 0,\n        routeSearch: {},\n        search: {},\n        status: 'pending',\n        loader: undefined\n      }, {\n        onUpdate: () => {\n          this.state = this.__store.state;\n        }\n      })\n    });\n    this.state = this.__store.state;\n    componentTypes.map(async type => {\n      const component = this.route.options[type];\n      this[type] = component;\n    });\n    this.__loadPromise = new Promise(r => {\n      this.__loadPromiseResolve = r;\n    });\n    if (this.state.status === 'pending' && !this.#hasLoaders()) {\n      this.__store.setState(s => ({\n        ...s,\n        status: 'success'\n      }));\n      this.__loadPromiseResolve?.();\n    }\n  }\n  #hasLoaders = () => {\n    return !!(this.route.options.loader || componentTypes.some(d => this.route.options[d]?.preload));\n  };\n  __commit = () => {\n    const {\n      routeSearch,\n      search,\n      context,\n      routeContext\n    } = this.#resolveInfo({\n      location: this.router.state.location\n    });\n    this.context = context;\n    this.routeContext = routeContext;\n    this.__store.setState(s => ({\n      ...s,\n      routeSearch: replaceEqualDeep(s.routeSearch, routeSearch),\n      search: replaceEqualDeep(s.search, search)\n    }));\n  };\n  cancel = () => {\n    this.abortController?.abort();\n  };\n  #resolveSearchInfo = opts => {\n    // Validate the search params and stabilize them\n    const parentSearchInfo = this.parentMatch ? this.parentMatch.#resolveSearchInfo(opts) : {\n      search: opts.location.search,\n      routeSearch: opts.location.search\n    };\n    try {\n      const validator = typeof this.route.options.validateSearch === 'object' ? this.route.options.validateSearch.parse : this.route.options.validateSearch;\n      const routeSearch = validator?.(parentSearchInfo.search) ?? {};\n      const search = {\n        ...parentSearchInfo.search,\n        ...routeSearch\n      };\n      return {\n        routeSearch,\n        search\n      };\n    } catch (err) {\n      if (isRedirect(err)) {\n        throw err;\n      }\n      const errorHandler = this.route.options.onValidateSearchError ?? this.route.options.onError;\n      errorHandler?.(err);\n      const error = new Error('Invalid search params found', {\n        cause: err\n      });\n      error.code = 'INVALID_SEARCH_PARAMS';\n      throw error;\n    }\n  };\n  #resolveInfo = opts => {\n    const {\n      search,\n      routeSearch\n    } = this.#resolveSearchInfo(opts);\n    try {\n      const routeContext = this.route.options.getContext?.({\n        parentContext: this.parentMatch?.routeContext ?? {},\n        context: this.parentMatch?.context ?? this.router?.options.context ?? {},\n        params: this.params,\n        search\n      }) || {};\n      const context = {\n        ...(this.parentMatch?.context ?? this.router?.options.context),\n        ...routeContext\n      };\n      return {\n        routeSearch,\n        search,\n        context,\n        routeContext\n      };\n    } catch (err) {\n      this.route.options.onError?.(err);\n      throw err;\n    }\n  };\n  __load = async opts => {\n    this.parentMatch = opts.parentMatch;\n    let info;\n    try {\n      info = this.#resolveInfo(opts);\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.router.navigate(err);\n        }\n        return;\n      }\n      this.__store.setState(s => ({\n        ...s,\n        status: 'error',\n        error: err\n      }));\n\n      // Do not proceed with loading the route\n      return;\n    }\n    const {\n      routeSearch,\n      search,\n      context,\n      routeContext\n    } = info;\n    const loaderOpts = {\n      params: this.params,\n      routeSearch,\n      search,\n      signal: this.abortController.signal,\n      preload: !!opts?.preload,\n      routeContext,\n      context\n    };\n    this.__loadPromise = Promise.resolve().then(async () => {\n      const loadId = '' + Date.now() + Math.random();\n      this.#latestId = loadId;\n      const checkLatest = () => {\n        return loadId !== this.#latestId ? this.__loadPromise : undefined;\n      };\n      let latestPromise;\n      const componentsPromise = (async () => {\n        // then run all component and data loaders in parallel\n        // For each component type, potentially load it asynchronously\n\n        await Promise.all(componentTypes.map(async type => {\n          const component = this.route.options[type];\n          if (component?.preload) {\n            await component.preload();\n          }\n        }));\n      })();\n      const loaderPromise = Promise.resolve().then(() => {\n        if (this.route.options.loader) {\n          return this.route.options.loader(loaderOpts);\n        }\n        return;\n      });\n      try {\n        const [_, loader] = await Promise.all([componentsPromise, loaderPromise]);\n        if (latestPromise = checkLatest()) return await latestPromise;\n\n        // Object.keys(loader ?? {}).forEach((key) => {\n        //   const value = loader[key]\n        //   if (value instanceof Promise || value?.then) {\n        //     // if (this.__promisesByKey[key]) {\n        //     //   return\n        //     // }\n\n        //     if (typeof document === 'undefined') {\n        //       this.__promisesByKey[key] = {\n        //         status: 'pending',\n        //         promise: value,\n        //         data: undefined,\n        //         resolve: () => {},\n        //       }\n\n        //       value.then((d: any) => {\n        //         this.__promisesByKey[key]!.status = 'resolved'\n        //         this.__promisesByKey[key]!.data = d\n        //       })\n        //     } else {\n        //       const promise = createPromise()\n        //       this.__promisesByKey[key] = {\n        //         status: 'pending',\n        //         promise,\n        //         data: undefined,\n        //         resolve: (d: any) => {\n        //           // @ts-ignore\n        //           promise.resolve()\n        //           this.__promisesByKey[key]!.status = 'resolved'\n        //           this.__promisesByKey[key]!.data = d\n        //         },\n        //       }\n\n        //       if (!this.__promiseKeys.includes(key)) {\n        //         value.then(this.__promisesByKey[key]!.resolve)\n        //       }\n        //     }\n\n        //     loader[key] = this.__promisesByKey[key]\n        //   }\n        // })\n\n        if (!opts.preload) {\n          this.__store.setState(s => ({\n            ...s,\n            error: undefined,\n            status: 'success',\n            updatedAt: Date.now(),\n            loader\n          }));\n        }\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!opts?.preload) {\n            this.router.navigate(err);\n          }\n          return;\n        }\n        const errorHandler = this.route.options.onLoadError ?? this.route.options.onError;\n        try {\n          errorHandler?.(err);\n        } catch (errorHandlerErr) {\n          if (isRedirect(errorHandlerErr)) {\n            if (!opts?.preload) {\n              this.router.navigate(errorHandlerErr);\n            }\n            return;\n          }\n          this.__store.setState(s => ({\n            ...s,\n            error: errorHandlerErr,\n            status: 'error',\n            updatedAt: Date.now()\n          }));\n          return;\n        }\n        this.__store.setState(s => ({\n          ...s,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now()\n        }));\n      } finally {\n        this.__loadPromiseResolve?.();\n        delete this.__loadPromise;\n      }\n    });\n    return this.__loadPromise;\n  };\n  #latestId = '';\n}\n\nexport { Block, ErrorComponent, Link, MatchRoute, Navigate, Outlet, RootRoute, Route, RouteMatch, Router, RouterProvider, cleanPath, createBrowserHistory, createHashHistory, createMemoryHistory, decode, defaultFetchServerDataFn, defaultParseSearch, defaultStringifySearch, encode, functionalUpdate, interpolatePath, isPlainObject, isRedirect, joinPaths, last, lazy, matchByPath, matchPathname, matchesContext, parsePathname, parseSearchWith, partialDeepEqual, pick, redirect, replaceEqualDeep, resolvePath, rootRouteId, routerContext, stringifySearchWith, trimPath, trimPathLeft, trimPathRight, useBlocker, useDehydrate, useHydrate, useInjectHtml, useLinkProps, useLoader, useMatch, useMatchRoute, useMatches, useNavigate, useParams, useRouter, useRouterContext, useSearch };\n//# sourceMappingURL=index.js.map\n","import React from 'react'\n\nconst getItem = (key: string): unknown => {\n  try {\n    const itemValue = localStorage.getItem(key)\n    if (typeof itemValue === 'string') {\n      return JSON.parse(itemValue)\n    }\n    return undefined\n  } catch {\n    return undefined\n  }\n}\n\nexport default function useLocalStorage<T>(\n  key: string,\n  defaultValue: T | undefined,\n): [T | undefined, (newVal: T | ((prevVal: T) => T)) => void] {\n  const [value, setValue] = React.useState<T>()\n\n  React.useEffect(() => {\n    const initialValue = getItem(key) as T | undefined\n\n    if (typeof initialValue === 'undefined' || initialValue === null) {\n      setValue(\n        typeof defaultValue === 'function' ? defaultValue() : defaultValue,\n      )\n    } else {\n      setValue(initialValue)\n    }\n  }, [defaultValue, key])\n\n  const setter = React.useCallback(\n    (updater: any) => {\n      setValue((old) => {\n        let newVal = updater\n\n        if (typeof updater == 'function') {\n          newVal = updater(old)\n        }\n        try {\n          localStorage.setItem(key, JSON.stringify(newVal))\n        } catch {}\n\n        return newVal\n      })\n    },\n    [key],\n  )\n\n  return [value, setter]\n}\n","import React from 'react'\n\nexport const defaultTheme = {\n  background: '#0b1521',\n  backgroundAlt: '#132337',\n  foreground: 'white',\n  gray: '#3f4e60',\n  grayAlt: '#222e3e',\n  inputBackgroundColor: '#fff',\n  inputTextColor: '#000',\n  success: '#00ab52',\n  danger: '#ff0085',\n  active: '#006bff',\n  warning: '#ffb200',\n} as const\n\nexport type Theme = typeof defaultTheme\ninterface ProviderProps {\n  theme: Theme\n  children?: React.ReactNode\n}\n\nconst ThemeContext = React.createContext(defaultTheme)\n\nexport function ThemeProvider({ theme, ...rest }: ProviderProps) {\n  return <ThemeContext.Provider value={theme} {...rest} />\n}\n\nexport function useTheme() {\n  return React.useContext(ThemeContext)\n}\n","import React from 'react'\nimport {\n  AnyRootRoute,\n  AnyRoute,\n  AnyRouteMatch,\n  RouteMatch,\n} from '@tanstack/router'\n\nimport { Theme, useTheme } from './theme'\nimport useMediaQuery from './useMediaQuery'\n\nexport const isServer = typeof window === 'undefined'\n\ntype StyledComponent<T> = T extends 'button'\n  ? React.DetailedHTMLProps<\n      React.ButtonHTMLAttributes<HTMLButtonElement>,\n      HTMLButtonElement\n    >\n  : T extends 'input'\n  ? React.DetailedHTMLProps<\n      React.InputHTMLAttributes<HTMLInputElement>,\n      HTMLInputElement\n    >\n  : T extends 'select'\n  ? React.DetailedHTMLProps<\n      React.SelectHTMLAttributes<HTMLSelectElement>,\n      HTMLSelectElement\n    >\n  : T extends keyof HTMLElementTagNameMap\n  ? React.HTMLAttributes<HTMLElementTagNameMap[T]>\n  : never\n\nexport function getStatusColor(match: AnyRouteMatch, theme: Theme) {\n  return match.state.status === 'pending'\n    ? theme.active\n    : match.state.status === 'error'\n    ? theme.danger\n    : match.state.status === 'success'\n    ? theme.success\n    : theme.gray\n}\n\nexport function getRouteStatusColor(\n  matches: AnyRouteMatch[],\n  route: AnyRoute | AnyRootRoute,\n  theme: Theme,\n) {\n  const found = matches.find((d) => d.route === route)\n\n  return found\n    ? found.route.status === 'pending'\n      ? theme.active\n      : found.state.status === 'error'\n      ? theme.danger\n      : found.state.status === 'success'\n      ? theme.success\n      : theme.gray\n    : theme.gray\n}\n\ntype Styles =\n  | React.CSSProperties\n  | ((props: Record<string, any>, theme: Theme) => React.CSSProperties)\n\nexport function styled<T extends keyof HTMLElementTagNameMap>(\n  type: T,\n  newStyles: Styles,\n  queries: Record<string, Styles> = {},\n) {\n  return React.forwardRef<HTMLElementTagNameMap[T], StyledComponent<T>>(\n    ({ style, ...rest }, ref) => {\n      const theme = useTheme()\n\n      const mediaStyles = Object.entries(queries).reduce(\n        (current, [key, value]) => {\n          // eslint-disable-next-line react-hooks/rules-of-hooks\n          return useMediaQuery(key)\n            ? {\n                ...current,\n                ...(typeof value === 'function' ? value(rest, theme) : value),\n              }\n            : current\n        },\n        {},\n      )\n\n      return React.createElement(type, {\n        ...rest,\n        style: {\n          ...(typeof newStyles === 'function'\n            ? newStyles(rest, theme)\n            : newStyles),\n          ...style,\n          ...mediaStyles,\n        },\n        ref,\n      })\n    },\n  )\n}\n\nexport function useIsMounted() {\n  const mountedRef = React.useRef(false)\n  const isMounted = React.useCallback(() => mountedRef.current, [])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    mountedRef.current = true\n    return () => {\n      mountedRef.current = false\n    }\n  }, [])\n\n  return isMounted\n}\n\n/**\n * Displays a string regardless the type of the data\n * @param {unknown} value Value to be stringified\n */\nexport const displayValue = (value: unknown) => {\n  const name = Object.getOwnPropertyNames(Object(value))\n  const newValue = typeof value === 'bigint' ? `${value.toString()}n` : value\n\n  return JSON.stringify(newValue, name)\n}\n\n/**\n * This hook is a safe useState version which schedules state updates in microtasks\n * to prevent updating a component state while React is rendering different components\n * or when the component is not mounted anymore.\n */\nexport function useSafeState<T>(initialState: T): [T, (value: T) => void] {\n  const isMounted = useIsMounted()\n  const [state, setState] = React.useState(initialState)\n\n  const safeSetState = React.useCallback(\n    (value: T) => {\n      scheduleMicrotask(() => {\n        if (isMounted()) {\n          setState(value)\n        }\n      })\n    },\n    [isMounted],\n  )\n\n  return [state, safeSetState]\n}\n\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\nfunction scheduleMicrotask(callback: () => void) {\n  Promise.resolve()\n    .then(callback)\n    .catch((error) =>\n      setTimeout(() => {\n        throw error\n      }),\n    )\n}\n\nexport function multiSortBy<T>(\n  arr: T[],\n  accessors: ((item: T) => any)[] = [(d) => d],\n): T[] {\n  return arr\n    .map((d, i) => [d, i] as const)\n    .sort(([a, ai], [b, bi]) => {\n      for (const accessor of accessors) {\n        const ao = accessor(a)\n        const bo = accessor(b)\n\n        if (typeof ao === 'undefined') {\n          if (typeof bo === 'undefined') {\n            continue\n          }\n          return 1\n        }\n\n        if (ao === bo) {\n          continue\n        }\n\n        return ao > bo ? 1 : -1\n      }\n\n      return ai - bi\n    })\n    .map(([d]) => d)\n}\n","import React from 'react'\n\nexport default function useMediaQuery(query: string): boolean | undefined {\n  // Keep track of the preference in state, start with the current match\n  const [isMatch, setIsMatch] = React.useState(() => {\n    if (typeof window !== 'undefined') {\n      return window.matchMedia && window.matchMedia(query).matches\n    }\n    return\n  })\n\n  // Watch for changes\n  React.useEffect(() => {\n    if (typeof window !== 'undefined') {\n      if (!window.matchMedia) {\n        return\n      }\n\n      // Create a matcher\n      const matcher = window.matchMedia(query)\n\n      // Create our handler\n      const onChange = ({ matches }: { matches: boolean }) =>\n        setIsMatch(matches)\n\n      // Listen for changes\n      matcher.addListener(onChange)\n\n      return () => {\n        // Stop listening for changes\n        matcher.removeListener(onChange)\n      }\n    }\n\n    return\n  }, [isMatch, query, setIsMatch])\n\n  return isMatch\n}\n","import { styled } from './utils'\n\nexport const Panel = styled(\n  'div',\n  (_props, theme) => ({\n    fontSize: 'clamp(12px, 1.5vw, 14px)',\n    fontFamily: `sans-serif`,\n    display: 'flex',\n    backgroundColor: theme.background,\n    color: theme.foreground,\n  }),\n  {\n    '(max-width: 700px)': {\n      flexDirection: 'column',\n    },\n    '(max-width: 600px)': {\n      fontSize: '.9em',\n      // flexDirection: 'column',\n    },\n  },\n)\n\nexport const ActivePanel = styled(\n  'div',\n  () => ({\n    flex: '1 1 500px',\n    display: 'flex',\n    flexDirection: 'column',\n    overflow: 'auto',\n    height: '100%',\n  }),\n  {\n    '(max-width: 700px)': (_props, theme) => ({\n      borderTop: `2px solid ${theme.gray}`,\n    }),\n  },\n)\n\nexport const Button = styled('button', (props, theme) => ({\n  appearance: 'none',\n  fontSize: '.9em',\n  fontWeight: 'bold',\n  background: theme.gray,\n  border: '0',\n  borderRadius: '.3em',\n  color: 'white',\n  padding: '.5em',\n  opacity: props.disabled ? '.5' : undefined,\n  cursor: 'pointer',\n}))\n\n// export const QueryKeys = styled('span', {\n//   display: 'inline-block',\n//   fontSize: '0.9em',\n// })\n\n// export const QueryKey = styled('span', {\n//   display: 'inline-flex',\n//   alignItems: 'center',\n//   padding: '.2em .4em',\n//   fontWeight: 'bold',\n//   textShadow: '0 0 10px black',\n//   borderRadius: '.2em',\n// })\n\nexport const Code = styled('code', {\n  fontSize: '.9em',\n})\n\nexport const Input = styled('input', (_props, theme) => ({\n  backgroundColor: theme.inputBackgroundColor,\n  border: 0,\n  borderRadius: '.2em',\n  color: theme.inputTextColor,\n  fontSize: '.9em',\n  lineHeight: `1.3`,\n  padding: '.3em .4em',\n}))\n\nexport const Select = styled(\n  'select',\n  (_props, theme) => ({\n    display: `inline-block`,\n    fontSize: `.9em`,\n    fontFamily: `sans-serif`,\n    fontWeight: 'normal',\n    lineHeight: `1.3`,\n    padding: `.3em 1.5em .3em .5em`,\n    height: 'auto',\n    border: 0,\n    borderRadius: `.2em`,\n    appearance: `none`,\n    WebkitAppearance: 'none',\n    backgroundColor: theme.inputBackgroundColor,\n    backgroundImage: `url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100' fill='%23444444'><polygon points='0,25 100,25 50,75'/></svg>\")`,\n    backgroundRepeat: `no-repeat`,\n    backgroundPosition: `right .55em center`,\n    backgroundSize: `.65em auto, 100%`,\n    color: theme.inputTextColor,\n  }),\n  {\n    '(max-width: 500px)': {\n      display: 'none',\n    },\n  },\n)\n","import * as React from 'react'\n\nimport { displayValue, styled } from './utils'\n\nexport const Entry = styled('div', {\n  fontFamily: 'Menlo, monospace',\n  fontSize: '.7rem',\n  lineHeight: '1.7',\n  outline: 'none',\n  wordBreak: 'break-word',\n})\n\nexport const Label = styled('span', {\n  color: 'white',\n})\n\nexport const LabelButton = styled('button', {\n  cursor: 'pointer',\n  color: 'white',\n})\n\nexport const ExpandButton = styled('button', {\n  cursor: 'pointer',\n  color: 'inherit',\n  font: 'inherit',\n  outline: 'inherit',\n  background: 'transparent',\n  border: 'none',\n  padding: 0,\n})\n\nexport const Value = styled('span', (_props, theme) => ({\n  color: theme.danger,\n}))\n\nexport const SubEntries = styled('div', {\n  marginLeft: '.1em',\n  paddingLeft: '1em',\n  borderLeft: '2px solid rgba(0,0,0,.15)',\n})\n\nexport const Info = styled('span', {\n  color: 'grey',\n  fontSize: '.7em',\n})\n\ntype ExpanderProps = {\n  expanded: boolean\n  style?: React.CSSProperties\n}\n\nexport const Expander = ({ expanded, style = {} }: ExpanderProps) => (\n  <span\n    style={{\n      display: 'inline-block',\n      transition: 'all .1s ease',\n      transform: `rotate(${expanded ? 90 : 0}deg) ${style.transform || ''}`,\n      ...style,\n    }}\n  >\n    ▶\n  </span>\n)\n\ntype Entry = {\n  label: string\n}\n\ntype RendererProps = {\n  handleEntry: HandleEntryFn\n  label?: React.ReactNode\n  value: unknown\n  subEntries: Entry[]\n  subEntryPages: Entry[][]\n  type: string\n  expanded: boolean\n  toggleExpanded: () => void\n  pageSize: number\n  renderer?: Renderer\n}\n\n/**\n * Chunk elements in the array by size\n *\n * when the array cannot be chunked evenly by size, the last chunk will be\n * filled with the remaining elements\n *\n * @example\n * chunkArray(['a','b', 'c', 'd', 'e'], 2) // returns [['a','b'], ['c', 'd'], ['e']]\n */\nexport function chunkArray<T>(array: T[], size: number): T[][] {\n  if (size < 1) return []\n  let i = 0\n  const result: T[][] = []\n  while (i < array.length) {\n    result.push(array.slice(i, i + size))\n    i = i + size\n  }\n  return result\n}\n\ntype Renderer = (props: RendererProps) => JSX.Element\n\nexport const DefaultRenderer: Renderer = ({\n  handleEntry,\n  label,\n  value,\n  subEntries = [],\n  subEntryPages = [],\n  type,\n  expanded = false,\n  toggleExpanded,\n  pageSize,\n  renderer,\n}) => {\n  const [expandedPages, setExpandedPages] = React.useState<number[]>([])\n  const [valueSnapshot, setValueSnapshot] = React.useState(undefined)\n\n  const refreshValueSnapshot = () => {\n    setValueSnapshot((value as () => any)())\n  }\n\n  return (\n    <Entry>\n      {subEntryPages.length ? (\n        <>\n          <ExpandButton onClick={() => toggleExpanded()}>\n            <Expander expanded={expanded} /> {label}{' '}\n            <Info>\n              {String(type).toLowerCase() === 'iterable' ? '(Iterable) ' : ''}\n              {subEntries.length} {subEntries.length > 1 ? `items` : `item`}\n            </Info>\n          </ExpandButton>\n          {expanded ? (\n            subEntryPages.length === 1 ? (\n              <SubEntries>\n                {subEntries.map((entry, index) => handleEntry(entry))}\n              </SubEntries>\n            ) : (\n              <SubEntries>\n                {subEntryPages.map((entries, index) => (\n                  <div key={index}>\n                    <Entry>\n                      <LabelButton\n                        onClick={() =>\n                          setExpandedPages((old) =>\n                            old.includes(index)\n                              ? old.filter((d) => d !== index)\n                              : [...old, index],\n                          )\n                        }\n                      >\n                        <Expander expanded={expanded} /> [{index * pageSize} ...{' '}\n                        {index * pageSize + pageSize - 1}]\n                      </LabelButton>\n                      {expandedPages.includes(index) ? (\n                        <SubEntries>\n                          {entries.map((entry) => handleEntry(entry))}\n                        </SubEntries>\n                      ) : null}\n                    </Entry>\n                  </div>\n                ))}\n              </SubEntries>\n            )\n          ) : null}\n        </>\n      ) : type === 'function' ? (\n        <>\n          <Explorer\n            renderer={renderer}\n            label={\n              <button\n                onClick={refreshValueSnapshot}\n                style={{\n                  appearance: 'none',\n                  border: '0',\n                  background: 'transparent',\n                }}\n              >\n                <Label>{label}</Label> 🔄{' '}\n              </button>\n            }\n            value={valueSnapshot}\n            defaultExpanded={{}}\n          />\n        </>\n      ) : (\n        <>\n          <Label>{label}:</Label> <Value>{displayValue(value)}</Value>\n        </>\n      )}\n    </Entry>\n  )\n}\n\ntype HandleEntryFn = (entry: Entry) => JSX.Element\n\ntype ExplorerProps = Partial<RendererProps> & {\n  renderer?: Renderer\n  defaultExpanded?: true | Record<string, boolean>\n}\n\ntype Property = {\n  defaultExpanded?: boolean | Record<string, boolean>\n  label: string\n  value: unknown\n}\n\nfunction isIterable(x: any): x is Iterable<unknown> {\n  return Symbol.iterator in x\n}\n\nexport default function Explorer({\n  value,\n  defaultExpanded,\n  renderer = DefaultRenderer,\n  pageSize = 100,\n  ...rest\n}: ExplorerProps) {\n  const [expanded, setExpanded] = React.useState(Boolean(defaultExpanded))\n  const toggleExpanded = React.useCallback(() => setExpanded((old) => !old), [])\n\n  let type: string = typeof value\n  let subEntries: Property[] = []\n\n  const makeProperty = (sub: { label: string; value: unknown }): Property => {\n    const subDefaultExpanded =\n      defaultExpanded === true\n        ? { [sub.label]: true }\n        : defaultExpanded?.[sub.label]\n    return {\n      ...sub,\n      defaultExpanded: subDefaultExpanded,\n    }\n  }\n\n  if (Array.isArray(value)) {\n    type = 'array'\n    subEntries = value.map((d, i) =>\n      makeProperty({\n        label: i.toString(),\n        value: d,\n      }),\n    )\n  } else if (\n    value !== null &&\n    typeof value === 'object' &&\n    isIterable(value) &&\n    typeof value[Symbol.iterator] === 'function'\n  ) {\n    type = 'Iterable'\n    subEntries = Array.from(value, (val, i) =>\n      makeProperty({\n        label: i.toString(),\n        value: val,\n      }),\n    )\n  } else if (typeof value === 'object' && value !== null) {\n    type = 'object'\n    subEntries = Object.entries(value).map(([key, val]) =>\n      makeProperty({\n        label: key,\n        value: val,\n      }),\n    )\n  }\n\n  const subEntryPages = chunkArray(subEntries, pageSize)\n\n  return renderer({\n    handleEntry: (entry) => (\n      <Explorer\n        key={entry.label}\n        value={value}\n        renderer={renderer}\n        {...rest}\n        {...entry}\n      />\n    ),\n    type,\n    subEntries,\n    subEntryPages,\n    value,\n    expanded,\n    toggleExpanded,\n    pageSize,\n    ...rest,\n  })\n}\n","import React from 'react'\nimport {\n  last,\n  routerContext,\n  invariant,\n  AnyRouter,\n  useStore,\n  Route,\n  AnyRoute,\n  AnyRootRoute,\n  RouteMatch,\n  trimPath,\n} from '@tanstack/router'\n\nimport useLocalStorage from './useLocalStorage'\nimport {\n  getRouteStatusColor,\n  getStatusColor,\n  multiSortBy,\n  useIsMounted,\n  useSafeState,\n} from './utils'\nimport { Panel, Button, Code, ActivePanel } from './styledComponents'\nimport { ThemeProvider, defaultTheme as theme } from './theme'\n// import { getQueryStatusLabel, getQueryStatusColor } from './utils'\nimport Explorer from './Explorer'\n\nexport type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\n\ninterface DevtoolsOptions {\n  /**\n   * Set this true if you want the dev tools to default to being open\n   */\n  initialIsOpen?: boolean\n  /**\n   * Use this to add props to the panel. For example, you can add className, style (merge and override default style), etc.\n   */\n  panelProps?: React.DetailedHTMLProps<\n    React.HTMLAttributes<HTMLDivElement>,\n    HTMLDivElement\n  >\n  /**\n   * Use this to add props to the close button. For example, you can add className, style (merge and override default style), onClick (extend default handler), etc.\n   */\n  closeButtonProps?: React.DetailedHTMLProps<\n    React.ButtonHTMLAttributes<HTMLButtonElement>,\n    HTMLButtonElement\n  >\n  /**\n   * Use this to add props to the toggle button. For example, you can add className, style (merge and override default style), onClick (extend default handler), etc.\n   */\n  toggleButtonProps?: React.DetailedHTMLProps<\n    React.ButtonHTMLAttributes<HTMLButtonElement>,\n    HTMLButtonElement\n  >\n  /**\n   * The position of the TanStack Router logo to open and close the devtools panel.\n   * Defaults to 'bottom-left'.\n   */\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right'\n  /**\n   * Use this to render the devtools inside a different type of container element for a11y purposes.\n   * Any string which corresponds to a valid intrinsic JSX element is allowed.\n   * Defaults to 'footer'.\n   */\n  containerElement?: string | any\n  /**\n   * A boolean variable indicating if the \"lite\" version of the library is being used\n   */\n  router?: AnyRouter\n}\n\ninterface DevtoolsPanelOptions {\n  /**\n   * The standard React style object used to style a component with inline styles\n   */\n  style?: React.CSSProperties\n  /**\n   * The standard React className property used to style a component with classes\n   */\n  className?: string\n  /**\n   * A boolean variable indicating whether the panel is open or closed\n   */\n  isOpen?: boolean\n  /**\n   * A function that toggles the open and close state of the panel\n   */\n  setIsOpen: (isOpen: boolean) => void\n  /**\n   * Handles the opening and closing the devtools panel\n   */\n  handleDragStart: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void\n  /**\n   * A boolean variable indicating if the \"lite\" version of the library is being used\n   */\n  router?: AnyRouter\n}\n\nconst isServer = typeof window === 'undefined'\n\nfunction Logo(props: React.HTMLProps<HTMLDivElement>) {\n  return (\n    <div\n      {...props}\n      style={{\n        ...(props.style ?? {}),\n        display: 'flex',\n        alignItems: 'center',\n        flexDirection: 'column',\n        fontSize: '0.8rem',\n        fontWeight: 'bolder',\n        lineHeight: '1',\n      }}\n    >\n      <div\n        style={{\n          letterSpacing: '-0.05rem',\n        }}\n      >\n        TANSTACK\n      </div>\n      <div\n        style={{\n          backgroundImage:\n            'linear-gradient(to right, var(--tw-gradient-stops))',\n          // @ts-ignore\n          '--tw-gradient-from': '#84cc16',\n          '--tw-gradient-stops':\n            'var(--tw-gradient-from), var(--tw-gradient-to)',\n          '--tw-gradient-to': '#10b981',\n          WebkitBackgroundClip: 'text',\n          color: 'transparent',\n          letterSpacing: '0.1rem',\n          marginRight: '-0.2rem',\n        }}\n      >\n        ROUTER\n      </div>\n    </div>\n  )\n}\n\nexport function TanStackRouterDevtools({\n  initialIsOpen,\n  panelProps = {},\n  closeButtonProps = {},\n  toggleButtonProps = {},\n  position = 'bottom-left',\n  containerElement: Container = 'footer',\n  router,\n}: DevtoolsOptions): React.ReactElement | null {\n  const rootRef = React.useRef<HTMLDivElement>(null)\n  const panelRef = React.useRef<HTMLDivElement>(null)\n  const [isOpen, setIsOpen] = useLocalStorage(\n    'tanstackRouterDevtoolsOpen',\n    initialIsOpen,\n  )\n  const [devtoolsHeight, setDevtoolsHeight] = useLocalStorage<number | null>(\n    'tanstackRouterDevtoolsHeight',\n    null,\n  )\n  const [isResolvedOpen, setIsResolvedOpen] = useSafeState(false)\n  const [isResizing, setIsResizing] = useSafeState(false)\n  const isMounted = useIsMounted()\n\n  const handleDragStart = (\n    panelElement: HTMLDivElement | null,\n    startEvent: React.MouseEvent<HTMLDivElement, MouseEvent>,\n  ) => {\n    if (startEvent.button !== 0) return // Only allow left click for drag\n\n    setIsResizing(true)\n\n    const dragInfo = {\n      originalHeight: panelElement?.getBoundingClientRect().height ?? 0,\n      pageY: startEvent.pageY,\n    }\n\n    const run = (moveEvent: MouseEvent) => {\n      const delta = dragInfo.pageY - moveEvent.pageY\n      const newHeight = dragInfo?.originalHeight + delta\n\n      setDevtoolsHeight(newHeight)\n\n      if (newHeight < 70) {\n        setIsOpen(false)\n      } else {\n        setIsOpen(true)\n      }\n    }\n\n    const unsub = () => {\n      setIsResizing(false)\n      document.removeEventListener('mousemove', run)\n      document.removeEventListener('mouseUp', unsub)\n    }\n\n    document.addEventListener('mousemove', run)\n    document.addEventListener('mouseup', unsub)\n  }\n\n  React.useEffect(() => {\n    setIsResolvedOpen(isOpen ?? false)\n  }, [isOpen, isResolvedOpen, setIsResolvedOpen])\n\n  // Toggle panel visibility before/after transition (depending on direction).\n  // Prevents focusing in a closed panel.\n  React.useEffect(() => {\n    const ref = panelRef.current\n\n    if (ref) {\n      const handlePanelTransitionStart = () => {\n        if (ref && isResolvedOpen) {\n          ref.style.visibility = 'visible'\n        }\n      }\n\n      const handlePanelTransitionEnd = () => {\n        if (ref && !isResolvedOpen) {\n          ref.style.visibility = 'hidden'\n        }\n      }\n\n      ref.addEventListener('transitionstart', handlePanelTransitionStart)\n      ref.addEventListener('transitionend', handlePanelTransitionEnd)\n\n      return () => {\n        ref.removeEventListener('transitionstart', handlePanelTransitionStart)\n        ref.removeEventListener('transitionend', handlePanelTransitionEnd)\n      }\n    }\n\n    return\n  }, [isResolvedOpen])\n\n  React[isServer ? 'useEffect' : 'useLayoutEffect'](() => {\n    if (isResolvedOpen) {\n      const previousValue = rootRef.current?.parentElement?.style.paddingBottom\n\n      const run = () => {\n        const containerHeight = panelRef.current?.getBoundingClientRect().height\n        if (rootRef.current?.parentElement) {\n          rootRef.current.parentElement.style.paddingBottom = `${containerHeight}px`\n        }\n      }\n\n      run()\n\n      if (typeof window !== 'undefined') {\n        window.addEventListener('resize', run)\n\n        return () => {\n          window.removeEventListener('resize', run)\n          if (\n            rootRef.current?.parentElement &&\n            typeof previousValue === 'string'\n          ) {\n            rootRef.current.parentElement.style.paddingBottom = previousValue\n          }\n        }\n      }\n    }\n    return\n  }, [isResolvedOpen])\n\n  const { style: panelStyle = {}, ...otherPanelProps } = panelProps\n\n  const {\n    style: closeButtonStyle = {},\n    onClick: onCloseClick,\n    ...otherCloseButtonProps\n  } = closeButtonProps\n\n  const {\n    style: toggleButtonStyle = {},\n    onClick: onToggleClick,\n    ...otherToggleButtonProps\n  } = toggleButtonProps\n\n  // Do not render on the server\n  if (!isMounted()) return null\n\n  return (\n    <Container ref={rootRef} className=\"TanStackRouterDevtools\">\n      <ThemeProvider theme={theme}>\n        <TanStackRouterDevtoolsPanel\n          ref={panelRef as any}\n          {...otherPanelProps}\n          router={router}\n          style={{\n            position: 'fixed',\n            bottom: '0',\n            right: '0',\n            zIndex: 99999,\n            width: '100%',\n            height: devtoolsHeight ?? 500,\n            maxHeight: '90%',\n            boxShadow: '0 0 20px rgba(0,0,0,.3)',\n            borderTop: `1px solid ${theme.gray}`,\n            transformOrigin: 'top',\n            // visibility will be toggled after transitions, but set initial state here\n            visibility: isOpen ? 'visible' : 'hidden',\n            ...panelStyle,\n            ...(isResizing\n              ? {\n                  transition: `none`,\n                }\n              : { transition: `all .2s ease` }),\n            ...(isResolvedOpen\n              ? {\n                  opacity: 1,\n                  pointerEvents: 'all',\n                  transform: `translateY(0) scale(1)`,\n                }\n              : {\n                  opacity: 0,\n                  pointerEvents: 'none',\n                  transform: `translateY(15px) scale(1.02)`,\n                }),\n          }}\n          isOpen={isResolvedOpen}\n          setIsOpen={setIsOpen}\n          handleDragStart={(e) => handleDragStart(panelRef.current, e)}\n        />\n        {isResolvedOpen ? (\n          <Button\n            type=\"button\"\n            aria-label=\"Close TanStack Router Devtools\"\n            {...(otherCloseButtonProps as any)}\n            onClick={(e) => {\n              setIsOpen(false)\n              onCloseClick && onCloseClick(e)\n            }}\n            style={{\n              position: 'fixed',\n              zIndex: 99999,\n              margin: '.5em',\n              bottom: 0,\n              ...(position === 'top-right'\n                ? {\n                    right: '0',\n                  }\n                : position === 'top-left'\n                ? {\n                    left: '0',\n                  }\n                : position === 'bottom-right'\n                ? {\n                    right: '0',\n                  }\n                : {\n                    left: '0',\n                  }),\n              ...closeButtonStyle,\n            }}\n          >\n            Close\n          </Button>\n        ) : null}\n      </ThemeProvider>\n      {!isResolvedOpen ? (\n        <button\n          type=\"button\"\n          {...otherToggleButtonProps}\n          aria-label=\"Open TanStack Router Devtools\"\n          onClick={(e) => {\n            setIsOpen(true)\n            onToggleClick && onToggleClick(e)\n          }}\n          style={{\n            appearance: 'none',\n            background: 'none',\n            border: 0,\n            padding: 0,\n            position: 'fixed',\n            zIndex: 99999,\n            display: 'inline-flex',\n            fontSize: '1.5em',\n            margin: '.5em',\n            cursor: 'pointer',\n            width: 'fit-content',\n            ...(position === 'top-right'\n              ? {\n                  top: '0',\n                  right: '0',\n                }\n              : position === 'top-left'\n              ? {\n                  top: '0',\n                  left: '0',\n                }\n              : position === 'bottom-right'\n              ? {\n                  bottom: '0',\n                  right: '0',\n                }\n              : {\n                  bottom: '0',\n                  left: '0',\n                }),\n            ...toggleButtonStyle,\n          }}\n        >\n          <Logo aria-hidden />\n        </button>\n      ) : null}\n    </Container>\n  )\n}\n\nfunction RouteComp({\n  route,\n  isRoot,\n  matches,\n  activeRouteId,\n  setActiveRouteId,\n}: {\n  route: AnyRootRoute | AnyRoute\n  isRoot?: boolean\n  matches: RouteMatch[]\n  activeRouteId: string | undefined\n  setActiveRouteId: (id: string) => void\n}) {\n  const isActive = matches.find((d) => d.route === route)\n  return (\n    <div>\n      <div\n        role=\"button\"\n        aria-label={`Open match details for ${route.id}`}\n        onClick={() => {\n          if (isActive)\n            setActiveRouteId(activeRouteId === route.id ? '' : route.id)\n        }}\n        style={{\n          display: 'flex',\n          borderBottom: `solid 1px ${theme.grayAlt}`,\n          cursor: isActive ? 'pointer' : 'default',\n          alignItems: 'center',\n          background:\n            route.id === activeRouteId ? 'rgba(255,255,255,.1)' : undefined,\n        }}\n      >\n        {isRoot ? null : (\n          <div\n            style={{\n              flex: '0 0 auto',\n              width: '.7rem',\n              height: '.7rem',\n              margin: '.5rem .75rem',\n              alignItems: 'center',\n              justifyContent: 'center',\n              fontWeight: 'bold',\n              borderRadius: '100%',\n              transition: 'all .2s ease-out',\n              background: getRouteStatusColor(matches, route, theme),\n              opacity: isActive ? 1 : 0.3,\n            }}\n          />\n        )}\n        <Code\n          style={{\n            padding: '.25rem 0',\n            paddingLeft: isRoot ? '.5rem' : 0,\n            opacity: isActive ? 1 : 0.7,\n          }}\n        >{`${route.path || trimPath(route.id)}`}</Code>\n      </div>\n      {(route.children as Route[])?.length ? (\n        <div\n          style={{\n            marginLeft: isRoot ? 0 : '1rem',\n            borderLeft: isRoot ? '' : `solid 1px ${theme.grayAlt}`,\n          }}\n        >\n          {[...(route.children as Route[])]\n            .sort((a, b) => {\n              return a.rank - b.rank\n            })\n            .map((r) => (\n              <RouteComp\n                key={r.id}\n                route={r}\n                matches={matches}\n                activeRouteId={activeRouteId}\n                setActiveRouteId={setActiveRouteId}\n              />\n            ))}\n        </div>\n      ) : null}\n    </div>\n  )\n}\n\nexport const TanStackRouterDevtoolsPanel = React.forwardRef<\n  HTMLDivElement,\n  DevtoolsPanelOptions\n>(function TanStackRouterDevtoolsPanel(props, ref): React.ReactElement {\n  const {\n    isOpen = true,\n    setIsOpen,\n    handleDragStart,\n    router: userRouter,\n    ...panelProps\n  } = props\n\n  const routerContextValue = React.useContext(routerContext)\n  const router = userRouter ?? routerContextValue?.router\n\n  invariant(\n    router,\n    'No router was found for the TanStack Router Devtools. Please place the devtools in the <RouterProvider> component tree or pass the router instance to the devtools manually.',\n  )\n\n  useStore(router.__store)\n\n  const [showMatches, setShowMatches] = useLocalStorage(\n    'tanstackRouterDevtoolsShowMatches',\n    true,\n  )\n\n  const [activeRouteId, setActiveRouteId] = useLocalStorage(\n    'tanstackRouterDevtoolsActiveRouteId',\n    '',\n  )\n\n  const allMatches: RouteMatch[] = React.useMemo(\n    () => [...Object.values(router.state.matches)],\n    [router.state.matches],\n  )\n\n  const activeMatch = allMatches?.find((d) => d.route.id === activeRouteId)\n\n  const hasSearch = Object.keys(\n    last(router.state.matches)?.state.search || {},\n  ).length\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Panel ref={ref} className=\"TanStackRouterDevtoolsPanel\" {...panelProps}>\n        <style\n          dangerouslySetInnerHTML={{\n            __html: `\n\n            .TanStackRouterDevtoolsPanel * {\n              scrollbar-color: ${theme.backgroundAlt} ${theme.gray};\n            }\n\n            .TanStackRouterDevtoolsPanel *::-webkit-scrollbar, .TanStackRouterDevtoolsPanel scrollbar {\n              width: 1em;\n              height: 1em;\n            }\n\n            .TanStackRouterDevtoolsPanel *::-webkit-scrollbar-track, .TanStackRouterDevtoolsPanel scrollbar-track {\n              background: ${theme.backgroundAlt};\n            }\n\n            .TanStackRouterDevtoolsPanel *::-webkit-scrollbar-thumb, .TanStackRouterDevtoolsPanel scrollbar-thumb {\n              background: ${theme.gray};\n              border-radius: .5em;\n              border: 3px solid ${theme.backgroundAlt};\n            }\n\n            .TanStackRouterDevtoolsPanel table {\n              width: 100%;\n            }\n\n            .TanStackRouterDevtoolsPanel table tr {\n              border-bottom: 2px dotted rgba(255, 255, 255, .2);\n            }\n\n            .TanStackRouterDevtoolsPanel table tr:last-child {\n              border-bottom: none\n            }\n\n            .TanStackRouterDevtoolsPanel table td {\n              padding: .25rem .5rem;\n              border-right: 2px dotted rgba(255, 255, 255, .05);\n            }\n\n            .TanStackRouterDevtoolsPanel table td:last-child {\n              border-right: none\n            }\n\n          `,\n          }}\n        />\n        <div\n          style={{\n            position: 'absolute',\n            left: 0,\n            top: 0,\n            width: '100%',\n            height: '4px',\n            marginBottom: '-4px',\n            cursor: 'row-resize',\n            zIndex: 100000,\n          }}\n          onMouseDown={handleDragStart}\n        ></div>\n        <div\n          style={{\n            flex: '1 1 500px',\n            minHeight: '40%',\n            maxHeight: '100%',\n            overflow: 'auto',\n            borderRight: `1px solid ${theme.grayAlt}`,\n            display: 'flex',\n            flexDirection: 'column',\n          }}\n        >\n          <div\n            style={{\n              display: 'flex',\n              justifyContent: 'start',\n              gap: '1rem',\n              padding: '1rem',\n              alignItems: 'center',\n              background: theme.backgroundAlt,\n            }}\n          >\n            <Logo aria-hidden />\n            <div\n              style={{\n                fontSize: 'clamp(.8rem, 2vw, 1.3rem)',\n                fontWeight: 'bold',\n              }}\n            >\n              <span\n                style={{\n                  fontWeight: 100,\n                }}\n              >\n                Devtools\n              </span>\n            </div>\n          </div>\n          <div\n            style={{\n              overflowY: 'auto',\n              flex: '1',\n            }}\n          >\n            <div\n              style={{\n                padding: '.5em',\n              }}\n            >\n              <Explorer label=\"Router\" value={router} defaultExpanded={{}} />\n            </div>\n          </div>\n        </div>\n        <div\n          style={{\n            flex: '1 1 500px',\n            minHeight: '40%',\n            maxHeight: '100%',\n            overflow: 'auto',\n            borderRight: `1px solid ${theme.grayAlt}`,\n            display: 'flex',\n            flexDirection: 'column',\n          }}\n        >\n          <div\n            style={{\n              padding: '.5em',\n              background: theme.backgroundAlt,\n              position: 'sticky',\n              top: 0,\n              zIndex: 1,\n              display: 'flex',\n              alignItems: 'center',\n              gap: '.5rem',\n            }}\n          >\n            <button\n              type=\"button\"\n              onClick={() => {\n                setShowMatches(false)\n              }}\n              disabled={!showMatches}\n              style={{\n                opacity: showMatches ? 0.5 : 1,\n              }}\n            >\n              Routes\n            </button>\n            /\n            <button\n              type=\"button\"\n              onClick={() => {\n                setShowMatches(true)\n              }}\n              disabled={showMatches}\n              style={{\n                opacity: !showMatches ? 0.5 : 1,\n              }}\n            >\n              Matches\n            </button>\n          </div>\n          {!showMatches ? (\n            <RouteComp\n              route={router.routeTree}\n              isRoot\n              matches={allMatches}\n              activeRouteId={activeRouteId}\n              setActiveRouteId={setActiveRouteId}\n            />\n          ) : (\n            <div>\n              {router.state.matches.map((match, i) => {\n                return (\n                  <div\n                    key={match.route.id || i}\n                    role=\"button\"\n                    aria-label={`Open match details for ${match.route.id}`}\n                    onClick={() =>\n                      setActiveRouteId(\n                        activeRouteId === match.route.id ? '' : match.route.id,\n                      )\n                    }\n                    style={{\n                      display: 'flex',\n                      borderBottom: `solid 1px ${theme.grayAlt}`,\n                      cursor: 'pointer',\n                      alignItems: 'center',\n                      background:\n                        match === activeMatch\n                          ? 'rgba(255,255,255,.1)'\n                          : undefined,\n                    }}\n                  >\n                    <div\n                      style={{\n                        flex: '0 0 auto',\n                        width: '1.3rem',\n                        height: '1.3rem',\n                        marginLeft: '.25rem',\n                        background: getStatusColor(match, theme),\n                        alignItems: 'center',\n                        justifyContent: 'center',\n                        fontWeight: 'bold',\n                        borderRadius: '.25rem',\n                        transition: 'all .2s ease-out',\n                      }}\n                    />\n\n                    <Code\n                      style={{\n                        padding: '.5em',\n                      }}\n                    >\n                      {`${match.id}`}\n                    </Code>\n                  </div>\n                )\n              })}\n            </div>\n          )}\n        </div>\n        {activeMatch ? (\n          <ActivePanel>\n            <div\n              style={{\n                padding: '.5em',\n                background: theme.backgroundAlt,\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n              }}\n            >\n              Match Details\n            </div>\n            <div>\n              <table>\n                <tbody>\n                  <tr>\n                    <td style={{ opacity: '.5' }}>ID</td>\n                    <td>\n                      <Code\n                        style={{\n                          lineHeight: '1.8em',\n                        }}\n                      >\n                        {JSON.stringify(activeMatch.id, null, 2)}\n                      </Code>\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style={{ opacity: '.5' }}>Status</td>\n                    <td>{activeMatch.state.status}</td>\n                  </tr>\n                  {/* <tr>\n                    <td style={{ opacity: '.5' }}>Invalid</td>\n                    <td>{activeMatch.getIsInvalid().toString()}</td>\n                  </tr> */}\n                  <tr>\n                    <td style={{ opacity: '.5' }}>Last Updated</td>\n                    <td>\n                      {activeMatch.state.updatedAt\n                        ? new Date(\n                            activeMatch.state.updatedAt as number,\n                          ).toLocaleTimeString()\n                        : 'N/A'}\n                    </td>\n                  </tr>\n                </tbody>\n              </table>\n            </div>\n            {/* <div\n              style={{\n                background: theme.backgroundAlt,\n                padding: '.5em',\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n              }}\n            >\n              Actions\n            </div>\n            <div\n              style={{\n                padding: '0.5em',\n              }}\n            >\n              <Button\n                type=\"button\"\n                onClick={() => activeMatch.__store.setState(d => ({...d, status: 'pending'}))}\n                style={{\n                  background: theme.gray,\n                }}\n              >\n                Reload\n              </Button>\n            </div> */}\n            <div\n              style={{\n                background: theme.backgroundAlt,\n                padding: '.5em',\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n              }}\n            >\n              Explorer\n            </div>\n            <div\n              style={{\n                padding: '.5em',\n              }}\n            >\n              <Explorer\n                label=\"Match\"\n                value={activeMatch}\n                defaultExpanded={{}}\n              />\n            </div>\n          </ActivePanel>\n        ) : null}\n        {hasSearch ? (\n          <div\n            style={{\n              flex: '1 1 500px',\n              minHeight: '40%',\n              maxHeight: '100%',\n              overflow: 'auto',\n              borderRight: `1px solid ${theme.grayAlt}`,\n              display: 'flex',\n              flexDirection: 'column',\n            }}\n          >\n            <div\n              style={{\n                padding: '.5em',\n                background: theme.backgroundAlt,\n                position: 'sticky',\n                top: 0,\n                bottom: 0,\n                zIndex: 1,\n              }}\n            >\n              Search Params\n            </div>\n            <div\n              style={{\n                padding: '.5em',\n              }}\n            >\n              <Explorer\n                value={last(router.state.matches)?.state.search || {}}\n                defaultExpanded={Object.keys(\n                  (last(router.state.matches)?.state.search as {}) || {},\n                ).reduce((obj: any, next) => {\n                  obj[next] = {}\n                  return obj\n                }, {})}\n              />\n            </div>\n          </div>\n        ) : null}\n      </Panel>\n    </ThemeProvider>\n  )\n})\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n"],"names":["shallow","objA","objB","Object","is","keysA","keys","length","i","prototype","hasOwnProperty","call","last","arr","routerContext","React","createContext","useLocalStorage","key","defaultValue","value","setValue","useState","useEffect","initialValue","itemValue","localStorage","getItem","JSON","parse","useCallback","updater","old","newVal","setItem","stringify","defaultTheme","background","backgroundAlt","foreground","gray","grayAlt","inputBackgroundColor","inputTextColor","success","danger","active","warning","ThemeContext","ThemeProvider","theme","rest","createElement","Provider","_extends","isServer","window","getStatusColor","match","state","status","getRouteStatusColor","matches","route","found","find","d","styled","type","newStyles","queries","forwardRef","style","ref","useContext","mediaStyles","entries","reduce","current","query","isMatch","setIsMatch","matchMedia","matcher","onChange","addListener","removeListener","useMediaQuery","useIsMounted","mountedRef","useRef","isMounted","useSafeState","initialState","setState","callback","Promise","resolve","then","catch","error","setTimeout","Panel","_props","fontSize","fontFamily","display","backgroundColor","color","flexDirection","ActivePanel","flex","overflow","height","borderTop","Button","props","appearance","fontWeight","border","borderRadius","padding","opacity","disabled","undefined","cursor","Code","Entry","lineHeight","outline","wordBreak","Label","LabelButton","ExpandButton","font","Value","SubEntries","marginLeft","paddingLeft","borderLeft","Info","Expander","expanded","transition","transform","DefaultRenderer","handleEntry","label","subEntries","subEntryPages","toggleExpanded","pageSize","renderer","expandedPages","setExpandedPages","valueSnapshot","setValueSnapshot","Fragment","onClick","String","toLowerCase","map","entry","index","includes","filter","Explorer","defaultExpanded","name","getOwnPropertyNames","newValue","toString","displayValue","setExpanded","Boolean","makeProperty","sub","subDefaultExpanded","x","Array","isArray","Symbol","iterator","from","val","array","size","result","push","slice","chunkArray","Logo","alignItems","letterSpacing","backgroundImage","WebkitBackgroundClip","marginRight","RouteComp","isRoot","activeRouteId","setActiveRouteId","isActive","role","id","borderBottom","width","margin","justifyContent","path","replace","trimPathRight","trimPathLeft","children","sort","a","b","rank","r","TanStackRouterDevtoolsPanel","isOpen","setIsOpen","handleDragStart","router","userRouter","panelProps","routerContextValue","condition","message","Error","invariant","store","selector","useSyncExternalStoreWithSelector","subscribe","useStore","__store","showMatches","setShowMatches","allMatches","useMemo","values","activeMatch","hasSearch","search","className","dangerouslySetInnerHTML","__html","position","left","top","marginBottom","zIndex","onMouseDown","minHeight","maxHeight","borderRight","gap","overflowY","routeTree","bottom","updatedAt","Date","toLocaleTimeString","obj","next","initialIsOpen","closeButtonProps","toggleButtonProps","containerElement","Container","rootRef","panelRef","devtoolsHeight","setDevtoolsHeight","isResolvedOpen","setIsResolvedOpen","isResizing","setIsResizing","handlePanelTransitionStart","visibility","handlePanelTransitionEnd","addEventListener","removeEventListener","previousValue","parentElement","paddingBottom","run","containerHeight","getBoundingClientRect","panelStyle","otherPanelProps","closeButtonStyle","onCloseClick","otherCloseButtonProps","toggleButtonStyle","onToggleClick","otherToggleButtonProps","right","boxShadow","transformOrigin","pointerEvents","e","panelElement","startEvent","button","dragInfo","pageY","moveEvent","delta","newHeight","unsub","document"],"mappings":"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"}