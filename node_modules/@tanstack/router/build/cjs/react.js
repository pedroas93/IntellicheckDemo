/**
 * @tanstack/router/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var React = require('react');
var reactStore = require('@tanstack/react-store');
var invariant = require('tiny-invariant');
var warning = require('tiny-warning');
var utils = require('./utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);
var warning__default = /*#__PURE__*/_interopDefaultLegacy(warning);

//

function lazy(importer, exportName = 'default') {
  const lazyComp = /*#__PURE__*/React__namespace.lazy(async () => {
    const moduleExports = await importer();
    const component = moduleExports[exportName];
    return {
      default: component
    };
  });
  const finalComp = lazyComp;
  finalComp.preload = async () => {
    {
      await importer();
    }
  };
  return finalComp;
}
//

function useLinkProps(options) {
  const router = useRouterContext();
  const {
    // custom props
    type,
    children,
    target,
    activeProps = () => ({
      className: 'active'
    }),
    inactiveProps = () => ({}),
    activeOptions,
    disabled,
    // fromCurrent,
    hash,
    search,
    params,
    to = '.',
    preload,
    preloadDelay,
    replace,
    // element props
    style,
    className,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchStart,
    ...rest
  } = options;
  const linkInfo = router.buildLink(options);
  if (linkInfo.type === 'external') {
    const {
      href
    } = linkInfo;
    return {
      href
    };
  }
  const {
    handleClick,
    handleFocus,
    handleEnter,
    handleLeave,
    handleTouchStart,
    isActive,
    next
  } = linkInfo;
  const reactHandleClick = e => {
    if (React__namespace.startTransition) {
      // This is a hack for react < 18
      React__namespace.startTransition(() => {
        handleClick(e);
      });
    } else {
      handleClick(e);
    }
  };
  const composeHandlers = handlers => e => {
    if (e.persist) e.persist();
    handlers.filter(Boolean).forEach(handler => {
      if (e.defaultPrevented) return;
      handler(e);
    });
  };

  // Get the active props
  const resolvedActiveProps = isActive ? utils.functionalUpdate(activeProps, {}) ?? {} : {};

  // Get the inactive props
  const resolvedInactiveProps = isActive ? {} : utils.functionalUpdate(inactiveProps, {}) ?? {};
  return {
    ...resolvedActiveProps,
    ...resolvedInactiveProps,
    ...rest,
    href: disabled ? undefined : next.href,
    onClick: composeHandlers([onClick, reactHandleClick]),
    onFocus: composeHandlers([onFocus, handleFocus]),
    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
    target,
    style: {
      ...style,
      ...resolvedActiveProps.style,
      ...resolvedInactiveProps.style
    },
    className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,
    ...(disabled ? {
      role: 'link',
      'aria-disabled': true
    } : undefined),
    ['data-status']: isActive ? 'active' : undefined
  };
}
const Link = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
  const linkProps = useLinkProps(props);
  return /*#__PURE__*/React__namespace.createElement("a", _rollupPluginBabelHelpers["extends"]({
    ref: ref
  }, linkProps, {
    children: typeof props.children === 'function' ? props.children({
      isActive: linkProps['data-status'] === 'active'
    }) : props.children
  }));
});
function Navigate(props) {
  const router = useRouterContext();
  React__namespace.useLayoutEffect(() => {
    router.navigate(props);
  }, []);
  return null;
}
const matchesContext = /*#__PURE__*/React__namespace.createContext(null);
const routerContext = /*#__PURE__*/React__namespace.createContext(null);
// const useDeferredValue = React.useDeferredValue || ((d) => d)
const useDeferredValue = d => d;
function RouterProvider({
  router,
  ...rest
}) {
  router.update(rest);
  const matches = useDeferredValue(reactStore.useStore(router.__store, s => {
    return s.matches;
  }));
  React__namespace.useEffect(router.mount, [router]);
  return /*#__PURE__*/React__namespace.createElement(routerContext.Provider, {
    value: {
      router: router
    }
  }, /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
    value: [undefined, ...matches]
  }, /*#__PURE__*/React__namespace.createElement(CatchBoundary, {
    errorComponent: ErrorComponent,
    onCatch: () => {
      warning__default["default"](false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! üëç`);
    }
  }, /*#__PURE__*/React__namespace.createElement(Outlet, null))));
}
function useRouterContext() {
  const value = React__namespace.useContext(routerContext);
  warning__default["default"](value, 'useRouter must be used inside a <Router> component!');
  reactStore.useStore(value.router.__store);
  return value.router;
}
function useRouter(track) {
  const router = useRouterContext();
  reactStore.useStore(router.__store, track);
  return router;
}
function useMatches() {
  return React__namespace.useContext(matchesContext);
}
function useMatch(opts) {
  const router = useRouterContext();
  const nearestMatch = useMatches()[0];
  const matches = useDeferredValue(router.state.matches);
  const match = opts?.from ? matches.find(d => d.route.id === opts?.from) : nearestMatch;
  invariant__default["default"](match, `Could not find ${opts?.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
  if (opts?.strict ?? true) {
    invariant__default["default"](nearestMatch.route.id == match?.route.id, `useMatch("${match?.route.id}") is being called in a component that is meant to render the '${nearestMatch.route.id}' route. Did you mean to 'useMatch("${match?.route.id}", { strict: false })' or 'useRoute("${match?.route.id}")' instead?`);
  }
  reactStore.useStore(match.__store, d => opts?.track?.(match) ?? match);
  return match;
}
function useLoader(opts) {
  const {
    track,
    ...matchOpts
  } = opts;
  const match = useMatch(matchOpts);
  reactStore.useStore(match.__store, d => opts?.track?.(d.loader) ?? d.loader);
  return match.state.loader;
}
function useSearch(opts) {
  const {
    track,
    ...matchOpts
  } = opts ?? {};
  const match = useMatch(matchOpts);
  reactStore.useStore(match.__store, d => opts?.track?.(d.search) ?? d.search);
  return match.state.search;
}
function useParams(opts) {
  const router = useRouterContext();
  return reactStore.useStore(router.__store, d => {
    const params = utils.last(d.matches)?.params;
    return opts?.track?.(params) ?? params;
  });

  // return last(router.state.matches)?.params as any
}

function useNavigate(defaultOpts) {
  const router = useRouterContext();
  return React__namespace.useCallback(opts => {
    return router.navigate({
      ...defaultOpts,
      ...opts
    });
  }, []);
}
function useMatchRoute() {
  const router = useRouterContext();
  return React__namespace.useCallback(opts => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return router.matchRoute(rest, {
      pending,
      caseSensitive
    });
  }, []);
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (!params) {
    return null;
  }
  if (typeof props.children === 'function') {
    return props.children(params);
  }
  return params ? props.children : null;
}
function Outlet() {
  const matches = useMatches().slice(1);
  const match = matches[0];
  if (!match) {
    return null;
  }
  return /*#__PURE__*/React__namespace.createElement(SubOutlet, {
    matches: matches,
    match: match
  });
}
function SubOutlet({
  matches,
  match
}) {
  const router = useRouterContext();
  reactStore.useStore(match.__store, store => [store.status, store.error]);
  const defaultPending = React__namespace.useCallback(() => null, []);
  const PendingComponent = match.pendingComponent ?? router.options.defaultPendingComponent ?? defaultPending;
  const errorComponent = match.errorComponent ?? router.options.defaultErrorComponent;
  const ResolvedSuspenseBoundary = match.route.options.wrapInSuspense ?? !match.route.isRoot ? React__namespace.Suspense : SafeFragment;
  const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment;

  // if (typeof document === 'undefined') {
  //   if (match.state.loader) {
  //     Object.keys(match.state.loader).forEach((key) => {
  //       let value = match.state.loader[key]

  //       if (value instanceof Promise || value.then) {
  //         value = {
  //           __isPromise: true,
  //           key: key,
  //         }
  //       }

  //       dehydrated[key] = value
  //     })
  //   }
  // } else {
  // }

  return /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
    value: matches
  }, /*#__PURE__*/React__namespace.createElement(ResolvedSuspenseBoundary, {
    fallback: /*#__PURE__*/React__namespace.createElement(PendingComponent, null)
  }, /*#__PURE__*/React__namespace.createElement(ResolvedCatchBoundary, {
    key: match.route.id,
    errorComponent: errorComponent,
    onCatch: () => {
      warning__default["default"](false, `Error in route match: ${match.id}`);
    }
  }, /*#__PURE__*/React__namespace.createElement(Inner, {
    match: match
  }))));
}
function useInjectHtml() {
  const router = useRouterContext();
  return React__namespace.useCallback(html => {
    router.injectHtml(html);
  }, []);
}
function useDehydrate() {
  const router = useRouterContext();
  return React__namespace.useCallback(function dehydrate(key, data) {
    return router.dehydrateData(key, data);
  }, []);
}
function useHydrate() {
  const router = useRouterContext();
  return function hydrate(key) {
    return router.hydrateData(key);
  };
}
function Inner(props) {
  const router = useRouterContext();
  if (props.match.state.status === 'error') {
    throw props.match.state.error;
  }
  if (props.match.state.status === 'pending') {
    throw props.match.__loadPromise;
  }
  if (props.match.state.status === 'success') {
    let comp = props.match.component ?? router.options.defaultComponent;
    if (comp) {
      return /*#__PURE__*/React__namespace.createElement(comp, {
        useLoader: props.match.route.useLoader,
        useMatch: props.match.route.useMatch,
        useContext: props.match.route.useContext,
        useSearch: props.match.route.useSearch,
        useParams: props.match.route.useParams
      });
    }
    return /*#__PURE__*/React__namespace.createElement(Outlet, null);
  }
  invariant__default["default"](false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
}
function SafeFragment(props) {
  return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, props.children);
}

// This is the messiest thing ever... I'm either seriously tired (likely) or
// there has to be a better way to reset error boundaries when the
// router's location key changes.

class CatchBoundary extends React__namespace.Component {
  state = {
    error: false,
    info: undefined
  };
  componentDidCatch(error, info) {
    this.props.onCatch(error, info);
    console.error(error);
    this.setState({
      error,
      info
    });
  }
  render() {
    return /*#__PURE__*/React__namespace.createElement(CatchBoundaryInner, _rollupPluginBabelHelpers["extends"]({}, this.props, {
      errorState: this.state,
      reset: () => this.setState({})
    }));
  }
}
function CatchBoundaryInner(props) {
  const [activeErrorState, setActiveErrorState] = React__namespace.useState(props.errorState);
  const router = useRouterContext();
  const errorComponent = props.errorComponent ?? ErrorComponent;
  const prevKeyRef = React__namespace.useRef('');
  React__namespace.useEffect(() => {
    if (activeErrorState) {
      if (router.state.location.key !== prevKeyRef.current) ;
    }
    prevKeyRef.current = router.state.location.key;
  }, [activeErrorState, router.state.location.key]);
  React__namespace.useEffect(() => {
    if (props.errorState.error) ;
    // props.reset()
  }, [props.errorState.error]);
  if (props.errorState.error && activeErrorState.error) {
    return /*#__PURE__*/React__namespace.createElement(errorComponent, activeErrorState);
  }
  return props.children;
}
function ErrorComponent({
  error
}) {
  return /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      padding: '.5rem',
      maxWidth: '100%'
    }
  }, /*#__PURE__*/React__namespace.createElement("strong", {
    style: {
      fontSize: '1.2rem'
    }
  }, "Something went wrong!"), /*#__PURE__*/React__namespace.createElement("div", {
    style: {
      height: '.5rem'
    }
  }), /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("pre", {
    style: {
      fontSize: '.7em',
      border: '1px solid red',
      borderRadius: '.25rem',
      padding: '.5rem',
      color: 'red',
      overflow: 'auto'
    }
  }, error.message ? /*#__PURE__*/React__namespace.createElement("code", null, error.message) : null)));
}
function useBlocker(message, condition = true) {
  const router = useRouter();
  React__namespace.useEffect(() => {
    if (!condition) return;
    let unblock = router.history.block((retry, cancel) => {
      if (window.confirm(message)) {
        unblock();
        retry();
      }
    });
    return unblock;
  });
}
function Block({
  message,
  condition,
  children
}) {
  useBlocker(message, condition);
  return children ?? null;
}

Object.defineProperty(exports, 'useStore', {
  enumerable: true,
  get: function () { return reactStore.useStore; }
});
exports.Block = Block;
exports.ErrorComponent = ErrorComponent;
exports.Link = Link;
exports.MatchRoute = MatchRoute;
exports.Navigate = Navigate;
exports.Outlet = Outlet;
exports.RouterProvider = RouterProvider;
exports.lazy = lazy;
exports.matchesContext = matchesContext;
exports.routerContext = routerContext;
exports.useBlocker = useBlocker;
exports.useDehydrate = useDehydrate;
exports.useHydrate = useHydrate;
exports.useInjectHtml = useInjectHtml;
exports.useLinkProps = useLinkProps;
exports.useLoader = useLoader;
exports.useMatch = useMatch;
exports.useMatchRoute = useMatchRoute;
exports.useMatches = useMatches;
exports.useNavigate = useNavigate;
exports.useParams = useParams;
exports.useRouter = useRouter;
exports.useRouterContext = useRouterContext;
exports.useSearch = useSearch;
//# sourceMappingURL=react.js.map
