/**
 * @tanstack/router/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var invariant = require('tiny-invariant');
var path = require('./path.js');
var react = require('./react.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

const rootRouteId = '__root__';
class Route {
  // Set up in this.init()

  // customId!: TCustomId

  // Optional

  constructor(options) {
    this.options = options || {};
    this.isRoot = !options?.getParentRoute;
  }
  init = opts => {
    this.originalIndex = opts.originalIndex;
    this.router = opts.router;
    const allOptions = this.options;
    const isRoot = !allOptions?.path && !allOptions?.id;
    this.parentRoute = this.options?.getParentRoute?.();
    if (isRoot) {
      this.path = rootRouteId;
    } else {
      invariant__default["default"](this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
    }
    let path$1 = isRoot ? rootRouteId : allOptions.path;

    // If the path is anything other than an index path, trim it up
    if (path$1 && path$1 !== '/') {
      path$1 = path.trimPath(path$1);
    }
    const customId = allOptions?.id || path$1;

    // Strip the parentId prefix from the first level of children
    let id = isRoot ? rootRouteId : path.joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);
    if (path$1 === rootRouteId) {
      path$1 = '/';
    }
    if (id !== rootRouteId) {
      id = path.joinPaths(['/', id]);
    }
    const fullPath = id === rootRouteId ? '/' : path.joinPaths([this.parentRoute.fullPath, path$1]);
    this.path = path$1;
    this.id = id;
    // this.customId = customId as TCustomId
    this.fullPath = fullPath;
    this.to = fullPath;
  };
  addChildren = children => {
    this.children = children;
    return this;
  };
  useMatch = opts => {
    return react.useMatch({
      ...opts,
      from: this.id
    });
  };
  useLoader = opts => {
    return react.useLoader({
      ...opts,
      from: this.id
    });
  };
  useContext = opts => {
    return react.useMatch({
      ...opts,
      from: this.id
    }).context;
  };
  useSearch = opts => {
    return react.useSearch({
      ...opts,
      from: this.id
    });
  };
  useParams = opts => {
    return react.useParams({
      ...opts,
      from: this.id
    });
  };
}
class RootRoute extends Route {
  constructor(options) {
    super(options);
  }
  static withRouterContext = () => {
    return options => new RootRoute(options);
  };
}

// const rootRoute = new RootRoute({
//   validateSearch: () => null as unknown as { root?: boolean },
// })

// const aRoute = new Route({
//   getParentRoute: () => rootRoute,
//   path: 'a',
//   validateSearch: () => null as unknown as { a?: string },
// })

// const bRoute = new Route({
//   getParentRoute: () => aRoute,
//   path: 'b',
// })

// const rootIsRoot = rootRoute.isRoot
// //    ^?
// const aIsRoot = aRoute.isRoot
// //    ^?

// const rId = rootRoute.id
// //    ^?
// const aId = aRoute.id
// //    ^?
// const bId = bRoute.id
// //    ^?

// const rPath = rootRoute.fullPath
// //    ^?
// const aPath = aRoute.fullPath
// //    ^?
// const bPath = bRoute.fullPath
// //    ^?

// const rSearch = rootRoute.__types.fullSearchSchema
// //    ^?
// const aSearch = aRoute.__types.fullSearchSchema
// //    ^?
// const bSearch = bRoute.__types.fullSearchSchema
// //    ^?

// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])
// //    ^?

exports.RootRoute = RootRoute;
exports.Route = Route;
exports.rootRouteId = rootRouteId;
//# sourceMappingURL=route.js.map
