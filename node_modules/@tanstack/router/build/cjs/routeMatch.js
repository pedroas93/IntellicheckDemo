/**
 * @tanstack/router/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactStore = require('@tanstack/react-store');
var router = require('./router.js');
var utils = require('./utils.js');

const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
class RouteMatch {
  abortController = new AbortController();
  constructor(router, route, opts) {
    Object.assign(this, {
      route,
      router,
      id: opts.id,
      pathname: opts.pathname,
      params: opts.params,
      __store: new reactStore.Store({
        updatedAt: 0,
        routeSearch: {},
        search: {},
        status: 'pending',
        loader: undefined
      }, {
        onUpdate: () => {
          this.state = this.__store.state;
        }
      })
    });
    this.state = this.__store.state;
    componentTypes.map(async type => {
      const component = this.route.options[type];
      this[type] = component;
    });
    this.__loadPromise = new Promise(r => {
      this.__loadPromiseResolve = r;
    });
    if (this.state.status === 'pending' && !this.#hasLoaders()) {
      this.__store.setState(s => ({
        ...s,
        status: 'success'
      }));
      this.__loadPromiseResolve?.();
    }
  }
  #hasLoaders = () => {
    return !!(this.route.options.loader || componentTypes.some(d => this.route.options[d]?.preload));
  };
  __commit = () => {
    const {
      routeSearch,
      search,
      context,
      routeContext
    } = this.#resolveInfo({
      location: this.router.state.location
    });
    this.context = context;
    this.routeContext = routeContext;
    this.__store.setState(s => ({
      ...s,
      routeSearch: utils.replaceEqualDeep(s.routeSearch, routeSearch),
      search: utils.replaceEqualDeep(s.search, search)
    }));
  };
  cancel = () => {
    this.abortController?.abort();
  };
  #resolveSearchInfo = opts => {
    // Validate the search params and stabilize them
    const parentSearchInfo = this.parentMatch ? this.parentMatch.#resolveSearchInfo(opts) : {
      search: opts.location.search,
      routeSearch: opts.location.search
    };
    try {
      const validator = typeof this.route.options.validateSearch === 'object' ? this.route.options.validateSearch.parse : this.route.options.validateSearch;
      const routeSearch = validator?.(parentSearchInfo.search) ?? {};
      const search = {
        ...parentSearchInfo.search,
        ...routeSearch
      };
      return {
        routeSearch,
        search
      };
    } catch (err) {
      if (router.isRedirect(err)) {
        throw err;
      }
      const errorHandler = this.route.options.onValidateSearchError ?? this.route.options.onError;
      errorHandler?.(err);
      const error = new Error('Invalid search params found', {
        cause: err
      });
      error.code = 'INVALID_SEARCH_PARAMS';
      throw error;
    }
  };
  #resolveInfo = opts => {
    const {
      search,
      routeSearch
    } = this.#resolveSearchInfo(opts);
    try {
      const routeContext = this.route.options.getContext?.({
        parentContext: this.parentMatch?.routeContext ?? {},
        context: this.parentMatch?.context ?? this.router?.options.context ?? {},
        params: this.params,
        search
      }) || {};
      const context = {
        ...(this.parentMatch?.context ?? this.router?.options.context),
        ...routeContext
      };
      return {
        routeSearch,
        search,
        context,
        routeContext
      };
    } catch (err) {
      this.route.options.onError?.(err);
      throw err;
    }
  };
  __load = async opts => {
    this.parentMatch = opts.parentMatch;
    let info;
    try {
      info = this.#resolveInfo(opts);
    } catch (err) {
      if (router.isRedirect(err)) {
        if (!opts?.preload) {
          this.router.navigate(err);
        }
        return;
      }
      this.__store.setState(s => ({
        ...s,
        status: 'error',
        error: err
      }));

      // Do not proceed with loading the route
      return;
    }
    const {
      routeSearch,
      search,
      context,
      routeContext
    } = info;
    const loaderOpts = {
      params: this.params,
      routeSearch,
      search,
      signal: this.abortController.signal,
      preload: !!opts?.preload,
      routeContext,
      context
    };
    this.__loadPromise = Promise.resolve().then(async () => {
      const loadId = '' + Date.now() + Math.random();
      this.#latestId = loadId;
      const checkLatest = () => {
        return loadId !== this.#latestId ? this.__loadPromise : undefined;
      };
      let latestPromise;
      const componentsPromise = (async () => {
        // then run all component and data loaders in parallel
        // For each component type, potentially load it asynchronously

        await Promise.all(componentTypes.map(async type => {
          const component = this.route.options[type];
          if (component?.preload) {
            await component.preload();
          }
        }));
      })();
      const loaderPromise = Promise.resolve().then(() => {
        if (this.route.options.loader) {
          return this.route.options.loader(loaderOpts);
        }
        return;
      });
      try {
        const [_, loader] = await Promise.all([componentsPromise, loaderPromise]);
        if (latestPromise = checkLatest()) return await latestPromise;

        // Object.keys(loader ?? {}).forEach((key) => {
        //   const value = loader[key]
        //   if (value instanceof Promise || value?.then) {
        //     // if (this.__promisesByKey[key]) {
        //     //   return
        //     // }

        //     if (typeof document === 'undefined') {
        //       this.__promisesByKey[key] = {
        //         status: 'pending',
        //         promise: value,
        //         data: undefined,
        //         resolve: () => {},
        //       }

        //       value.then((d: any) => {
        //         this.__promisesByKey[key]!.status = 'resolved'
        //         this.__promisesByKey[key]!.data = d
        //       })
        //     } else {
        //       const promise = createPromise()
        //       this.__promisesByKey[key] = {
        //         status: 'pending',
        //         promise,
        //         data: undefined,
        //         resolve: (d: any) => {
        //           // @ts-ignore
        //           promise.resolve()
        //           this.__promisesByKey[key]!.status = 'resolved'
        //           this.__promisesByKey[key]!.data = d
        //         },
        //       }

        //       if (!this.__promiseKeys.includes(key)) {
        //         value.then(this.__promisesByKey[key]!.resolve)
        //       }
        //     }

        //     loader[key] = this.__promisesByKey[key]
        //   }
        // })

        if (!opts.preload) {
          this.__store.setState(s => ({
            ...s,
            error: undefined,
            status: 'success',
            updatedAt: Date.now(),
            loader
          }));
        }
      } catch (err) {
        if (router.isRedirect(err)) {
          if (!opts?.preload) {
            this.router.navigate(err);
          }
          return;
        }
        const errorHandler = this.route.options.onLoadError ?? this.route.options.onError;
        try {
          errorHandler?.(err);
        } catch (errorHandlerErr) {
          if (router.isRedirect(errorHandlerErr)) {
            if (!opts?.preload) {
              this.router.navigate(errorHandlerErr);
            }
            return;
          }
          this.__store.setState(s => ({
            ...s,
            error: errorHandlerErr,
            status: 'error',
            updatedAt: Date.now()
          }));
          return;
        }
        this.__store.setState(s => ({
          ...s,
          error: err,
          status: 'error',
          updatedAt: Date.now()
        }));
      } finally {
        this.__loadPromiseResolve?.();
        delete this.__loadPromise;
      }
    });
    return this.__loadPromise;
  };
  #latestId = '';
}

exports.RouteMatch = RouteMatch;
//# sourceMappingURL=routeMatch.js.map
