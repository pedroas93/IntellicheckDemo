/**
 * @tanstack/router/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var reactStore = require('@tanstack/react-store');
var invariant = require('tiny-invariant');
var path = require('./path.js');
var routeMatch = require('./routeMatch.js');
var searchParams = require('./searchParams.js');
var utils = require('./utils.js');
var history = require('./history.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

const defaultFetchServerDataFn = async ({
  router,
  routeMatch
}) => {
  const next = router.buildNext({
    to: '.',
    search: d => ({
      ...(d ?? {}),
      __data: {
        matchId: routeMatch.id
      }
    })
  });
  const res = await fetch(next.href, {
    method: 'GET',
    signal: routeMatch.abortController.signal
  });
  if (res.ok) {
    return res.json();
  }
  throw new Error('Failed to fetch match data');
};
class Router {
  #unsubHistory;
  startedLoadingAt = Date.now();
  resolveNavigation = () => {};
  constructor(options) {
    this.options = {
      defaultPreloadDelay: 50,
      context: undefined,
      ...options,
      stringifySearch: options?.stringifySearch ?? searchParams.defaultStringifySearch,
      parseSearch: options?.parseSearch ?? searchParams.defaultParseSearch,
      fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn
    };
    this.__store = new reactStore.Store(getInitialRouterState(), {
      onUpdate: () => {
        this.state = this.__store.state;
      }
    });
    this.state = this.__store.state;
    this.update(options);
    const next = this.buildNext({
      hash: true,
      fromCurrent: true,
      search: true,
      state: true
    });
    if (this.state.location.href !== next.href) {
      this.#commitLocation({
        ...next,
        replace: true
      });
    }
  }
  reset = () => {
    this.__store.setState(s => Object.assign(s, getInitialRouterState()));
  };
  mount = () => {
    // Mount only does anything on the client
    if (!isServer) {
      // If the router matches are empty, start loading the matches
      if (!this.state.matches.length) {
        this.safeLoad();
      }
    }
    return () => {};
  };
  update = opts => {
    Object.assign(this.options, opts);
    this.context = this.options.context;
    if (!this.history || this.options.history && this.options.history !== this.history) {
      if (this.#unsubHistory) {
        this.#unsubHistory();
      }
      this.history = this.options.history ?? (isServer ? history.createMemoryHistory() : history.createBrowserHistory());
      const parsedLocation = this.#parseLocation();
      this.__store.setState(s => ({
        ...s,
        resolvedLocation: parsedLocation,
        location: parsedLocation
      }));
      this.#unsubHistory = this.history.listen(() => {
        this.safeLoad({
          next: this.#parseLocation(this.state.location)
        });
      });
    }
    const {
      basepath,
      routeTree
    } = this.options;
    this.basepath = `/${path.trimPath(basepath ?? '') ?? ''}`;
    if (routeTree && routeTree !== this.routeTree) {
      this.#buildRouteTree(routeTree);
    }
    return this;
  };
  buildNext = opts => {
    const next = this.#buildLocation(opts);
    const __matches = this.matchRoutes(next.pathname, next.search);
    return this.#buildLocation({
      ...opts,
      __matches
    });
  };
  cancelMatches = () => {
    [...this.state.matches].forEach(match => {
      match.cancel();
    });
  };
  safeLoad = opts => {
    this.load(opts).catch(err => {
      console.warn(err);
      invariant__default["default"](false, 'Encountered an error during router.load()! ☝️.');
    });
  };
  load = async opts => {
    this.#createNavigationPromise();
    let now = Date.now();
    const startedAt = now;
    this.startedLoadingAt = startedAt;

    // Cancel any pending matches
    this.cancelMatches();
    let matches;
    this.__store.batch(() => {
      if (opts?.next) {
        // Ingest the new location
        this.__store.setState(s => ({
          ...s,
          location: opts.next
        }));
      }

      // Match the routes
      matches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {
        strictParseParams: true,
        debug: true
      });
      this.__store.setState(s => ({
        ...s,
        status: 'pending',
        matches
      }));
    });
    matches.forEach(match => {
      match.__commit();
    });

    // Load the matches
    await this.loadMatches(matches, this.state.location);
    if (this.startedLoadingAt !== startedAt) {
      // Ignore side-effects of outdated side-effects
      return this.navigationPromise;
    }
    const previousMatches = this.state.matches;
    const exiting = [],
      staying = [];
    previousMatches.forEach(d => {
      if (matches.find(dd => dd.id === d.id)) {
        staying.push(d);
      } else {
        exiting.push(d);
      }
    });
    const entering = matches.filter(d => {
      return !previousMatches.find(dd => dd.id === d.id);
    });
    now = Date.now();
    exiting.forEach(d => {
      d.__onExit?.({
        params: d.params,
        search: d.state.routeSearch
      });

      // Clear non-loading error states when match leaves
      if (d.state.status === 'error') {
        this.__store.setState(s => ({
          ...s,
          status: 'idle',
          error: undefined
        }));
      }
    });
    staying.forEach(d => {
      d.route.options.onTransition?.({
        params: d.params,
        search: d.state.routeSearch
      });
    });
    entering.forEach(d => {
      d.__onExit = d.route.options.onLoaded?.({
        params: d.params,
        search: d.state.search
      });
    });
    const prevLocation = this.state.location;
    this.__store.setState(s => ({
      ...s,
      status: 'idle',
      resolvedLocation: s.location,
      matches
    }));
    if (prevLocation.href !== this.state.location.href) {
      this.options.onRouteChange?.();
    }
    this.resolveNavigation();
  };
  getRoute = id => {
    const route = this.routesById[id];
    invariant__default["default"](route, `Route with id "${id}" not found`);
    return route;
  };
  loadRoute = async (navigateOpts = this.state.location) => {
    const next = this.buildNext(navigateOpts);
    const matches = this.matchRoutes(next.pathname, next.search, {
      strictParseParams: true
    });
    await this.loadMatches(matches, next);
    return matches;
  };
  preloadRoute = async (navigateOpts = this.state.location) => {
    const next = this.buildNext(navigateOpts);
    const matches = this.matchRoutes(next.pathname, next.search, {
      strictParseParams: true
    });
    await this.loadMatches(matches, next, {
      preload: true
    });
    return matches;
  };
  matchRoutes = (pathname, search, opts) => {
    // If there's no route tree, we can't match anything
    if (!this.flatRoutes.length) {
      return [];
    }
    let routeParams = {};
    let foundRoute = this.flatRoutes.find(route => {
      const matchedParams = path.matchPathname(this.basepath, pathname, {
        to: route.fullPath,
        caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive
      });
      if (matchedParams) {
        routeParams = matchedParams;
        return true;
      }
      return false;
    });
    if (!foundRoute) {
      return [];
    }
    let matchedRoutes = [foundRoute];
    while (foundRoute?.parentRoute) {
      foundRoute = foundRoute.parentRoute;
      if (foundRoute) matchedRoutes.unshift(foundRoute);
    }

    // Alright, by now we should have all of our
    // matching routes and their param pairs, let's
    // Turn them into actual `Match` objects and
    // accumulate the params into a single params bag
    let allParams = {};

    // Existing matches are matches that are already loaded along with
    // pending matches that are still loading
    const existingMatches = [...this.state.matches];
    const matches = matchedRoutes.map(route => {
      let parsedParams;
      try {
        parsedParams = route.options.parseParams?.(routeParams) ?? routeParams;
      } catch (err) {
        if (opts?.strictParseParams) {
          throw err;
        }
      }

      // Add the parsed params to the accumulated params bag
      Object.assign(allParams, parsedParams);
      const interpolatedPath = path.interpolatePath(route.path, allParams);
      const matchId = path.interpolatePath(route.id, allParams, true) + (route.options.getKey?.({
        params: allParams,
        search
      }) ?? '');

      // Waste not, want not. If we already have a match for this route,
      // reuse it. This is important for layout routes, which might stick
      // around between navigation actions that only change leaf routes.
      const existingMatch = existingMatches.find(d => d.id === matchId);
      if (existingMatch) {
        return existingMatch;
      }
      return new routeMatch.RouteMatch(this, route, {
        id: matchId,
        params: allParams,
        pathname: path.joinPaths([this.basepath, interpolatedPath])
      });
    }).filter((d, i, all) => {
      // Filter out any duplicate matches
      // I honesty don't know why this is necessary, but it is and it's safe for now
      // Someday someone will figure out why my logic is wrong and fix it to just
      // not create duplicate matches in the first place
      return all.findIndex(dd => dd.id === d.id) === i;
    });
    return matches;
  };
  loadMatches = async (resolvedMatches, location, opts) => {
    let firstBadMatchIndex;

    // Check each match middleware to see if the route can be accessed
    try {
      await Promise.all(resolvedMatches.map(async (match, index) => {
        try {
          await match.route.options.beforeLoad?.({
            router: this,
            match
          });
        } catch (err) {
          if (isRedirect(err)) {
            throw err;
          }
          firstBadMatchIndex = firstBadMatchIndex ?? index;
          const errorHandler = match.route.options.onBeforeLoadError ?? match.route.options.onError;
          try {
            errorHandler?.(err);
          } catch (errorHandlerErr) {
            if (isRedirect(errorHandlerErr)) {
              throw errorHandlerErr;
            }
            match.__store.setState(s => ({
              ...s,
              error: errorHandlerErr,
              status: 'error',
              updatedAt: Date.now()
            }));
            return;
          }
          match.__store.setState(s => ({
            ...s,
            error: err,
            status: 'error',
            updatedAt: Date.now()
          }));
        }
      }));
    } catch (err) {
      if (isRedirect(err)) {
        if (!opts?.preload) {
          this.navigate(err);
        }
        return;
      }
      throw err; // we should never end up here
    }

    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex);
    const matchPromises = validResolvedMatches.map(async (match, index) => {
      const parentMatch = validResolvedMatches[index - 1];
      match.__load({
        preload: opts?.preload,
        location,
        parentMatch
      });
      await match.__loadPromise;
      if (parentMatch) {
        await parentMatch.__loadPromise;
      }
    });
    await Promise.all(matchPromises);
  };
  reload = () => {
    this.navigate({
      fromCurrent: true,
      replace: true,
      search: true
    });
  };
  resolvePath = (from, path$1) => {
    return path.resolvePath(this.basepath, from, path.cleanPath(path$1));
  };
  navigate = async ({
    from,
    to = '',
    search,
    hash,
    replace,
    params
  }) => {
    // If this link simply reloads the current route,
    // make sure it has a new key so it will trigger a data refresh

    // If this `to` is a valid external URL, return
    // null for LinkUtils
    const toString = String(to);
    const fromString = typeof from === 'undefined' ? from : String(from);
    let isExternal;
    try {
      new URL(`${toString}`);
      isExternal = true;
    } catch (e) {}
    invariant__default["default"](!isExternal, 'Attempting to navigate to external url with this.navigate!');
    return this.#commitLocation({
      from: fromString,
      to: toString,
      search,
      hash,
      replace,
      params
    });
  };
  matchRoute = (location, opts) => {
    location = {
      ...location,
      to: location.to ? this.resolvePath(location.from ?? '', location.to) : undefined
    };
    const next = this.buildNext(location);
    if (opts?.pending && this.state.status !== 'pending') {
      return false;
    }
    const baseLocation = opts?.pending ? this.state.location : this.state.resolvedLocation;
    if (!baseLocation) {
      return false;
    }
    const match = path.matchPathname(this.basepath, baseLocation.pathname, {
      ...opts,
      to: next.pathname
    });
    if (!match) {
      return false;
    }
    if (opts?.includeSearch ?? true) {
      return utils.partialDeepEqual(baseLocation.search, next.search) ? match : false;
    }
    return match;
  };
  buildLink = ({
    from,
    to = '.',
    search,
    params,
    hash,
    target,
    replace,
    activeOptions,
    preload,
    preloadDelay: userPreloadDelay,
    disabled
  }) => {
    // If this link simply reloads the current route,
    // make sure it has a new key so it will trigger a data refresh

    // If this `to` is a valid external URL, return
    // null for LinkUtils

    try {
      new URL(`${to}`);
      return {
        type: 'external',
        href: to
      };
    } catch (e) {}
    const nextOpts = {
      from,
      to,
      search,
      params,
      hash,
      replace
    };
    const next = this.buildNext(nextOpts);
    preload = preload ?? this.options.defaultPreload;
    const preloadDelay = userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0;

    // Compare path/hash for matches
    const currentPathSplit = this.state.location.pathname.split('/');
    const nextPathSplit = next.pathname.split('/');
    const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
    // Combine the matches based on user options
    const pathTest = activeOptions?.exact ? this.state.location.pathname === next.pathname : pathIsFuzzyEqual;
    const hashTest = activeOptions?.includeHash ? this.state.location.hash === next.hash : true;
    const searchTest = activeOptions?.includeSearch ?? true ? utils.partialDeepEqual(this.state.location.search, next.search) : true;

    // The final "active" test
    const isActive = pathTest && hashTest && searchTest;

    // The click handler
    const handleClick = e => {
      if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
        e.preventDefault();

        // All is well? Navigate!
        this.#commitLocation(nextOpts);
      }
    };

    // The click handler
    const handleFocus = e => {
      if (preload) {
        this.preloadRoute(nextOpts).catch(err => {
          console.warn(err);
          console.warn('Error preloading route! ☝️');
        });
      }
    };
    const handleTouchStart = e => {
      this.preloadRoute(nextOpts).catch(err => {
        console.warn(err);
        console.warn('Error preloading route! ☝️');
      });
    };
    const handleEnter = e => {
      const target = e.target || {};
      if (preload) {
        if (target.preloadTimeout) {
          return;
        }
        target.preloadTimeout = setTimeout(() => {
          target.preloadTimeout = null;
          this.preloadRoute(nextOpts).catch(err => {
            console.warn(err);
            console.warn('Error preloading route! ☝️');
          });
        }, preloadDelay);
      }
    };
    const handleLeave = e => {
      const target = e.target || {};
      if (target.preloadTimeout) {
        clearTimeout(target.preloadTimeout);
        target.preloadTimeout = null;
      }
    };
    return {
      type: 'internal',
      next,
      handleFocus,
      handleClick,
      handleEnter,
      handleLeave,
      handleTouchStart,
      isActive,
      disabled
    };
  };
  dehydrate = () => {
    return {
      state: {
        ...utils.pick(this.state, ['location', 'status', 'lastUpdated'])
        // matches: this.state.matches.map((m) => ({
        //   id: m.id,
        //   promiseKeys: Object.keys(m.__promisesByKey),
        // })),
      }
    };
  };

  hydrate = async __do_not_use_server_ctx => {
    let _ctx = __do_not_use_server_ctx;
    // Client hydrates from window
    if (typeof document !== 'undefined') {
      _ctx = window.__TSR_DEHYDRATED__;
    }
    invariant__default["default"](_ctx, 'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?');
    const ctx = _ctx;
    this.options.hydrate?.(ctx.payload);
    this.__store.setState(s => {
      return {
        ...s,
        ...ctx.router.state,
        matches: s.matches,
        resolvedLocation: ctx.router.state.location
      };
    });
    await this.load();

    // this.state.matches.forEach((m) => {
    //   m.__promiseKeys =
    //     ctx.router.state.matches.find((d) => d.id === m.id)?.promiseKeys ?? []
    // })

    return;
  };
  injectedHtml = [];
  injectHtml = async html => {
    this.injectedHtml.push(html);
  };
  dehydrateData = (key, getData) => {
    if (typeof document === 'undefined') {
      const strKey = typeof key === 'string' ? key : JSON.stringify(key);
      this.injectHtml(async () => {
        const data = typeof getData === 'function' ? await getData() : getData;
        return `<script>window["__TSR__DEHYRATED__${escapeJSON(strKey)}"] = ${JSON.stringify(data)}</script>`;
      });
      return () => this.hydrateData(key);
    }
    return () => undefined;
  };
  hydrateData = key => {
    if (typeof document !== 'undefined') {
      const strKey = typeof key === 'string' ? key : JSON.stringify(key);
      return window[`__TSR__DEHYRATED__${strKey}`];
    }
    return undefined;
  };

  // resolveMatchPromise = (matchId: string, key: string, value: any) => {
  //   this.state.matches
  //     .find((d) => d.id === matchId)
  //     ?.__promisesByKey[key]?.resolve(value)
  // }

  #buildRouteTree = routeTree => {
    this.routeTree = routeTree;
    this.routesById = {};
    this.routesByPath = {};
    this.flatRoutes = [];
    const recurseRoutes = routes => {
      routes.forEach((route, i) => {
        route.init({
          originalIndex: i,
          router: this
        });
        const existingRoute = this.routesById[route.id];
        invariant__default["default"](!existingRoute, `Duplicate routes found with id: ${String(route.id)}`);
        this.routesById[route.id] = route;
        if (!route.isRoot && route.path) {
          const trimmedFullPath = path.trimPathRight(route.fullPath);
          if (!this.routesByPath[trimmedFullPath] || route.fullPath.endsWith('/')) {
            this.routesByPath[trimmedFullPath] = route;
          }
        }
        const children = route.children;
        if (children?.length) {
          recurseRoutes(children);
        }
      });
    };
    recurseRoutes([routeTree]);
    this.flatRoutes = Object.values(this.routesByPath).map((d, i) => {
      const trimmed = path.trimPath(d.fullPath);
      const parsed = path.parsePathname(trimmed);
      while (parsed.length > 1 && parsed[0]?.value === '/') {
        parsed.shift();
      }
      const score = parsed.map(d => {
        if (d.type === 'param') {
          return 0.5;
        }
        if (d.type === 'wildcard') {
          return 0.25;
        }
        return 1;
      });
      return {
        child: d,
        trimmed,
        parsed,
        index: i,
        score
      };
    }).sort((a, b) => {
      let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0;
      if (isIndex !== 0) return isIndex;
      const length = Math.min(a.score.length, b.score.length);

      // Sort by length of score
      if (a.score.length !== b.score.length) {
        return b.score.length - a.score.length;
      }

      // Sort by min available score
      for (let i = 0; i < length; i++) {
        if (a.score[i] !== b.score[i]) {
          return b.score[i] - a.score[i];
        }
      }

      // Sort by min available parsed value
      for (let i = 0; i < length; i++) {
        if (a.parsed[i].value !== b.parsed[i].value) {
          return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
        }
      }

      // Sort by length of trimmed full path
      if (a.trimmed !== b.trimmed) {
        return a.trimmed > b.trimmed ? 1 : -1;
      }

      // Sort by original index
      return a.index - b.index;
    }).map((d, i) => {
      d.child.rank = i;
      return d.child;
    });
  };
  #parseLocation = previousLocation => {
    let {
      pathname,
      search,
      hash,
      state
    } = this.history.location;
    const parsedSearch = this.options.parseSearch(search);
    return {
      pathname: pathname,
      searchStr: search,
      search: utils.replaceEqualDeep(previousLocation?.search, parsedSearch),
      hash: hash.split('#').reverse()[0] ?? '',
      href: `${pathname}${search}${hash}`,
      state: state,
      key: state?.key || '__init__'
    };
  };
  #buildLocation = (dest = {}) => {
    dest.fromCurrent = dest.fromCurrent ?? dest.to === '';
    const fromPathname = dest.fromCurrent ? this.state.location.pathname : dest.from ?? this.state.location.pathname;
    let pathname = path.resolvePath(this.basepath ?? '/', fromPathname, `${dest.to ?? ''}`);
    const fromMatches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {
      strictParseParams: true
    });
    const prevParams = {
      ...utils.last(fromMatches)?.params
    };
    let nextParams = (dest.params ?? true) === true ? prevParams : utils.functionalUpdate(dest.params, prevParams);
    if (nextParams) {
      dest.__matches?.map(d => d.route.options.stringifyParams).filter(Boolean).forEach(fn => {
        nextParams = {
          ...nextParams,
          ...fn(nextParams)
        };
      });
    }
    pathname = path.interpolatePath(pathname, nextParams ?? {});
    const preSearchFilters = dest.__matches?.map(match => match.route.options.preSearchFilters ?? []).flat().filter(Boolean) ?? [];
    const postSearchFilters = dest.__matches?.map(match => match.route.options.postSearchFilters ?? []).flat().filter(Boolean) ?? [];

    // Pre filters first
    const preFilteredSearch = preSearchFilters?.length ? preSearchFilters?.reduce((prev, next) => next(prev), this.state.location.search) : this.state.location.search;

    // Then the link/navigate function
    const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true
    : dest.search ? utils.functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater
    : preSearchFilters?.length ? preFilteredSearch // Preserve resolvedFrom filters
    : {};

    // Then post filters
    const postFilteredSearch = postSearchFilters?.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
    const search = utils.replaceEqualDeep(this.state.location.search, postFilteredSearch);
    const searchStr = this.options.stringifySearch(search);
    const hash = dest.hash === true ? this.state.location.hash : utils.functionalUpdate(dest.hash, this.state.location.hash);
    const hashStr = hash ? `#${hash}` : '';
    const nextState = dest.state === true ? this.state.location.state : utils.functionalUpdate(dest.state, this.state.location.state);
    return {
      pathname,
      search,
      searchStr,
      state: nextState,
      hash,
      href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),
      key: dest.key
    };
  };
  #commitLocation = async location => {
    const next = this.buildNext(location);
    const id = '' + Date.now() + Math.random();
    if (this.navigateTimeout) clearTimeout(this.navigateTimeout);
    let nextAction = 'replace';
    if (!location.replace) {
      nextAction = 'push';
    }
    const isSameUrl = this.state.location.href === next.href;
    if (isSameUrl && !next.key) {
      nextAction = 'replace';
    }
    const href = `${next.pathname}${next.searchStr}${next.hash ? `#${next.hash}` : ''}`;
    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {
      id,
      ...next.state
    });
    return this.#createNavigationPromise();
  };
  #createNavigationPromise = () => {
    const previousNavigationResolve = this.resolveNavigation;
    this.navigationPromise = new Promise(resolve => {
      this.resolveNavigation = () => {
        resolve();
        previousNavigationResolve();
      };
    });
    return this.navigationPromise;
  };
}

// Detect if we're in the DOM
const isServer = typeof window === 'undefined' || !window.document.createElement;
function getInitialRouterState() {
  return {
    status: 'idle',
    resolvedLocation: null,
    location: null,
    matches: [],
    lastUpdated: Date.now()
  };
}
function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function redirect(opts) {
  opts.isRedirect = true;
  return opts;
}
function isRedirect(obj) {
  return !!obj?.isRedirect;
}
function escapeJSON(jsonString) {
  return jsonString.replace(/\\/g, '\\\\') // Escape backslashes
  .replace(/'/g, "\\'") // Escape single quotes
  .replace(/"/g, '\\"'); // Escape double quotes
}

exports.Router = Router;
exports.defaultFetchServerDataFn = defaultFetchServerDataFn;
exports.isRedirect = isRedirect;
exports.redirect = redirect;
//# sourceMappingURL=router.js.map
