import * as React from 'react';
import { NoInfer, useStore } from '@tanstack/react-store';
import { LinkOptions, ToOptions, ResolveRelativePath, NavigateOptions } from './link';
import { AnyRoute } from './route';
import { RouteByPath, AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo';
import { AnyRouteMatch, RouteMatch } from './routeMatch';
import { RegisteredRoutesInfo, MatchRouteOptions, RegisteredRouter, RouterOptions, RouterState, Router } from './router';
export { useStore };
type ReactNode = any;
export type SyncRouteComponent<TProps = {}> = (props: TProps) => ReactNode;
export type RouteComponent<TProps = {}> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
export declare function lazy<T extends Record<string, SyncRouteComponent>>(importer: () => Promise<T>, exportName?: keyof T): RouteComponent;
export type LinkPropsOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = LinkOptions<RegisteredRoutesInfo, TFrom, TTo> & {
    activeProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
    inactiveProps?: React.AnchorHTMLAttributes<HTMLAnchorElement> | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>);
};
export type MakeUseMatchRouteOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> & MatchRouteOptions;
export type MakeMatchRouteOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> & MatchRouteOptions & {
    children?: ReactNode | ((params: RouteByPath<RegisteredRoutesInfo, ResolveRelativePath<TFrom, NoInfer<TTo>>>['__types']['allParams']) => ReactNode);
};
export type MakeLinkPropsOptions<TFrom extends string = '/', TTo extends string = ''> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>;
export type MakeLinkOptions<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''> = LinkPropsOptions<TFrom, TTo> & Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {
    children?: React.ReactNode | ((state: {
        isActive: boolean;
    }) => React.ReactNode);
};
export type PromptProps = {
    message: string;
    condition?: boolean | any;
    children?: ReactNode;
};
export declare function useLinkProps<TFrom extends string = '/', TTo extends string = ''>(options: MakeLinkPropsOptions<TFrom, TTo>): React.AnchorHTMLAttributes<HTMLAnchorElement>;
export interface LinkFn<TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/', TDefaultTo extends string = ''> {
    <TFrom extends RegisteredRoutesInfo['routePaths'] = TDefaultFrom, TTo extends string = TDefaultTo>(props: MakeLinkOptions<TFrom, TTo> & React.RefAttributes<HTMLAnchorElement>): ReactNode;
}
export declare const Link: LinkFn;
export declare function Navigate<TFrom extends RegisteredRoutesInfo['routePaths'] = '/', TTo extends string = ''>(props: NavigateOptions<RegisteredRoutesInfo, TFrom, TTo>): null;
type MatchesContextValue = AnyRouteMatch[];
export declare const matchesContext: React.Context<MatchesContextValue>;
export declare const routerContext: React.Context<{
    router: RegisteredRouter;
}>;
export type MatchesProviderProps = {
    value: MatchesContextValue;
    children: ReactNode;
};
export type RouterProps<TRouteConfig extends AnyRoute = AnyRoute, TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TDehydrated extends Record<string, any> = Record<string, any>> = RouterOptions<TRouteConfig, TDehydrated> & {
    router: Router<TRouteConfig, TRoutesInfo>;
};
export declare function RouterProvider<TRouteConfig extends AnyRoute = AnyRoute, TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo, TDehydrated extends Record<string, any> = Record<string, any>>({ router, ...rest }: RouterProps<TRouteConfig, TRoutesInfo, TDehydrated>): JSX.Element;
export declare function useRouterContext(): RegisteredRouter;
export declare function useRouter<T = RouterState>(track?: (state: Router['__store']['state']) => T): RegisteredRouter;
export declare function useMatches(): RouteMatch[];
export declare function useMatch<TFrom extends keyof RegisteredRoutesInfo['routesById'], TStrict extends boolean = true, TRouteMatch = RouteMatch<RegisteredRoutesInfo, RegisteredRoutesInfo['routesById'][TFrom]>>(opts?: {
    from: TFrom;
    strict?: TStrict;
    track?: (match: TRouteMatch) => any;
}): TStrict extends true ? TRouteMatch : TRouteMatch | undefined;
export type RouteFromIdOrRoute<T> = T extends RegisteredRoutesInfo['routeUnion'] ? T : T extends keyof RegisteredRoutesInfo['routesById'] ? RegisteredRoutesInfo['routesById'][T] : T extends string ? keyof RegisteredRoutesInfo['routesById'] : never;
export declare function useLoader<TFrom extends keyof RegisteredRoutesInfo['routesById'], TStrict extends boolean = true, TLoader = RegisteredRoutesInfo['routesById'][TFrom]['__types']['loader'], TSelected = TLoader>(opts?: {
    from: TFrom;
    strict?: TStrict;
    track?: (search: TLoader) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
export declare function useSearch<TFrom extends keyof RegisteredRoutesInfo['routesById'], TStrict extends boolean = true, TSearch = RegisteredRoutesInfo['routesById'][TFrom]['__types']['fullSearchSchema'], TSelected = TSearch>(opts?: {
    from: TFrom;
    strict?: TStrict;
    track?: (search: TSearch) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
export declare function useParams<TFrom extends keyof RegisteredRoutesInfo['routesById'] = '/', TDefaultSelected = RegisteredRoutesInfo['allParams'] & RegisteredRoutesInfo['routesById'][TFrom]['__types']['allParams'], TSelected = TDefaultSelected>(opts?: {
    from: TFrom;
    track?: (search: TDefaultSelected) => TSelected;
}): TSelected;
export declare function useNavigate<TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/'>(defaultOpts?: {
    from?: TDefaultFrom;
}): <TFrom extends unknown = TDefaultFrom, TTo extends string = "">(opts?: NavigateOptions<AnyRoutesInfo, TFrom, TTo> | undefined) => Promise<void>;
export declare function useMatchRoute(): <TFrom extends string = "/", TTo extends string = "">(opts: MakeUseMatchRouteOptions<TFrom, TTo>) => any;
export declare function MatchRoute<TFrom extends string = '/', TTo extends string = ''>(props: MakeMatchRouteOptions<TFrom, TTo>): any;
export declare function Outlet(): JSX.Element | null;
export declare function useInjectHtml(): (html: string | (() => Promise<string> | string)) => void;
export declare function useDehydrate(): <T>(key: any, data: T | (() => T | Promise<T>)) => () => T | undefined;
export declare function useHydrate(): <T = unknown>(key: any) => T;
export declare function ErrorComponent({ error }: {
    error: any;
}): JSX.Element;
export declare function useBlocker(message: string, condition?: boolean | any): void;
export declare function Block({ message, condition, children }: PromptProps): any;
