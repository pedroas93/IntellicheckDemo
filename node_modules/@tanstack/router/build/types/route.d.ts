import { ParsePathParams } from './link';
import { RouteMatch } from './routeMatch';
import { AnyRouter, Router } from './router';
import { IsAny, NoInfer, PickRequired, PickUnsafe, UnionToIntersection } from './utils';
import { AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo';
import { RouteComponent } from './react';
export declare const rootRouteId: "__root__";
export type RootRouteId = typeof rootRouteId;
export type AnyPathParams = {};
export type AnySearchSchema = {};
export type AnyContext = {};
export interface RouteMeta {
}
export interface RouteContext {
}
export type RouteOptionsBase<TCustomId, TPath> = {
    path: TPath;
} | {
    id: TCustomId;
};
export type RouteOptionsBaseIntersection<TCustomId, TPath> = UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>;
export type MetaOptions = keyof PickRequired<RouteMeta> extends never ? {
    meta?: RouteMeta;
} : {
    meta: RouteMeta;
};
type GetContextFn<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext> = (opts: {
    params: TAllParams;
    search: TFullSearchSchema;
} & (TParentRoute extends undefined ? {
    context?: TAllParentContext;
    parentContext?: TParentContext;
} : {
    context: TAllParentContext;
    parentContext: TParentContext;
})) => TRouteContext;
export type ContextOptions<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext> = keyof PickRequired<RouteContext> extends never ? {
    getContext?: GetContextFn<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext>;
} : {
    getContext: GetContextFn<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext>;
};
export type RouteProps<TParentRoute extends AnyRoute, TPath extends string, TFullPath extends ResolveFullPath<TParentRoute, TPath, RoutePrefix<TParentRoute['fullPath'], TPath>>, TCustomId extends string, TId extends ResolveId<TParentRoute, TCustomId, TPath>, TLoader, TSearchSchema extends AnySearchSchema, TFullSearchSchema extends AnySearchSchema, TAllParams, TParentContext, TAllParentContext extends IsAny<TParentRoute['__types']['allParams'], TParentContext, TParentRoute['__types']['allParams'] & TParentContext>, TRouteContext, TContext, TRouterContext extends AnyContext> = {
    useMatch: () => RouteMatch<AnyRoutesInfo, Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TLoader, TSearchSchema, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext, TContext, TRouterContext, any, any>>;
    useLoader: () => UseLoaderResult<TLoader>;
    useSearch: <TStrict extends boolean = true, TSearch = TFullSearchSchema, TSelected = TSearch>(opts?: {
        strict?: TStrict;
        track?: (search: TSearch) => TSelected;
    }) => TStrict extends true ? TSelected : TSelected | undefined;
    useParams: <TDefaultSelected = TAllParams, TSelected = TDefaultSelected>(opts?: {
        track?: (search: TDefaultSelected) => TSelected;
    }) => TSelected;
    useContext: () => TContext;
};
export type RouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TLoader = unknown, TParentSearchSchema extends {} = {}, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = TSearchSchema, TParentParams extends AnyPathParams = {}, TParams = Record<ParsePathParams<TPath>, string>, TAllParams = TParams, TParentContext extends AnyContext = AnyContext, TAllParentContext extends IsAny<TParentRoute['__types']['allParams'], TParentContext, TParentRoute['__types']['allParams'] & TParentContext> = IsAny<TParentRoute['__types']['allParams'], TParentContext, TParentRoute['__types']['allParams'] & TParentContext>, TRouteContext extends RouteContext = RouteContext, TContext extends MergeFromParent<TAllParentContext, TRouteContext> = MergeFromParent<TAllParentContext, TRouteContext>> = RouteOptionsBase<TCustomId, TPath> & {
    getParentRoute: () => TParentRoute;
    getKey?: OnLoadFnKey<TSearchSchema, TFullSearchSchema, TAllParams, NoInfer<TRouteContext>, TContext>;
    caseSensitive?: boolean;
    preSearchFilters?: SearchFilter<TFullSearchSchema>[];
    postSearchFilters?: SearchFilter<TFullSearchSchema>[];
    component?: RouteComponent<RouteProps<TParentRoute, TPath, ResolveFullPath<TParentRoute, TPath>, TCustomId, ResolveId<TParentRoute, TCustomId, TPath>, TLoader, TSearchSchema, TFullSearchSchema, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext, NoInfer<TRouteContext>>>;
    errorComponent?: RouteComponent<{
        error: Error;
        info: {
            componentStack: string;
        };
    }>;
    pendingComponent?: RouteComponent<RouteProps<TParentRoute, TPath, ResolveFullPath<TParentRoute, TPath>, TCustomId, ResolveId<TParentRoute, TCustomId, TPath>, TLoader, TSearchSchema, TFullSearchSchema, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext, NoInfer<TRouteContext>>>;
    wrapInSuspense?: boolean;
    beforeLoad?: (opts: {
        router: AnyRouter;
        match: RouteMatch;
    }) => Promise<void> | void;
    onBeforeLoadError?: (err: any) => void;
    validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>;
    onValidateSearchError?: (err: any) => void;
    loader?: OnLoadFn<TLoader, TSearchSchema, TFullSearchSchema, TAllParams, NoInfer<TRouteContext>, TContext>;
    onLoadError?: (err: any) => void;
    onError?: (err: any) => void;
    onLoaded?: (matchContext: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void | undefined | ((match: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void);
    onTransition?: (match: {
        params: TAllParams;
        search: TFullSearchSchema;
    }) => void;
} & MetaOptions & ContextOptions<TParentRoute, TAllParams, TFullSearchSchema, TParentContext, TAllParentContext, TRouteContext> & ({
    parseParams?: (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
    stringifyParams?: (params: NoInfer<TParams>) => Record<ParsePathParams<TPath>, string>;
} | {
    stringifyParams?: never;
    parseParams?: never;
}) & (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never ? {
    test?: PickUnsafe<TParentParams, ParsePathParams<TPath>>;
} : 'Cannot redefined path params in child routes!');
export type SearchSchemaValidator<TReturn, TParentSchema> = SearchSchemaValidatorObj<TReturn, TParentSchema> | SearchSchemaValidatorFn<TReturn, TParentSchema>;
export type SearchSchemaValidatorObj<TReturn, TParentSchema> = {
    parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>;
};
export type SearchSchemaValidatorFn<TReturn, TParentSchema> = (searchObj: Record<string, unknown>) => {} extends TParentSchema ? TReturn : keyof TReturn extends keyof TParentSchema ? {
    error: 'Top level search params cannot be redefined by child routes!';
    keys: keyof TReturn & keyof TParentSchema;
} : TReturn;
export type DefinedPathParamWarning = 'Path params cannot be redefined by child routes!';
export type ParentParams<TParentParams> = AnyPathParams extends TParentParams ? {} : {
    [Key in keyof TParentParams]?: DefinedPathParamWarning;
};
export type OnLoadFn<TLoader = unknown, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = {}, TAllParams = {}, TContext extends AnyContext = AnyContext, TAllContext extends AnyContext = AnyContext> = (loaderContext: LoaderContext<TSearchSchema, TFullSearchSchema, TAllParams, TContext, TAllContext>) => Promise<TLoader> | TLoader;
export type OnLoadFnKey<TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = {}, TAllParams = {}, TContext extends AnyContext = AnyContext, TAllContext extends AnyContext = AnyContext> = (loaderContext: {
    params: TAllParams;
    search: TFullSearchSchema;
}) => any;
export interface LoaderContext<TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = {}, TAllParams = {}, TContext extends AnyContext = AnyContext, TAllContext extends AnyContext = AnyContext> {
    params: TAllParams;
    routeSearch: TSearchSchema;
    search: TFullSearchSchema;
    signal?: AbortSignal;
    preload: boolean;
    routeContext: TContext;
    context: TAllContext;
}
export type UnloaderFn<TPath extends string> = (routeMatch: RouteMatch<any, Route>) => void;
export type SearchFilter<T, U = T> = (prev: T) => U;
type ResolveId<TParentRoute, TCustomId extends string, TPath extends string> = TParentRoute extends {
    id: infer TParentId extends string;
} ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId> : RootRouteId;
export type InferFullSearchSchema<TRoute> = TRoute extends {
    isRoot: true;
    __types: {
        searchSchema: infer TSearchSchema;
    };
} ? TSearchSchema : TRoute extends {
    __types: {
        fullSearchSchema: infer TFullSearchSchema;
    };
} ? TFullSearchSchema : {};
export type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = InferFullSearchSchema<TParentRoute> & TSearchSchema;
export interface AnyRoute extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
type MergeFromParent<T, U> = IsAny<T, U, T & U>;
export type UseLoaderResult<T> = T extends Record<PropertyKey, infer U> ? {
    [K in keyof T]: UseLoaderResultPromise<T[K]>;
} : UseLoaderResultPromise<T>;
export type UseLoaderResultPromise<T> = T extends Promise<infer U> ? StreamedPromise<U> : T;
export type StreamedPromise<T> = {
    promise: Promise<T>;
    status: 'resolved' | 'pending';
    data: T;
    resolve: (value: T) => void;
};
export declare class Route<TParentRoute extends AnyRoute = AnyRoute, TPath extends string = '/', TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<TParentRoute, TPath>, TCustomId extends string = string, TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<TParentRoute, TCustomId, TPath>, TLoader = unknown, TSearchSchema extends AnySearchSchema = {}, TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends Record<ParsePathParams<TPath>, any> = Record<ParsePathParams<TPath>, string>, TAllParams extends MergeFromParent<TParentRoute['__types']['allParams'], TParams> = MergeFromParent<TParentRoute['__types']['allParams'], TParams>, TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'], TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'], TRouteContext extends RouteContext = RouteContext, TContext extends MergeFromParent<TParentRoute['__types']['context'], TRouteContext> = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>, TRouterContext extends AnyContext = AnyContext, TChildren extends unknown = unknown, TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo> {
    __types: {
        parentRoute: TParentRoute;
        path: TPath;
        to: TrimPathRight<TFullPath>;
        fullPath: TFullPath;
        customId: TCustomId;
        id: TId;
        loader: TLoader;
        searchSchema: TSearchSchema;
        fullSearchSchema: TFullSearchSchema;
        params: TParams;
        allParams: TAllParams;
        parentContext: TParentContext;
        allParentContext: TAllParentContext;
        routeContext: TRouteContext;
        context: TContext;
        children: TChildren;
        routesInfo: TRoutesInfo;
        routerContext: TRouterContext;
    };
    isRoot: TParentRoute extends Route<any> ? true : false;
    options: RouteOptions<TParentRoute, TCustomId, TPath, TLoader, InferFullSearchSchema<TParentRoute>, TSearchSchema, InferFullSearchSchema<TParentRoute> & TSearchSchema, TParentRoute['__types']['allParams'], TParams, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext>;
    parentRoute: TParentRoute;
    id: TId;
    path: TPath;
    fullPath: TFullPath;
    to: TrimPathRight<TFullPath>;
    children?: TChildren;
    originalIndex?: number;
    router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>;
    rank: number;
    constructor(options: RouteOptions<TParentRoute, TCustomId, TPath, TLoader, InferFullSearchSchema<TParentRoute>, TSearchSchema, TFullSearchSchema, TParentRoute['__types']['allParams'], TParams, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext>);
    init: (opts: {
        originalIndex: number;
        router: AnyRouter;
    }) => void;
    addChildren: <TNewChildren extends AnyRoute[]>(children: TNewChildren) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TLoader, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TParentContext, TAllParentContext, TRouteContext, TContext, TRouterContext, TNewChildren, TRoutesInfo>;
    useMatch: <TStrict extends boolean = true, TSelected = TContext>(opts?: {
        strict?: TStrict | undefined;
        track?: ((search: TContext) => TSelected) | undefined;
    } | undefined) => TStrict extends true ? TSelected : TSelected | undefined;
    useLoader: <TStrict extends boolean = true, TSelected = TLoader>(opts?: {
        strict?: TStrict | undefined;
        track?: ((search: TLoader) => TSelected) | undefined;
    } | undefined) => TStrict extends true ? UseLoaderResult<TSelected> : UseLoaderResult<TSelected> | undefined;
    useContext: <TStrict extends boolean = true, TSelected = TContext>(opts?: {
        strict?: TStrict | undefined;
        track?: ((search: TContext) => TSelected) | undefined;
    } | undefined) => TStrict extends true ? TSelected : TSelected | undefined;
    useSearch: <TStrict extends boolean = true, TSelected = TFullSearchSchema>(opts?: {
        strict?: TStrict | undefined;
        track?: ((search: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TStrict extends true ? TSelected : TSelected | undefined;
    useParams: <TStrict extends boolean = true, TSelected = TAllParams>(opts?: {
        strict?: TStrict | undefined;
        track?: ((search: TAllParams) => TSelected) | undefined;
    } | undefined) => TStrict extends true ? TSelected : TSelected | undefined;
}
export type AnyRootRoute = RootRoute<any, any, any, any>;
export declare class RootRoute<TLoader = unknown, TSearchSchema extends AnySearchSchema = {}, TContext extends RouteContext = RouteContext, TRouterContext extends {} = {}> extends Route<any, '/', '/', string, RootRouteId, TLoader, TSearchSchema, TSearchSchema, {}, {}, TRouterContext, TRouterContext, MergeFromParent<TRouterContext, TContext>, MergeFromParent<TRouterContext, TContext>, TRouterContext, any, any> {
    constructor(options?: Omit<RouteOptions<AnyRoute, RootRouteId, '', TLoader, {}, TSearchSchema, NoInfer<TSearchSchema>, {}, TRouterContext, TRouterContext, TContext, NoInfer<TContext>>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams'>);
    static withRouterContext: <TRouterContext_1 extends {}>() => <TLoader_1 = unknown, TSearchSchema_1 extends AnySearchSchema = {}, TContext_1 extends {} = {}>(options?: Omit<RouteOptions<AnyRoute, "__root__", "", TLoader_1, {}, TSearchSchema_1, NoInfer<TSearchSchema_1>, {}, TRouterContext_1, TRouterContext_1, TContext_1, TRouterContext_1 & TContext_1, RouteContext, IsAny<TRouterContext_1 & TContext_1, RouteContext, TRouterContext_1 & TContext_1 & RouteContext>>, "caseSensitive" | "id" | "path" | "getParentRoute"> | undefined) => RootRoute<TLoader_1, TSearchSchema_1, TContext_1, TRouterContext_1>;
}
type ResolveFullPath<TParentRoute extends AnyRoute, TPath extends string, TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<TParentRoute['fullPath'], TPath>> = TPrefixed extends RootRouteId ? '/' : TPrefixed;
type RoutePrefix<TPrefix extends string, TPath extends string> = string extends TPath ? RootRouteId : TPath extends string ? TPrefix extends RootRouteId ? TPath extends '/' ? '/' : `/${TrimPath<TPath>}` : `${TPrefix}/${TPath}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}` : never;
export type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
export type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
export type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;
export {};
