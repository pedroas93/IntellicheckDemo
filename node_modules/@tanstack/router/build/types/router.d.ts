/// <reference types="react" />
import { Store } from '@tanstack/react-store';
import { LinkInfo, LinkOptions, NavigateOptions, ToOptions, ResolveRelativePath } from './link';
import { AnySearchSchema, AnyRoute, RootRoute, AnyContext } from './route';
import { RoutesInfo, AnyRoutesInfo, RoutesById, RoutesByPath } from './routeInfo';
import { RouteMatch } from './routeMatch';
import { NoInfer, PickAsRequired, Timeout, Updater } from './utils';
import { RouterHistory } from './history';
import { RouteComponent } from './react';
declare global {
    interface Window {
        __TSR_DEHYDRATED__?: HydrationCtx;
    }
}
export interface Register {
}
export type AnyRouter = Router<any, any, any>;
export type RegisteredRouter = Register extends {
    router: Router<infer TRoute, infer TRoutesInfo>;
} ? Router<TRoute, TRoutesInfo> : Router;
export type RegisteredRoutesInfo = Register extends {
    router: Router<infer TRoute, infer TRoutesInfo>;
} ? TRoutesInfo : AnyRoutesInfo;
export interface LocationState {
}
export interface ParsedLocation<TSearchObj extends AnySearchSchema = {}, TState extends LocationState = LocationState> {
    href: string;
    pathname: string;
    search: TSearchObj;
    searchStr: string;
    state: TState;
    hash: string;
    key?: string;
}
export interface FromLocation {
    pathname: string;
    search?: unknown;
    key?: string;
    hash?: string;
}
export type SearchSerializer = (searchObj: Record<string, any>) => string;
export type SearchParser = (searchStr: string) => Record<string, any>;
export type HydrationCtx = {
    router: DehydratedRouter;
    payload: Record<string, any>;
};
type RouterContextOptions<TRouteTree extends AnyRoute> = AnyContext extends TRouteTree['__types']['routerContext'] ? {
    context?: TRouteTree['__types']['routerContext'];
} : {
    context: TRouteTree['__types']['routerContext'];
};
export interface RouterOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any>> {
    history?: RouterHistory;
    stringifySearch?: SearchSerializer;
    parseSearch?: SearchParser;
    defaultPreload?: false | 'intent';
    defaultPreloadDelay?: number;
    defaultComponent?: RouteComponent;
    defaultErrorComponent?: RouteComponent<{
        error: Error;
        info: {
            componentStack: string;
        };
    }>;
    defaultPendingComponent?: RouteComponent;
    defaultLoaderMaxAge?: number;
    defaultLoaderGcMaxAge?: number;
    caseSensitive?: boolean;
    routeTree?: TRouteTree;
    basepath?: string;
    createRoute?: (opts: {
        route: AnyRoute;
        router: AnyRouter;
    }) => void;
    onRouteChange?: () => void;
    fetchServerDataFn?: FetchServerDataFn;
    context?: TRouteTree['__types']['routerContext'];
    Wrap?: React.ComponentType<{
        children: React.ReactNode;
    }>;
    dehydrate?: () => TDehydrated;
    hydrate?: (dehydrated: TDehydrated) => void;
}
type FetchServerDataFn = (ctx: {
    router: AnyRouter;
    routeMatch: RouteMatch;
}) => Promise<any>;
export interface RouterState<TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo, TState extends LocationState = LocationState> {
    status: 'idle' | 'pending';
    matches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[];
    location: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>;
    resolvedLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>;
    lastUpdated: number;
}
export type ListenerFn = () => void;
export interface BuildNextOptions {
    to?: string | number | null;
    params?: true | Updater<unknown>;
    search?: true | Updater<unknown>;
    hash?: true | Updater<string>;
    state?: LocationState;
    key?: string;
    from?: string;
    fromCurrent?: boolean;
    __matches?: RouteMatch[];
}
export type MatchCacheEntry = {
    gc: number;
    match: RouteMatch;
};
export interface MatchLocation {
    to?: string | number | null;
    fuzzy?: boolean;
    caseSensitive?: boolean;
    from?: string;
    fromCurrent?: boolean;
}
export interface MatchRouteOptions {
    pending?: boolean;
    caseSensitive?: boolean;
    includeSearch?: boolean;
    fuzzy?: boolean;
}
export interface DehydratedRouterState extends Pick<RouterState, 'status' | 'location' | 'lastUpdated'> {
}
export interface DehydratedRouter {
    state: DehydratedRouterState;
}
export type MatchCache = Record<string, MatchCacheEntry>;
export declare const defaultFetchServerDataFn: FetchServerDataFn;
export type RouterConstructorOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & RouterContextOptions<TRouteTree>;
export declare class Router<TRouteTree extends AnyRoute = AnyRoute, TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>, TDehydrated extends Record<string, any> = Record<string, any>> {
    #private;
    types: {
        RootRoute: TRouteTree;
        RoutesInfo: TRoutesInfo;
    };
    options: PickAsRequired<RouterOptions<TRouteTree, TDehydrated>, 'stringifySearch' | 'parseSearch' | 'context'>;
    context: NonNullable<TRouteTree['__types']['routerContext']>;
    history: RouterHistory;
    basepath: string;
    routeTree: RootRoute;
    routesById: RoutesById<TRoutesInfo>;
    routesByPath: RoutesByPath<TRoutesInfo>;
    flatRoutes: TRoutesInfo['routesByFullPath'][keyof TRoutesInfo['routesByFullPath']][];
    navigateTimeout: undefined | Timeout;
    nextAction: undefined | 'push' | 'replace';
    navigationPromise: undefined | Promise<void>;
    __store: Store<RouterState<TRoutesInfo>>;
    state: RouterState<TRoutesInfo>;
    startedLoadingAt: number;
    resolveNavigation: () => void;
    constructor(options?: RouterConstructorOptions<TRouteTree, TDehydrated>);
    reset: () => void;
    mount: () => () => void;
    update: (opts?: RouterOptions<any, any>) => this;
    buildNext: (opts: BuildNextOptions) => ParsedLocation;
    cancelMatches: () => void;
    safeLoad: (opts?: {
        next?: ParsedLocation;
    }) => void;
    load: (opts?: {
        next?: ParsedLocation;
    }) => Promise<void>;
    getRoute: <TId extends keyof TRoutesInfo["routesById"]>(id: TId) => TRoutesInfo["routesById"][TId];
    loadRoute: (navigateOpts?: BuildNextOptions) => Promise<RouteMatch[]>;
    preloadRoute: (navigateOpts?: BuildNextOptions) => Promise<RouteMatch<import("./routeInfo").DefaultRoutesInfo, AnyRoute>[]>;
    matchRoutes: (pathname: string, search: AnySearchSchema, opts?: {
        strictParseParams?: boolean;
        debug?: boolean;
    }) => RouteMatch[];
    loadMatches: (resolvedMatches: RouteMatch[], location: ParsedLocation, opts?: {
        preload?: boolean;
    }) => Promise<void>;
    reload: () => void;
    resolvePath: (from: string, path: string) => string;
    navigate: <TFrom extends string = "/", TTo extends string = "">({ from, to, search, hash, replace, params, }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => Promise<void>;
    matchRoute: <TFrom extends string = "/", TTo extends string = "", TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>>(location: ToOptions<TRoutesInfo, TFrom, TTo, ResolveRelativePath<TFrom, NoInfer<TTo>>>, opts?: MatchRouteOptions) => false | TRoutesInfo["routesById"][TResolved]["__types"]["allParams"];
    buildLink: <TFrom extends string = "/", TTo extends string = "">({ from, to, search, params, hash, target, replace, activeOptions, preload, preloadDelay: userPreloadDelay, disabled, }: LinkOptions<TRoutesInfo, TFrom, TTo>) => LinkInfo;
    dehydrate: () => DehydratedRouter;
    hydrate: (__do_not_use_server_ctx?: HydrationCtx) => Promise<void>;
    injectedHtml: (string | (() => Promise<string> | string))[];
    injectHtml: (html: string | (() => Promise<string> | string)) => Promise<void>;
    dehydrateData: <T>(key: any, getData: T | (() => T | Promise<T>)) => () => T | undefined;
    hydrateData: <T = unknown>(key: any) => T | undefined;
}
export type AnyRedirect = Redirect<any, any, any>;
export type Redirect<TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {
    code?: number;
};
export declare function redirect<TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo, TFrom extends TRoutesInfo['routePaths'] = '/', TTo extends string = ''>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo>;
export declare function isRedirect(obj: any): obj is AnyRedirect;
export {};
