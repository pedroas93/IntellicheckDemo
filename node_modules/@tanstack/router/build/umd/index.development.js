/**
 * @tanstack/router/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('use-sync-external-store/shim/with-selector')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', 'use-sync-external-store/shim/with-selector'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.RouterCore = {}, global.React, global.withSelector));
})(this, (function (exports, React, withSelector) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var React__namespace = /*#__PURE__*/_interopNamespace(React);

    var prefix = 'Invariant failed';
    function invariant(condition, message) {
        if (condition) {
            return;
        }
        var provided = typeof message === 'function' ? message() : message;
        var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
        throw new Error(value);
    }

    function warning(condition, message) {
      {
        if (condition) {
          return;
        }

        var text = "Warning: " + message;

        if (typeof console !== 'undefined') {
          console.warn(text);
        }

        try {
          throw Error(text);
        } catch (x) {}
      }
    }

    // While the public API was clearly inspired by the "history" npm package,
    // This implementation attempts to be more lightweight by
    // making assumptions about the way TanStack Router works

    const popStateEvent = 'popstate';
    const beforeUnloadEvent = 'beforeunload';
    const beforeUnloadListener = event => {
      event.preventDefault();
      // @ts-ignore
      return event.returnValue = '';
    };
    const stopBlocking = () => {
      removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
        capture: true
      });
    };
    function createHistory(opts) {
      let location = opts.getLocation();
      let unsub = () => {};
      let listeners = new Set();
      let blockers = [];
      let queue = [];
      const tryFlush = () => {
        if (blockers.length) {
          blockers[0]?.(tryFlush, () => {
            blockers = [];
            stopBlocking();
          });
          return;
        }
        while (queue.length) {
          queue.shift()?.();
        }
        onUpdate();
      };
      const queueTask = task => {
        queue.push(task);
        tryFlush();
      };
      const onUpdate = () => {
        location = opts.getLocation();
        listeners.forEach(listener => listener());
      };
      return {
        get location() {
          return location;
        },
        listen: cb => {
          if (listeners.size === 0) {
            unsub = opts.listener(onUpdate);
          }
          listeners.add(cb);
          return () => {
            listeners.delete(cb);
            if (listeners.size === 0) {
              unsub();
            }
          };
        },
        push: (path, state) => {
          queueTask(() => {
            opts.pushState(path, state);
          });
        },
        replace: (path, state) => {
          queueTask(() => {
            opts.replaceState(path, state);
          });
        },
        go: index => {
          queueTask(() => {
            opts.go(index);
          });
        },
        back: () => {
          queueTask(() => {
            opts.back();
          });
        },
        forward: () => {
          queueTask(() => {
            opts.forward();
          });
        },
        createHref: str => opts.createHref(str),
        block: cb => {
          blockers.push(cb);
          if (blockers.length === 1) {
            addEventListener(beforeUnloadEvent, beforeUnloadListener, {
              capture: true
            });
          }
          return () => {
            blockers = blockers.filter(b => b !== cb);
            if (!blockers.length) {
              stopBlocking();
            }
          };
        }
      };
    }
    function createBrowserHistory(opts) {
      const getHref = opts?.getHref ?? (() => `${window.location.pathname}${window.location.search}${window.location.hash}`);
      const createHref = opts?.createHref ?? (path => path);
      const getLocation = () => parseLocation(getHref(), history.state);
      return createHistory({
        getLocation,
        listener: onUpdate => {
          window.addEventListener(popStateEvent, onUpdate);
          return () => {
            window.removeEventListener(popStateEvent, onUpdate);
          };
        },
        pushState: (path, state) => {
          window.history.pushState({
            ...state,
            key: createRandomKey()
          }, '', createHref(path));
        },
        replaceState: (path, state) => {
          window.history.replaceState({
            ...state,
            key: createRandomKey()
          }, '', createHref(path));
        },
        back: () => window.history.back(),
        forward: () => window.history.forward(),
        go: n => window.history.go(n),
        createHref: path => createHref(path)
      });
    }
    function createHashHistory() {
      return createBrowserHistory({
        getHref: () => window.location.hash.substring(1),
        createHref: path => `#${path}`
      });
    }
    function createMemoryHistory(opts = {
      initialEntries: ['/']
    }) {
      const entries = opts.initialEntries;
      let index = opts.initialIndex ?? entries.length - 1;
      let currentState = {};
      const getLocation = () => parseLocation(entries[index], currentState);
      return createHistory({
        getLocation,
        listener: () => {
          return () => {};
        },
        pushState: (path, state) => {
          currentState = {
            ...state,
            key: createRandomKey()
          };
          entries.push(path);
          index++;
        },
        replaceState: (path, state) => {
          currentState = {
            ...state,
            key: createRandomKey()
          };
          entries[index] = path;
        },
        back: () => {
          index--;
        },
        forward: () => {
          index = Math.min(index + 1, entries.length - 1);
        },
        go: n => window.history.go(n),
        createHref: path => path
      });
    }
    function parseLocation(href, state) {
      let hashIndex = href.indexOf('#');
      let searchIndex = href.indexOf('?');
      return {
        href,
        pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),
        hash: hashIndex > -1 ? href.substring(hashIndex) : '',
        search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex) : '',
        state
      };
    }

    // Thanks co-pilot!
    function createRandomKey() {
      return (Math.random() + 1).toString(36).substring(7);
    }

    function last(arr) {
      return arr[arr.length - 1];
    }
    function isFunction(d) {
      return typeof d === 'function';
    }
    function functionalUpdate(updater, previous) {
      if (isFunction(updater)) {
        return updater(previous);
      }
      return updater;
    }
    function pick(parent, keys) {
      return keys.reduce((obj, key) => {
        obj[key] = parent[key];
        return obj;
      }, {});
    }

    /**
     * This function returns `a` if `b` is deeply equal.
     * If not, it will replace any deeply equal children of `b` with those of `a`.
     * This can be used for structural sharing between immutable JSON values for example.
     * Do not use this with signals
     */
    function replaceEqualDeep(prev, _next) {
      if (prev === _next) {
        return prev;
      }
      const next = _next;
      const array = Array.isArray(prev) && Array.isArray(next);
      if (array || isPlainObject(prev) && isPlainObject(next)) {
        const prevSize = array ? prev.length : Object.keys(prev).length;
        const nextItems = array ? next : Object.keys(next);
        const nextSize = nextItems.length;
        const copy = array ? [] : {};
        let equalItems = 0;
        for (let i = 0; i < nextSize; i++) {
          const key = array ? i : nextItems[i];
          copy[key] = replaceEqualDeep(prev[key], next[key]);
          if (copy[key] === prev[key]) {
            equalItems++;
          }
        }
        return prevSize === nextSize && equalItems === prevSize ? prev : copy;
      }
      return next;
    }

    // Copied from: https://github.com/jonschlinkert/is-plain-object
    function isPlainObject(o) {
      if (!hasObjectPrototype(o)) {
        return false;
      }

      // If has modified constructor
      const ctor = o.constructor;
      if (typeof ctor === 'undefined') {
        return true;
      }

      // If has modified prototype
      const prot = ctor.prototype;
      if (!hasObjectPrototype(prot)) {
        return false;
      }

      // If constructor does not have an Object-specific method
      if (!prot.hasOwnProperty('isPrototypeOf')) {
        return false;
      }

      // Most likely a plain Object
      return true;
    }
    function hasObjectPrototype(o) {
      return Object.prototype.toString.call(o) === '[object Object]';
    }
    function partialDeepEqual(a, b) {
      if (a === b) {
        return true;
      }
      if (typeof a !== typeof b) {
        return false;
      }
      if (isPlainObject(a) && isPlainObject(b)) {
        return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));
      }
      if (Array.isArray(a) && Array.isArray(b)) {
        return a.length === b.length && a.every((item, index) => partialDeepEqual(item, b[index]));
      }
      return false;
    }

    function joinPaths(paths) {
      return cleanPath(paths.filter(Boolean).join('/'));
    }
    function cleanPath(path) {
      // remove double slashes
      return path.replace(/\/{2,}/g, '/');
    }
    function trimPathLeft(path) {
      return path === '/' ? path : path.replace(/^\/{1,}/, '');
    }
    function trimPathRight(path) {
      return path === '/' ? path : path.replace(/\/{1,}$/, '');
    }
    function trimPath(path) {
      return trimPathRight(trimPathLeft(path));
    }
    function resolvePath(basepath, base, to) {
      base = base.replace(new RegExp(`^${basepath}`), '/');
      to = to.replace(new RegExp(`^${basepath}`), '/');
      let baseSegments = parsePathname(base);
      const toSegments = parsePathname(to);
      toSegments.forEach((toSegment, index) => {
        if (toSegment.value === '/') {
          if (!index) {
            // Leading slash
            baseSegments = [toSegment];
          } else if (index === toSegments.length - 1) {
            // Trailing Slash
            baseSegments.push(toSegment);
          } else ;
        } else if (toSegment.value === '..') {
          // Extra trailing slash? pop it off
          if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {
            baseSegments.pop();
          }
          baseSegments.pop();
        } else if (toSegment.value === '.') {
          return;
        } else {
          baseSegments.push(toSegment);
        }
      });
      const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);
      return cleanPath(joined);
    }
    function parsePathname(pathname) {
      if (!pathname) {
        return [];
      }
      pathname = cleanPath(pathname);
      const segments = [];
      if (pathname.slice(0, 1) === '/') {
        pathname = pathname.substring(1);
        segments.push({
          type: 'pathname',
          value: '/'
        });
      }
      if (!pathname) {
        return segments;
      }

      // Remove empty segments and '.' segments
      const split = pathname.split('/').filter(Boolean);
      segments.push(...split.map(part => {
        if (part === '$' || part === '*') {
          return {
            type: 'wildcard',
            value: part
          };
        }
        if (part.charAt(0) === '$') {
          return {
            type: 'param',
            value: part
          };
        }
        return {
          type: 'pathname',
          value: part
        };
      }));
      if (pathname.slice(-1) === '/') {
        pathname = pathname.substring(1);
        segments.push({
          type: 'pathname',
          value: '/'
        });
      }
      return segments;
    }
    function interpolatePath(path, params, leaveWildcards = false) {
      const interpolatedPathSegments = parsePathname(path);
      return joinPaths(interpolatedPathSegments.map(segment => {
        if (segment.type === 'wildcard') {
          const value = params[segment.value];
          if (leaveWildcards) return `${segment.value}${value ?? ''}`;
          return value;
        }
        if (segment.type === 'param') {
          return params[segment.value.substring(1)] ?? '';
        }
        return segment.value;
      }));
    }
    function matchPathname(basepath, currentPathname, matchLocation) {
      const pathParams = matchByPath(basepath, currentPathname, matchLocation);
      // const searchMatched = matchBySearch(location.search, matchLocation)

      if (matchLocation.to && !pathParams) {
        return;
      }
      return pathParams ?? {};
    }
    function matchByPath(basepath, from, matchLocation) {
      // Remove the base path from the pathname
      from = basepath != '/' ? from.substring(basepath.length) : from;
      // Default to to $ (wildcard)
      const to = `${matchLocation.to ?? '$'}`;
      // Parse the from and to
      const baseSegments = parsePathname(from);
      const routeSegments = parsePathname(to);
      if (!from.startsWith('/')) {
        baseSegments.unshift({
          type: 'pathname',
          value: '/'
        });
      }
      if (!to.startsWith('/')) {
        routeSegments.unshift({
          type: 'pathname',
          value: '/'
        });
      }
      const params = {};
      let isMatch = (() => {
        for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
          const baseSegment = baseSegments[i];
          const routeSegment = routeSegments[i];
          const isLastBaseSegment = i >= baseSegments.length - 1;
          const isLastRouteSegment = i >= routeSegments.length - 1;
          if (routeSegment) {
            if (routeSegment.type === 'wildcard') {
              if (baseSegment?.value) {
                params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));
                return true;
              }
              return false;
            }
            if (routeSegment.type === 'pathname') {
              if (routeSegment.value === '/' && !baseSegment?.value) {
                return true;
              }
              if (baseSegment) {
                if (matchLocation.caseSensitive) {
                  if (routeSegment.value !== baseSegment.value) {
                    return false;
                  }
                } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
                  return false;
                }
              }
            }
            if (!baseSegment) {
              return false;
            }
            if (routeSegment.type === 'param') {
              if (baseSegment?.value === '/') {
                return false;
              }
              if (baseSegment.value.charAt(0) !== '$') {
                params[routeSegment.value.substring(1)] = baseSegment.value;
              }
            }
          }
          if (!isLastBaseSegment && isLastRouteSegment) {
            return !!matchLocation.fuzzy;
          }
        }
        return true;
      })();
      return isMatch ? params : undefined;
    }

    // @ts-nocheck

    // qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.

    function encode(obj, pfx) {
      var k,
        i,
        tmp,
        str = '';
      for (k in obj) {
        if ((tmp = obj[k]) !== void 0) {
          if (Array.isArray(tmp)) {
            for (i = 0; i < tmp.length; i++) {
              str && (str += '&');
              str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);
            }
          } else {
            str && (str += '&');
            str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);
          }
        }
      }
      return (pfx || '') + str;
    }
    function toValue(mix) {
      if (!mix) return '';
      var str = decodeURIComponent(mix);
      if (str === 'false') return false;
      if (str === 'true') return true;
      if (str.charAt(0) === '0') return str;
      return +str * 0 === 0 ? +str : str;
    }
    function decode(str) {
      var tmp,
        k,
        out = {},
        arr = str.split('&');
      while (tmp = arr.shift()) {
        tmp = tmp.split('=');
        k = tmp.shift();
        if (out[k] !== void 0) {
          out[k] = [].concat(out[k], toValue(tmp.shift()));
        } else {
          out[k] = toValue(tmp.shift());
        }
      }
      return out;
    }

    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }

    /**
     * @tanstack/store/src/index.ts
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    class Store {
      listeners = new Set();
      _batching = false;
      _flushing = 0;
      constructor(initialState, options) {
        this.state = initialState;
        this.options = options;
      }
      subscribe = listener => {
        this.listeners.add(listener);
        const unsub = this.options?.onSubscribe?.(listener, this);
        return () => {
          this.listeners.delete(listener);
          unsub?.();
        };
      };
      setState = updater => {
        const previous = this.state;
        this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);

        // Always run onUpdate, regardless of batching
        this.options?.onUpdate?.();

        // Attempt to flush
        this._flush();
      };
      _flush = () => {
        if (this._batching) return;
        const flushId = ++this._flushing;
        this.listeners.forEach(listener => {
          if (this._flushing !== flushId) return;
          listener();
        });
      };
      batch = cb => {
        if (this._batching) return cb();
        this._batching = true;
        cb();
        this._batching = false;
        this._flush();
      };
    }

    /**
     * @tanstack/react-store/src/index.tsx
     *
     * Copyright (c) TanStack
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */

    function useStore(store, selector = d => d) {
      // const isMountedRef = React.useRef(false)
      // const [state, setState] = React.useState<{ ref: TSelected }>({
      //   ref: undefined!,
      // })

      const slice = withSelector.useSyncExternalStoreWithSelector(store.subscribe, () => store.state, () => store.state, selector, shallow);

      // if (!isMountedRef.current) {
      //   state.ref = slice
      // }

      // if (slice !== state.ref) {
      //   setState({ ref: slice })
      // }

      // React.useEffect(() => {
      //   isMountedRef.current = true
      //   return () => {
      //     isMountedRef.current = false
      //   }
      // }, [])

      // return state.ref

      return slice;
    }
    function shallow(objA, objB) {
      if (Object.is(objA, objB)) {
        return true;
      }
      if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
        return false;
      }
      const keysA = Object.keys(objA);
      if (keysA.length !== Object.keys(objB).length) {
        return false;
      }
      for (let i = 0; i < keysA.length; i++) {
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
          return false;
        }
      }
      return true;
    }

    //

    function lazy(importer, exportName = 'default') {
      const lazyComp = /*#__PURE__*/React__namespace.lazy(async () => {
        const moduleExports = await importer();
        const component = moduleExports[exportName];
        return {
          default: component
        };
      });
      const finalComp = lazyComp;
      finalComp.preload = async () => {
        {
          await importer();
        }
      };
      return finalComp;
    }
    //

    function useLinkProps(options) {
      const router = useRouterContext();
      const {
        // custom props
        type,
        children,
        target,
        activeProps = () => ({
          className: 'active'
        }),
        inactiveProps = () => ({}),
        activeOptions,
        disabled,
        // fromCurrent,
        hash,
        search,
        params,
        to = '.',
        preload,
        preloadDelay,
        replace,
        // element props
        style,
        className,
        onClick,
        onFocus,
        onMouseEnter,
        onMouseLeave,
        onTouchStart,
        ...rest
      } = options;
      const linkInfo = router.buildLink(options);
      if (linkInfo.type === 'external') {
        const {
          href
        } = linkInfo;
        return {
          href
        };
      }
      const {
        handleClick,
        handleFocus,
        handleEnter,
        handleLeave,
        handleTouchStart,
        isActive,
        next
      } = linkInfo;
      const reactHandleClick = e => {
        if (React__namespace.startTransition) {
          // This is a hack for react < 18
          React__namespace.startTransition(() => {
            handleClick(e);
          });
        } else {
          handleClick(e);
        }
      };
      const composeHandlers = handlers => e => {
        if (e.persist) e.persist();
        handlers.filter(Boolean).forEach(handler => {
          if (e.defaultPrevented) return;
          handler(e);
        });
      };

      // Get the active props
      const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};

      // Get the inactive props
      const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};
      return {
        ...resolvedActiveProps,
        ...resolvedInactiveProps,
        ...rest,
        href: disabled ? undefined : next.href,
        onClick: composeHandlers([onClick, reactHandleClick]),
        onFocus: composeHandlers([onFocus, handleFocus]),
        onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
        onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
        onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
        target,
        style: {
          ...style,
          ...resolvedActiveProps.style,
          ...resolvedInactiveProps.style
        },
        className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,
        ...(disabled ? {
          role: 'link',
          'aria-disabled': true
        } : undefined),
        ['data-status']: isActive ? 'active' : undefined
      };
    }
    const Link = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
      const linkProps = useLinkProps(props);
      return /*#__PURE__*/React__namespace.createElement("a", _extends({
        ref: ref
      }, linkProps, {
        children: typeof props.children === 'function' ? props.children({
          isActive: linkProps['data-status'] === 'active'
        }) : props.children
      }));
    });
    function Navigate(props) {
      const router = useRouterContext();
      React__namespace.useLayoutEffect(() => {
        router.navigate(props);
      }, []);
      return null;
    }
    const matchesContext = /*#__PURE__*/React__namespace.createContext(null);
    const routerContext = /*#__PURE__*/React__namespace.createContext(null);
    // const useDeferredValue = React.useDeferredValue || ((d) => d)
    const useDeferredValue = d => d;
    function RouterProvider({
      router,
      ...rest
    }) {
      router.update(rest);
      const matches = useDeferredValue(useStore(router.__store, s => {
        return s.matches;
      }));
      React__namespace.useEffect(router.mount, [router]);
      return /*#__PURE__*/React__namespace.createElement(routerContext.Provider, {
        value: {
          router: router
        }
      }, /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
        value: [undefined, ...matches]
      }, /*#__PURE__*/React__namespace.createElement(CatchBoundary, {
        errorComponent: ErrorComponent,
        onCatch: () => {
          warning(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`);
        }
      }, /*#__PURE__*/React__namespace.createElement(Outlet, null))));
    }
    function useRouterContext() {
      const value = React__namespace.useContext(routerContext);
      warning(value, 'useRouter must be used inside a <Router> component!');
      useStore(value.router.__store);
      return value.router;
    }
    function useRouter(track) {
      const router = useRouterContext();
      useStore(router.__store, track);
      return router;
    }
    function useMatches() {
      return React__namespace.useContext(matchesContext);
    }
    function useMatch(opts) {
      const router = useRouterContext();
      const nearestMatch = useMatches()[0];
      const matches = useDeferredValue(router.state.matches);
      const match = opts?.from ? matches.find(d => d.route.id === opts?.from) : nearestMatch;
      invariant(match, `Could not find ${opts?.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
      if (opts?.strict ?? true) {
        invariant(nearestMatch.route.id == match?.route.id, `useMatch("${match?.route.id}") is being called in a component that is meant to render the '${nearestMatch.route.id}' route. Did you mean to 'useMatch("${match?.route.id}", { strict: false })' or 'useRoute("${match?.route.id}")' instead?`);
      }
      useStore(match.__store, d => opts?.track?.(match) ?? match);
      return match;
    }
    function useLoader(opts) {
      const {
        track,
        ...matchOpts
      } = opts;
      const match = useMatch(matchOpts);
      useStore(match.__store, d => opts?.track?.(d.loader) ?? d.loader);
      return match.state.loader;
    }
    function useSearch(opts) {
      const {
        track,
        ...matchOpts
      } = opts ?? {};
      const match = useMatch(matchOpts);
      useStore(match.__store, d => opts?.track?.(d.search) ?? d.search);
      return match.state.search;
    }
    function useParams(opts) {
      const router = useRouterContext();
      return useStore(router.__store, d => {
        const params = last(d.matches)?.params;
        return opts?.track?.(params) ?? params;
      });

      // return last(router.state.matches)?.params as any
    }

    function useNavigate(defaultOpts) {
      const router = useRouterContext();
      return React__namespace.useCallback(opts => {
        return router.navigate({
          ...defaultOpts,
          ...opts
        });
      }, []);
    }
    function useMatchRoute() {
      const router = useRouterContext();
      return React__namespace.useCallback(opts => {
        const {
          pending,
          caseSensitive,
          ...rest
        } = opts;
        return router.matchRoute(rest, {
          pending,
          caseSensitive
        });
      }, []);
    }
    function MatchRoute(props) {
      const matchRoute = useMatchRoute();
      const params = matchRoute(props);
      if (!params) {
        return null;
      }
      if (typeof props.children === 'function') {
        return props.children(params);
      }
      return params ? props.children : null;
    }
    function Outlet() {
      const matches = useMatches().slice(1);
      const match = matches[0];
      if (!match) {
        return null;
      }
      return /*#__PURE__*/React__namespace.createElement(SubOutlet, {
        matches: matches,
        match: match
      });
    }
    function SubOutlet({
      matches,
      match
    }) {
      const router = useRouterContext();
      useStore(match.__store, store => [store.status, store.error]);
      const defaultPending = React__namespace.useCallback(() => null, []);
      const PendingComponent = match.pendingComponent ?? router.options.defaultPendingComponent ?? defaultPending;
      const errorComponent = match.errorComponent ?? router.options.defaultErrorComponent;
      const ResolvedSuspenseBoundary = match.route.options.wrapInSuspense ?? !match.route.isRoot ? React__namespace.Suspense : SafeFragment;
      const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment;

      // if (typeof document === 'undefined') {
      //   if (match.state.loader) {
      //     Object.keys(match.state.loader).forEach((key) => {
      //       let value = match.state.loader[key]

      //       if (value instanceof Promise || value.then) {
      //         value = {
      //           __isPromise: true,
      //           key: key,
      //         }
      //       }

      //       dehydrated[key] = value
      //     })
      //   }
      // } else {
      // }

      return /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
        value: matches
      }, /*#__PURE__*/React__namespace.createElement(ResolvedSuspenseBoundary, {
        fallback: /*#__PURE__*/React__namespace.createElement(PendingComponent, null)
      }, /*#__PURE__*/React__namespace.createElement(ResolvedCatchBoundary, {
        key: match.route.id,
        errorComponent: errorComponent,
        onCatch: () => {
          warning(false, `Error in route match: ${match.id}`);
        }
      }, /*#__PURE__*/React__namespace.createElement(Inner, {
        match: match
      }))));
    }
    function useInjectHtml() {
      const router = useRouterContext();
      return React__namespace.useCallback(html => {
        router.injectHtml(html);
      }, []);
    }
    function useDehydrate() {
      const router = useRouterContext();
      return React__namespace.useCallback(function dehydrate(key, data) {
        return router.dehydrateData(key, data);
      }, []);
    }
    function useHydrate() {
      const router = useRouterContext();
      return function hydrate(key) {
        return router.hydrateData(key);
      };
    }
    function Inner(props) {
      const router = useRouterContext();
      if (props.match.state.status === 'error') {
        throw props.match.state.error;
      }
      if (props.match.state.status === 'pending') {
        throw props.match.__loadPromise;
      }
      if (props.match.state.status === 'success') {
        let comp = props.match.component ?? router.options.defaultComponent;
        if (comp) {
          return /*#__PURE__*/React__namespace.createElement(comp, {
            useLoader: props.match.route.useLoader,
            useMatch: props.match.route.useMatch,
            useContext: props.match.route.useContext,
            useSearch: props.match.route.useSearch,
            useParams: props.match.route.useParams
          });
        }
        return /*#__PURE__*/React__namespace.createElement(Outlet, null);
      }
      invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
    }
    function SafeFragment(props) {
      return /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, props.children);
    }

    // This is the messiest thing ever... I'm either seriously tired (likely) or
    // there has to be a better way to reset error boundaries when the
    // router's location key changes.

    class CatchBoundary extends React__namespace.Component {
      state = {
        error: false,
        info: undefined
      };
      componentDidCatch(error, info) {
        this.props.onCatch(error, info);
        console.error(error);
        this.setState({
          error,
          info
        });
      }
      render() {
        return /*#__PURE__*/React__namespace.createElement(CatchBoundaryInner, _extends({}, this.props, {
          errorState: this.state,
          reset: () => this.setState({})
        }));
      }
    }
    function CatchBoundaryInner(props) {
      const [activeErrorState, setActiveErrorState] = React__namespace.useState(props.errorState);
      const router = useRouterContext();
      const errorComponent = props.errorComponent ?? ErrorComponent;
      const prevKeyRef = React__namespace.useRef('');
      React__namespace.useEffect(() => {
        if (activeErrorState) {
          if (router.state.location.key !== prevKeyRef.current) ;
        }
        prevKeyRef.current = router.state.location.key;
      }, [activeErrorState, router.state.location.key]);
      React__namespace.useEffect(() => {
        if (props.errorState.error) ;
        // props.reset()
      }, [props.errorState.error]);
      if (props.errorState.error && activeErrorState.error) {
        return /*#__PURE__*/React__namespace.createElement(errorComponent, activeErrorState);
      }
      return props.children;
    }
    function ErrorComponent({
      error
    }) {
      return /*#__PURE__*/React__namespace.createElement("div", {
        style: {
          padding: '.5rem',
          maxWidth: '100%'
        }
      }, /*#__PURE__*/React__namespace.createElement("strong", {
        style: {
          fontSize: '1.2rem'
        }
      }, "Something went wrong!"), /*#__PURE__*/React__namespace.createElement("div", {
        style: {
          height: '.5rem'
        }
      }), /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("pre", {
        style: {
          fontSize: '.7em',
          border: '1px solid red',
          borderRadius: '.25rem',
          padding: '.5rem',
          color: 'red',
          overflow: 'auto'
        }
      }, error.message ? /*#__PURE__*/React__namespace.createElement("code", null, error.message) : null)));
    }
    function useBlocker(message, condition = true) {
      const router = useRouter();
      React__namespace.useEffect(() => {
        if (!condition) return;
        let unblock = router.history.block((retry, cancel) => {
          if (window.confirm(message)) {
            unblock();
            retry();
          }
        });
        return unblock;
      });
    }
    function Block({
      message,
      condition,
      children
    }) {
      useBlocker(message, condition);
      return children ?? null;
    }

    const rootRouteId = '__root__';
    class Route {
      // Set up in this.init()

      // customId!: TCustomId

      // Optional

      constructor(options) {
        this.options = options || {};
        this.isRoot = !options?.getParentRoute;
      }
      init = opts => {
        this.originalIndex = opts.originalIndex;
        this.router = opts.router;
        const allOptions = this.options;
        const isRoot = !allOptions?.path && !allOptions?.id;
        this.parentRoute = this.options?.getParentRoute?.();
        if (isRoot) {
          this.path = rootRouteId;
        } else {
          invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
        }
        let path = isRoot ? rootRouteId : allOptions.path;

        // If the path is anything other than an index path, trim it up
        if (path && path !== '/') {
          path = trimPath(path);
        }
        const customId = allOptions?.id || path;

        // Strip the parentId prefix from the first level of children
        let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);
        if (path === rootRouteId) {
          path = '/';
        }
        if (id !== rootRouteId) {
          id = joinPaths(['/', id]);
        }
        const fullPath = id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path]);
        this.path = path;
        this.id = id;
        // this.customId = customId as TCustomId
        this.fullPath = fullPath;
        this.to = fullPath;
      };
      addChildren = children => {
        this.children = children;
        return this;
      };
      useMatch = opts => {
        return useMatch({
          ...opts,
          from: this.id
        });
      };
      useLoader = opts => {
        return useLoader({
          ...opts,
          from: this.id
        });
      };
      useContext = opts => {
        return useMatch({
          ...opts,
          from: this.id
        }).context;
      };
      useSearch = opts => {
        return useSearch({
          ...opts,
          from: this.id
        });
      };
      useParams = opts => {
        return useParams({
          ...opts,
          from: this.id
        });
      };
    }
    class RootRoute extends Route {
      constructor(options) {
        super(options);
      }
      static withRouterContext = () => {
        return options => new RootRoute(options);
      };
    }

    // const rootRoute = new RootRoute({
    //   validateSearch: () => null as unknown as { root?: boolean },
    // })

    // const aRoute = new Route({
    //   getParentRoute: () => rootRoute,
    //   path: 'a',
    //   validateSearch: () => null as unknown as { a?: string },
    // })

    // const bRoute = new Route({
    //   getParentRoute: () => aRoute,
    //   path: 'b',
    // })

    // const rootIsRoot = rootRoute.isRoot
    // //    ^?
    // const aIsRoot = aRoute.isRoot
    // //    ^?

    // const rId = rootRoute.id
    // //    ^?
    // const aId = aRoute.id
    // //    ^?
    // const bId = bRoute.id
    // //    ^?

    // const rPath = rootRoute.fullPath
    // //    ^?
    // const aPath = aRoute.fullPath
    // //    ^?
    // const bPath = bRoute.fullPath
    // //    ^?

    // const rSearch = rootRoute.__types.fullSearchSchema
    // //    ^?
    // const aSearch = aRoute.__types.fullSearchSchema
    // //    ^?
    // const bSearch = bRoute.__types.fullSearchSchema
    // //    ^?

    // const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])
    // //    ^?

    const defaultParseSearch = parseSearchWith(JSON.parse);
    const defaultStringifySearch = stringifySearchWith(JSON.stringify);
    function parseSearchWith(parser) {
      return searchStr => {
        if (searchStr.substring(0, 1) === '?') {
          searchStr = searchStr.substring(1);
        }
        let query = decode(searchStr);

        // Try to parse any query params that might be json
        for (let key in query) {
          const value = query[key];
          if (typeof value === 'string') {
            try {
              query[key] = parser(value);
            } catch (err) {
              //
            }
          }
        }
        return query;
      };
    }
    function stringifySearchWith(stringify) {
      return search => {
        search = {
          ...search
        };
        if (search) {
          Object.keys(search).forEach(key => {
            const val = search[key];
            if (typeof val === 'undefined' || val === undefined) {
              delete search[key];
            } else if (val && typeof val === 'object' && val !== null) {
              try {
                search[key] = stringify(val);
              } catch (err) {
                // silent
              }
            }
          });
        }
        const searchStr = encode(search).toString();
        return searchStr ? `?${searchStr}` : '';
      };
    }

    const defaultFetchServerDataFn = async ({
      router,
      routeMatch
    }) => {
      const next = router.buildNext({
        to: '.',
        search: d => ({
          ...(d ?? {}),
          __data: {
            matchId: routeMatch.id
          }
        })
      });
      const res = await fetch(next.href, {
        method: 'GET',
        signal: routeMatch.abortController.signal
      });
      if (res.ok) {
        return res.json();
      }
      throw new Error('Failed to fetch match data');
    };
    class Router {
      #unsubHistory;
      startedLoadingAt = Date.now();
      resolveNavigation = () => {};
      constructor(options) {
        this.options = {
          defaultPreloadDelay: 50,
          context: undefined,
          ...options,
          stringifySearch: options?.stringifySearch ?? defaultStringifySearch,
          parseSearch: options?.parseSearch ?? defaultParseSearch,
          fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn
        };
        this.__store = new Store(getInitialRouterState(), {
          onUpdate: () => {
            this.state = this.__store.state;
          }
        });
        this.state = this.__store.state;
        this.update(options);
        const next = this.buildNext({
          hash: true,
          fromCurrent: true,
          search: true,
          state: true
        });
        if (this.state.location.href !== next.href) {
          this.#commitLocation({
            ...next,
            replace: true
          });
        }
      }
      reset = () => {
        this.__store.setState(s => Object.assign(s, getInitialRouterState()));
      };
      mount = () => {
        // Mount only does anything on the client
        if (!isServer) {
          // If the router matches are empty, start loading the matches
          if (!this.state.matches.length) {
            this.safeLoad();
          }
        }
        return () => {};
      };
      update = opts => {
        Object.assign(this.options, opts);
        this.context = this.options.context;
        if (!this.history || this.options.history && this.options.history !== this.history) {
          if (this.#unsubHistory) {
            this.#unsubHistory();
          }
          this.history = this.options.history ?? (isServer ? createMemoryHistory() : createBrowserHistory());
          const parsedLocation = this.#parseLocation();
          this.__store.setState(s => ({
            ...s,
            resolvedLocation: parsedLocation,
            location: parsedLocation
          }));
          this.#unsubHistory = this.history.listen(() => {
            this.safeLoad({
              next: this.#parseLocation(this.state.location)
            });
          });
        }
        const {
          basepath,
          routeTree
        } = this.options;
        this.basepath = `/${trimPath(basepath ?? '') ?? ''}`;
        if (routeTree && routeTree !== this.routeTree) {
          this.#buildRouteTree(routeTree);
        }
        return this;
      };
      buildNext = opts => {
        const next = this.#buildLocation(opts);
        const __matches = this.matchRoutes(next.pathname, next.search);
        return this.#buildLocation({
          ...opts,
          __matches
        });
      };
      cancelMatches = () => {
        [...this.state.matches].forEach(match => {
          match.cancel();
        });
      };
      safeLoad = opts => {
        this.load(opts).catch(err => {
          console.warn(err);
          invariant(false, 'Encountered an error during router.load()! ☝️.');
        });
      };
      load = async opts => {
        this.#createNavigationPromise();
        let now = Date.now();
        const startedAt = now;
        this.startedLoadingAt = startedAt;

        // Cancel any pending matches
        this.cancelMatches();
        let matches;
        this.__store.batch(() => {
          if (opts?.next) {
            // Ingest the new location
            this.__store.setState(s => ({
              ...s,
              location: opts.next
            }));
          }

          // Match the routes
          matches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {
            strictParseParams: true,
            debug: true
          });
          this.__store.setState(s => ({
            ...s,
            status: 'pending',
            matches
          }));
        });
        matches.forEach(match => {
          match.__commit();
        });

        // Load the matches
        await this.loadMatches(matches, this.state.location);
        if (this.startedLoadingAt !== startedAt) {
          // Ignore side-effects of outdated side-effects
          return this.navigationPromise;
        }
        const previousMatches = this.state.matches;
        const exiting = [],
          staying = [];
        previousMatches.forEach(d => {
          if (matches.find(dd => dd.id === d.id)) {
            staying.push(d);
          } else {
            exiting.push(d);
          }
        });
        const entering = matches.filter(d => {
          return !previousMatches.find(dd => dd.id === d.id);
        });
        now = Date.now();
        exiting.forEach(d => {
          d.__onExit?.({
            params: d.params,
            search: d.state.routeSearch
          });

          // Clear non-loading error states when match leaves
          if (d.state.status === 'error') {
            this.__store.setState(s => ({
              ...s,
              status: 'idle',
              error: undefined
            }));
          }
        });
        staying.forEach(d => {
          d.route.options.onTransition?.({
            params: d.params,
            search: d.state.routeSearch
          });
        });
        entering.forEach(d => {
          d.__onExit = d.route.options.onLoaded?.({
            params: d.params,
            search: d.state.search
          });
        });
        const prevLocation = this.state.location;
        this.__store.setState(s => ({
          ...s,
          status: 'idle',
          resolvedLocation: s.location,
          matches
        }));
        if (prevLocation.href !== this.state.location.href) {
          this.options.onRouteChange?.();
        }
        this.resolveNavigation();
      };
      getRoute = id => {
        const route = this.routesById[id];
        invariant(route, `Route with id "${id}" not found`);
        return route;
      };
      loadRoute = async (navigateOpts = this.state.location) => {
        const next = this.buildNext(navigateOpts);
        const matches = this.matchRoutes(next.pathname, next.search, {
          strictParseParams: true
        });
        await this.loadMatches(matches, next);
        return matches;
      };
      preloadRoute = async (navigateOpts = this.state.location) => {
        const next = this.buildNext(navigateOpts);
        const matches = this.matchRoutes(next.pathname, next.search, {
          strictParseParams: true
        });
        await this.loadMatches(matches, next, {
          preload: true
        });
        return matches;
      };
      matchRoutes = (pathname, search, opts) => {
        // If there's no route tree, we can't match anything
        if (!this.flatRoutes.length) {
          return [];
        }
        let routeParams = {};
        let foundRoute = this.flatRoutes.find(route => {
          const matchedParams = matchPathname(this.basepath, pathname, {
            to: route.fullPath,
            caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive
          });
          if (matchedParams) {
            routeParams = matchedParams;
            return true;
          }
          return false;
        });
        if (!foundRoute) {
          return [];
        }
        let matchedRoutes = [foundRoute];
        while (foundRoute?.parentRoute) {
          foundRoute = foundRoute.parentRoute;
          if (foundRoute) matchedRoutes.unshift(foundRoute);
        }

        // Alright, by now we should have all of our
        // matching routes and their param pairs, let's
        // Turn them into actual `Match` objects and
        // accumulate the params into a single params bag
        let allParams = {};

        // Existing matches are matches that are already loaded along with
        // pending matches that are still loading
        const existingMatches = [...this.state.matches];
        const matches = matchedRoutes.map(route => {
          let parsedParams;
          try {
            parsedParams = route.options.parseParams?.(routeParams) ?? routeParams;
          } catch (err) {
            if (opts?.strictParseParams) {
              throw err;
            }
          }

          // Add the parsed params to the accumulated params bag
          Object.assign(allParams, parsedParams);
          const interpolatedPath = interpolatePath(route.path, allParams);
          const matchId = interpolatePath(route.id, allParams, true) + (route.options.getKey?.({
            params: allParams,
            search
          }) ?? '');

          // Waste not, want not. If we already have a match for this route,
          // reuse it. This is important for layout routes, which might stick
          // around between navigation actions that only change leaf routes.
          const existingMatch = existingMatches.find(d => d.id === matchId);
          if (existingMatch) {
            return existingMatch;
          }
          return new RouteMatch(this, route, {
            id: matchId,
            params: allParams,
            pathname: joinPaths([this.basepath, interpolatedPath])
          });
        }).filter((d, i, all) => {
          // Filter out any duplicate matches
          // I honesty don't know why this is necessary, but it is and it's safe for now
          // Someday someone will figure out why my logic is wrong and fix it to just
          // not create duplicate matches in the first place
          return all.findIndex(dd => dd.id === d.id) === i;
        });
        return matches;
      };
      loadMatches = async (resolvedMatches, location, opts) => {
        let firstBadMatchIndex;

        // Check each match middleware to see if the route can be accessed
        try {
          await Promise.all(resolvedMatches.map(async (match, index) => {
            try {
              await match.route.options.beforeLoad?.({
                router: this,
                match
              });
            } catch (err) {
              if (isRedirect(err)) {
                throw err;
              }
              firstBadMatchIndex = firstBadMatchIndex ?? index;
              const errorHandler = match.route.options.onBeforeLoadError ?? match.route.options.onError;
              try {
                errorHandler?.(err);
              } catch (errorHandlerErr) {
                if (isRedirect(errorHandlerErr)) {
                  throw errorHandlerErr;
                }
                match.__store.setState(s => ({
                  ...s,
                  error: errorHandlerErr,
                  status: 'error',
                  updatedAt: Date.now()
                }));
                return;
              }
              match.__store.setState(s => ({
                ...s,
                error: err,
                status: 'error',
                updatedAt: Date.now()
              }));
            }
          }));
        } catch (err) {
          if (isRedirect(err)) {
            if (!opts?.preload) {
              this.navigate(err);
            }
            return;
          }
          throw err; // we should never end up here
        }

        const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex);
        const matchPromises = validResolvedMatches.map(async (match, index) => {
          const parentMatch = validResolvedMatches[index - 1];
          match.__load({
            preload: opts?.preload,
            location,
            parentMatch
          });
          await match.__loadPromise;
          if (parentMatch) {
            await parentMatch.__loadPromise;
          }
        });
        await Promise.all(matchPromises);
      };
      reload = () => {
        this.navigate({
          fromCurrent: true,
          replace: true,
          search: true
        });
      };
      resolvePath = (from, path) => {
        return resolvePath(this.basepath, from, cleanPath(path));
      };
      navigate = async ({
        from,
        to = '',
        search,
        hash,
        replace,
        params
      }) => {
        // If this link simply reloads the current route,
        // make sure it has a new key so it will trigger a data refresh

        // If this `to` is a valid external URL, return
        // null for LinkUtils
        const toString = String(to);
        const fromString = typeof from === 'undefined' ? from : String(from);
        let isExternal;
        try {
          new URL(`${toString}`);
          isExternal = true;
        } catch (e) {}
        invariant(!isExternal, 'Attempting to navigate to external url with this.navigate!');
        return this.#commitLocation({
          from: fromString,
          to: toString,
          search,
          hash,
          replace,
          params
        });
      };
      matchRoute = (location, opts) => {
        location = {
          ...location,
          to: location.to ? this.resolvePath(location.from ?? '', location.to) : undefined
        };
        const next = this.buildNext(location);
        if (opts?.pending && this.state.status !== 'pending') {
          return false;
        }
        const baseLocation = opts?.pending ? this.state.location : this.state.resolvedLocation;
        if (!baseLocation) {
          return false;
        }
        const match = matchPathname(this.basepath, baseLocation.pathname, {
          ...opts,
          to: next.pathname
        });
        if (!match) {
          return false;
        }
        if (opts?.includeSearch ?? true) {
          return partialDeepEqual(baseLocation.search, next.search) ? match : false;
        }
        return match;
      };
      buildLink = ({
        from,
        to = '.',
        search,
        params,
        hash,
        target,
        replace,
        activeOptions,
        preload,
        preloadDelay: userPreloadDelay,
        disabled
      }) => {
        // If this link simply reloads the current route,
        // make sure it has a new key so it will trigger a data refresh

        // If this `to` is a valid external URL, return
        // null for LinkUtils

        try {
          new URL(`${to}`);
          return {
            type: 'external',
            href: to
          };
        } catch (e) {}
        const nextOpts = {
          from,
          to,
          search,
          params,
          hash,
          replace
        };
        const next = this.buildNext(nextOpts);
        preload = preload ?? this.options.defaultPreload;
        const preloadDelay = userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0;

        // Compare path/hash for matches
        const currentPathSplit = this.state.location.pathname.split('/');
        const nextPathSplit = next.pathname.split('/');
        const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
        // Combine the matches based on user options
        const pathTest = activeOptions?.exact ? this.state.location.pathname === next.pathname : pathIsFuzzyEqual;
        const hashTest = activeOptions?.includeHash ? this.state.location.hash === next.hash : true;
        const searchTest = activeOptions?.includeSearch ?? true ? partialDeepEqual(this.state.location.search, next.search) : true;

        // The final "active" test
        const isActive = pathTest && hashTest && searchTest;

        // The click handler
        const handleClick = e => {
          if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
            e.preventDefault();

            // All is well? Navigate!
            this.#commitLocation(nextOpts);
          }
        };

        // The click handler
        const handleFocus = e => {
          if (preload) {
            this.preloadRoute(nextOpts).catch(err => {
              console.warn(err);
              console.warn('Error preloading route! ☝️');
            });
          }
        };
        const handleTouchStart = e => {
          this.preloadRoute(nextOpts).catch(err => {
            console.warn(err);
            console.warn('Error preloading route! ☝️');
          });
        };
        const handleEnter = e => {
          const target = e.target || {};
          if (preload) {
            if (target.preloadTimeout) {
              return;
            }
            target.preloadTimeout = setTimeout(() => {
              target.preloadTimeout = null;
              this.preloadRoute(nextOpts).catch(err => {
                console.warn(err);
                console.warn('Error preloading route! ☝️');
              });
            }, preloadDelay);
          }
        };
        const handleLeave = e => {
          const target = e.target || {};
          if (target.preloadTimeout) {
            clearTimeout(target.preloadTimeout);
            target.preloadTimeout = null;
          }
        };
        return {
          type: 'internal',
          next,
          handleFocus,
          handleClick,
          handleEnter,
          handleLeave,
          handleTouchStart,
          isActive,
          disabled
        };
      };
      dehydrate = () => {
        return {
          state: {
            ...pick(this.state, ['location', 'status', 'lastUpdated'])
            // matches: this.state.matches.map((m) => ({
            //   id: m.id,
            //   promiseKeys: Object.keys(m.__promisesByKey),
            // })),
          }
        };
      };

      hydrate = async __do_not_use_server_ctx => {
        let _ctx = __do_not_use_server_ctx;
        // Client hydrates from window
        if (typeof document !== 'undefined') {
          _ctx = window.__TSR_DEHYDRATED__;
        }
        invariant(_ctx, 'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?');
        const ctx = _ctx;
        this.options.hydrate?.(ctx.payload);
        this.__store.setState(s => {
          return {
            ...s,
            ...ctx.router.state,
            matches: s.matches,
            resolvedLocation: ctx.router.state.location
          };
        });
        await this.load();

        // this.state.matches.forEach((m) => {
        //   m.__promiseKeys =
        //     ctx.router.state.matches.find((d) => d.id === m.id)?.promiseKeys ?? []
        // })

        return;
      };
      injectedHtml = [];
      injectHtml = async html => {
        this.injectedHtml.push(html);
      };
      dehydrateData = (key, getData) => {
        if (typeof document === 'undefined') {
          const strKey = typeof key === 'string' ? key : JSON.stringify(key);
          this.injectHtml(async () => {
            const data = typeof getData === 'function' ? await getData() : getData;
            return `<script>window["__TSR__DEHYRATED__${escapeJSON(strKey)}"] = ${JSON.stringify(data)}</script>`;
          });
          return () => this.hydrateData(key);
        }
        return () => undefined;
      };
      hydrateData = key => {
        if (typeof document !== 'undefined') {
          const strKey = typeof key === 'string' ? key : JSON.stringify(key);
          return window[`__TSR__DEHYRATED__${strKey}`];
        }
        return undefined;
      };

      // resolveMatchPromise = (matchId: string, key: string, value: any) => {
      //   this.state.matches
      //     .find((d) => d.id === matchId)
      //     ?.__promisesByKey[key]?.resolve(value)
      // }

      #buildRouteTree = routeTree => {
        this.routeTree = routeTree;
        this.routesById = {};
        this.routesByPath = {};
        this.flatRoutes = [];
        const recurseRoutes = routes => {
          routes.forEach((route, i) => {
            route.init({
              originalIndex: i,
              router: this
            });
            const existingRoute = this.routesById[route.id];
            invariant(!existingRoute, `Duplicate routes found with id: ${String(route.id)}`);
            this.routesById[route.id] = route;
            if (!route.isRoot && route.path) {
              const trimmedFullPath = trimPathRight(route.fullPath);
              if (!this.routesByPath[trimmedFullPath] || route.fullPath.endsWith('/')) {
                this.routesByPath[trimmedFullPath] = route;
              }
            }
            const children = route.children;
            if (children?.length) {
              recurseRoutes(children);
            }
          });
        };
        recurseRoutes([routeTree]);
        this.flatRoutes = Object.values(this.routesByPath).map((d, i) => {
          const trimmed = trimPath(d.fullPath);
          const parsed = parsePathname(trimmed);
          while (parsed.length > 1 && parsed[0]?.value === '/') {
            parsed.shift();
          }
          const score = parsed.map(d => {
            if (d.type === 'param') {
              return 0.5;
            }
            if (d.type === 'wildcard') {
              return 0.25;
            }
            return 1;
          });
          return {
            child: d,
            trimmed,
            parsed,
            index: i,
            score
          };
        }).sort((a, b) => {
          let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0;
          if (isIndex !== 0) return isIndex;
          const length = Math.min(a.score.length, b.score.length);

          // Sort by length of score
          if (a.score.length !== b.score.length) {
            return b.score.length - a.score.length;
          }

          // Sort by min available score
          for (let i = 0; i < length; i++) {
            if (a.score[i] !== b.score[i]) {
              return b.score[i] - a.score[i];
            }
          }

          // Sort by min available parsed value
          for (let i = 0; i < length; i++) {
            if (a.parsed[i].value !== b.parsed[i].value) {
              return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
            }
          }

          // Sort by length of trimmed full path
          if (a.trimmed !== b.trimmed) {
            return a.trimmed > b.trimmed ? 1 : -1;
          }

          // Sort by original index
          return a.index - b.index;
        }).map((d, i) => {
          d.child.rank = i;
          return d.child;
        });
      };
      #parseLocation = previousLocation => {
        let {
          pathname,
          search,
          hash,
          state
        } = this.history.location;
        const parsedSearch = this.options.parseSearch(search);
        return {
          pathname: pathname,
          searchStr: search,
          search: replaceEqualDeep(previousLocation?.search, parsedSearch),
          hash: hash.split('#').reverse()[0] ?? '',
          href: `${pathname}${search}${hash}`,
          state: state,
          key: state?.key || '__init__'
        };
      };
      #buildLocation = (dest = {}) => {
        dest.fromCurrent = dest.fromCurrent ?? dest.to === '';
        const fromPathname = dest.fromCurrent ? this.state.location.pathname : dest.from ?? this.state.location.pathname;
        let pathname = resolvePath(this.basepath ?? '/', fromPathname, `${dest.to ?? ''}`);
        const fromMatches = this.matchRoutes(this.state.location.pathname, this.state.location.search, {
          strictParseParams: true
        });
        const prevParams = {
          ...last(fromMatches)?.params
        };
        let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);
        if (nextParams) {
          dest.__matches?.map(d => d.route.options.stringifyParams).filter(Boolean).forEach(fn => {
            nextParams = {
              ...nextParams,
              ...fn(nextParams)
            };
          });
        }
        pathname = interpolatePath(pathname, nextParams ?? {});
        const preSearchFilters = dest.__matches?.map(match => match.route.options.preSearchFilters ?? []).flat().filter(Boolean) ?? [];
        const postSearchFilters = dest.__matches?.map(match => match.route.options.postSearchFilters ?? []).flat().filter(Boolean) ?? [];

        // Pre filters first
        const preFilteredSearch = preSearchFilters?.length ? preSearchFilters?.reduce((prev, next) => next(prev), this.state.location.search) : this.state.location.search;

        // Then the link/navigate function
        const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true
        : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater
        : preSearchFilters?.length ? preFilteredSearch // Preserve resolvedFrom filters
        : {};

        // Then post filters
        const postFilteredSearch = postSearchFilters?.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
        const search = replaceEqualDeep(this.state.location.search, postFilteredSearch);
        const searchStr = this.options.stringifySearch(search);
        const hash = dest.hash === true ? this.state.location.hash : functionalUpdate(dest.hash, this.state.location.hash);
        const hashStr = hash ? `#${hash}` : '';
        const nextState = dest.state === true ? this.state.location.state : functionalUpdate(dest.state, this.state.location.state);
        return {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash,
          href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),
          key: dest.key
        };
      };
      #commitLocation = async location => {
        const next = this.buildNext(location);
        const id = '' + Date.now() + Math.random();
        if (this.navigateTimeout) clearTimeout(this.navigateTimeout);
        let nextAction = 'replace';
        if (!location.replace) {
          nextAction = 'push';
        }
        const isSameUrl = this.state.location.href === next.href;
        if (isSameUrl && !next.key) {
          nextAction = 'replace';
        }
        const href = `${next.pathname}${next.searchStr}${next.hash ? `#${next.hash}` : ''}`;
        this.history[nextAction === 'push' ? 'push' : 'replace'](href, {
          id,
          ...next.state
        });
        return this.#createNavigationPromise();
      };
      #createNavigationPromise = () => {
        const previousNavigationResolve = this.resolveNavigation;
        this.navigationPromise = new Promise(resolve => {
          this.resolveNavigation = () => {
            resolve();
            previousNavigationResolve();
          };
        });
        return this.navigationPromise;
      };
    }

    // Detect if we're in the DOM
    const isServer = typeof window === 'undefined' || !window.document.createElement;
    function getInitialRouterState() {
      return {
        status: 'idle',
        resolvedLocation: null,
        location: null,
        matches: [],
        lastUpdated: Date.now()
      };
    }
    function isCtrlEvent(e) {
      return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
    }
    function redirect(opts) {
      opts.isRedirect = true;
      return opts;
    }
    function isRedirect(obj) {
      return !!obj?.isRedirect;
    }
    function escapeJSON(jsonString) {
      return jsonString.replace(/\\/g, '\\\\') // Escape backslashes
      .replace(/'/g, "\\'") // Escape single quotes
      .replace(/"/g, '\\"'); // Escape double quotes
    }

    const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
    class RouteMatch {
      abortController = new AbortController();
      constructor(router, route, opts) {
        Object.assign(this, {
          route,
          router,
          id: opts.id,
          pathname: opts.pathname,
          params: opts.params,
          __store: new Store({
            updatedAt: 0,
            routeSearch: {},
            search: {},
            status: 'pending',
            loader: undefined
          }, {
            onUpdate: () => {
              this.state = this.__store.state;
            }
          })
        });
        this.state = this.__store.state;
        componentTypes.map(async type => {
          const component = this.route.options[type];
          this[type] = component;
        });
        this.__loadPromise = new Promise(r => {
          this.__loadPromiseResolve = r;
        });
        if (this.state.status === 'pending' && !this.#hasLoaders()) {
          this.__store.setState(s => ({
            ...s,
            status: 'success'
          }));
          this.__loadPromiseResolve?.();
        }
      }
      #hasLoaders = () => {
        return !!(this.route.options.loader || componentTypes.some(d => this.route.options[d]?.preload));
      };
      __commit = () => {
        const {
          routeSearch,
          search,
          context,
          routeContext
        } = this.#resolveInfo({
          location: this.router.state.location
        });
        this.context = context;
        this.routeContext = routeContext;
        this.__store.setState(s => ({
          ...s,
          routeSearch: replaceEqualDeep(s.routeSearch, routeSearch),
          search: replaceEqualDeep(s.search, search)
        }));
      };
      cancel = () => {
        this.abortController?.abort();
      };
      #resolveSearchInfo = opts => {
        // Validate the search params and stabilize them
        const parentSearchInfo = this.parentMatch ? this.parentMatch.#resolveSearchInfo(opts) : {
          search: opts.location.search,
          routeSearch: opts.location.search
        };
        try {
          const validator = typeof this.route.options.validateSearch === 'object' ? this.route.options.validateSearch.parse : this.route.options.validateSearch;
          const routeSearch = validator?.(parentSearchInfo.search) ?? {};
          const search = {
            ...parentSearchInfo.search,
            ...routeSearch
          };
          return {
            routeSearch,
            search
          };
        } catch (err) {
          if (isRedirect(err)) {
            throw err;
          }
          const errorHandler = this.route.options.onValidateSearchError ?? this.route.options.onError;
          errorHandler?.(err);
          const error = new Error('Invalid search params found', {
            cause: err
          });
          error.code = 'INVALID_SEARCH_PARAMS';
          throw error;
        }
      };
      #resolveInfo = opts => {
        const {
          search,
          routeSearch
        } = this.#resolveSearchInfo(opts);
        try {
          const routeContext = this.route.options.getContext?.({
            parentContext: this.parentMatch?.routeContext ?? {},
            context: this.parentMatch?.context ?? this.router?.options.context ?? {},
            params: this.params,
            search
          }) || {};
          const context = {
            ...(this.parentMatch?.context ?? this.router?.options.context),
            ...routeContext
          };
          return {
            routeSearch,
            search,
            context,
            routeContext
          };
        } catch (err) {
          this.route.options.onError?.(err);
          throw err;
        }
      };
      __load = async opts => {
        this.parentMatch = opts.parentMatch;
        let info;
        try {
          info = this.#resolveInfo(opts);
        } catch (err) {
          if (isRedirect(err)) {
            if (!opts?.preload) {
              this.router.navigate(err);
            }
            return;
          }
          this.__store.setState(s => ({
            ...s,
            status: 'error',
            error: err
          }));

          // Do not proceed with loading the route
          return;
        }
        const {
          routeSearch,
          search,
          context,
          routeContext
        } = info;
        const loaderOpts = {
          params: this.params,
          routeSearch,
          search,
          signal: this.abortController.signal,
          preload: !!opts?.preload,
          routeContext,
          context
        };
        this.__loadPromise = Promise.resolve().then(async () => {
          const loadId = '' + Date.now() + Math.random();
          this.#latestId = loadId;
          const checkLatest = () => {
            return loadId !== this.#latestId ? this.__loadPromise : undefined;
          };
          let latestPromise;
          const componentsPromise = (async () => {
            // then run all component and data loaders in parallel
            // For each component type, potentially load it asynchronously

            await Promise.all(componentTypes.map(async type => {
              const component = this.route.options[type];
              if (component?.preload) {
                await component.preload();
              }
            }));
          })();
          const loaderPromise = Promise.resolve().then(() => {
            if (this.route.options.loader) {
              return this.route.options.loader(loaderOpts);
            }
            return;
          });
          try {
            const [_, loader] = await Promise.all([componentsPromise, loaderPromise]);
            if (latestPromise = checkLatest()) return await latestPromise;

            // Object.keys(loader ?? {}).forEach((key) => {
            //   const value = loader[key]
            //   if (value instanceof Promise || value?.then) {
            //     // if (this.__promisesByKey[key]) {
            //     //   return
            //     // }

            //     if (typeof document === 'undefined') {
            //       this.__promisesByKey[key] = {
            //         status: 'pending',
            //         promise: value,
            //         data: undefined,
            //         resolve: () => {},
            //       }

            //       value.then((d: any) => {
            //         this.__promisesByKey[key]!.status = 'resolved'
            //         this.__promisesByKey[key]!.data = d
            //       })
            //     } else {
            //       const promise = createPromise()
            //       this.__promisesByKey[key] = {
            //         status: 'pending',
            //         promise,
            //         data: undefined,
            //         resolve: (d: any) => {
            //           // @ts-ignore
            //           promise.resolve()
            //           this.__promisesByKey[key]!.status = 'resolved'
            //           this.__promisesByKey[key]!.data = d
            //         },
            //       }

            //       if (!this.__promiseKeys.includes(key)) {
            //         value.then(this.__promisesByKey[key]!.resolve)
            //       }
            //     }

            //     loader[key] = this.__promisesByKey[key]
            //   }
            // })

            if (!opts.preload) {
              this.__store.setState(s => ({
                ...s,
                error: undefined,
                status: 'success',
                updatedAt: Date.now(),
                loader
              }));
            }
          } catch (err) {
            if (isRedirect(err)) {
              if (!opts?.preload) {
                this.router.navigate(err);
              }
              return;
            }
            const errorHandler = this.route.options.onLoadError ?? this.route.options.onError;
            try {
              errorHandler?.(err);
            } catch (errorHandlerErr) {
              if (isRedirect(errorHandlerErr)) {
                if (!opts?.preload) {
                  this.router.navigate(errorHandlerErr);
                }
                return;
              }
              this.__store.setState(s => ({
                ...s,
                error: errorHandlerErr,
                status: 'error',
                updatedAt: Date.now()
              }));
              return;
            }
            this.__store.setState(s => ({
              ...s,
              error: err,
              status: 'error',
              updatedAt: Date.now()
            }));
          } finally {
            this.__loadPromiseResolve?.();
            delete this.__loadPromise;
          }
        });
        return this.__loadPromise;
      };
      #latestId = '';
    }

    exports.Block = Block;
    exports.ErrorComponent = ErrorComponent;
    exports.Link = Link;
    exports.MatchRoute = MatchRoute;
    exports.Navigate = Navigate;
    exports.Outlet = Outlet;
    exports.RootRoute = RootRoute;
    exports.Route = Route;
    exports.RouteMatch = RouteMatch;
    exports.Router = Router;
    exports.RouterProvider = RouterProvider;
    exports.cleanPath = cleanPath;
    exports.createBrowserHistory = createBrowserHistory;
    exports.createHashHistory = createHashHistory;
    exports.createMemoryHistory = createMemoryHistory;
    exports.decode = decode;
    exports.defaultFetchServerDataFn = defaultFetchServerDataFn;
    exports.defaultParseSearch = defaultParseSearch;
    exports.defaultStringifySearch = defaultStringifySearch;
    exports.encode = encode;
    exports.functionalUpdate = functionalUpdate;
    exports.interpolatePath = interpolatePath;
    exports.invariant = invariant;
    exports.isPlainObject = isPlainObject;
    exports.isRedirect = isRedirect;
    exports.joinPaths = joinPaths;
    exports.last = last;
    exports.lazy = lazy;
    exports.matchByPath = matchByPath;
    exports.matchPathname = matchPathname;
    exports.matchesContext = matchesContext;
    exports.parsePathname = parsePathname;
    exports.parseSearchWith = parseSearchWith;
    exports.partialDeepEqual = partialDeepEqual;
    exports.pick = pick;
    exports.redirect = redirect;
    exports.replaceEqualDeep = replaceEqualDeep;
    exports.resolvePath = resolvePath;
    exports.rootRouteId = rootRouteId;
    exports.routerContext = routerContext;
    exports.stringifySearchWith = stringifySearchWith;
    exports.trimPath = trimPath;
    exports.trimPathLeft = trimPathLeft;
    exports.trimPathRight = trimPathRight;
    exports.useBlocker = useBlocker;
    exports.useDehydrate = useDehydrate;
    exports.useHydrate = useHydrate;
    exports.useInjectHtml = useInjectHtml;
    exports.useLinkProps = useLinkProps;
    exports.useLoader = useLoader;
    exports.useMatch = useMatch;
    exports.useMatchRoute = useMatchRoute;
    exports.useMatches = useMatches;
    exports.useNavigate = useNavigate;
    exports.useParams = useParams;
    exports.useRouter = useRouter;
    exports.useRouterContext = useRouterContext;
    exports.useSearch = useSearch;
    exports.useStore = useStore;
    exports.warning = warning;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map
