{"version":3,"file":"index.production.js","sources":["../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js","../../src/history.ts","../../src/utils.ts","../../src/path.ts","../../src/qss.ts","../../../store/build/esm/index.js","../../../react-store/build/esm/index.js","../../src/react.tsx","../../src/route.ts","../../src/searchParams.ts","../../src/router.ts","../../src/routeMatch.ts"],"sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: RouterLocation\n  listen: (cb: () => void) => () => void\n  push: (path: string, state?: any) => void\n  replace: (path: string, state?: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blockerFn: BlockerFn) => () => void\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface RouterLocation extends ParsedPath {\n  state: any\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void\n\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nfunction createHistory(opts: {\n  getLocation: () => RouterLocation\n  listener: (onUpdate: () => void) => () => void\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n}): RouterHistory {\n  let location = opts.getLocation()\n  let unsub = () => {}\n  let listeners = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n  let queue: (() => void)[] = []\n\n  const tryFlush = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryFlush, () => {\n        blockers = []\n        stopBlocking()\n      })\n      return\n    }\n\n    while (queue.length) {\n      queue.shift()?.()\n    }\n\n    onUpdate()\n  }\n\n  const queueTask = (task: () => void) => {\n    queue.push(task)\n    tryFlush()\n  }\n\n  const onUpdate = () => {\n    location = opts.getLocation()\n    listeners.forEach((listener) => listener())\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    listen: (cb: () => void) => {\n      if (listeners.size === 0) {\n        unsub = opts.listener(onUpdate)\n      }\n      listeners.add(cb)\n\n      return () => {\n        listeners.delete(cb)\n        if (listeners.size === 0) {\n          unsub()\n        }\n      }\n    },\n    push: (path: string, state: any) => {\n      queueTask(() => {\n        opts.pushState(path, state)\n      })\n    },\n    replace: (path: string, state: any) => {\n      queueTask(() => {\n        opts.replaceState(path, state)\n      })\n    },\n    go: (index) => {\n      queueTask(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (cb) => {\n      blockers.push(cb)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== cb)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n  }\n}\n\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.search}${window.location.hash}`)\n  const createHref = opts?.createHref ?? ((path) => path)\n  const getLocation = () => parseLocation(getHref(), history.state)\n\n  return createHistory({\n    getLocation,\n    listener: (onUpdate) => {\n      window.addEventListener(popStateEvent, onUpdate)\n      return () => {\n        window.removeEventListener(popStateEvent, onUpdate)\n      }\n    },\n    pushState: (path, state) => {\n      window.history.pushState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    replaceState: (path, state) => {\n      window.history.replaceState(\n        { ...state, key: createRandomKey() },\n        '',\n        createHref(path),\n      )\n    },\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n    createHref: (path) => createHref(path),\n  })\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {}\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    listener: () => {\n      return () => {}\n    },\n    pushState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = {\n        ...state,\n        key: createRandomKey(),\n      }\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n    createHref: (path) => path,\n  })\n}\n\nfunction parseLocation(href: string, state: any): RouterLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state,\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n","export type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\ntype Compute<T> = { [K in keyof T]: T[K] } | never\n\ntype AllKeys<T> = T extends any ? keyof T : never\n\nexport type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n  {\n    [K in Keys]: T[Keys]\n  } & {\n    [K in AllKeys<T>]?: T extends any\n      ? K extends keyof T\n        ? T[K]\n        : never\n      : never\n  }\n>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult>,\n  previous: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return (\n      a.length === b.length &&\n      a.every((item, index) => partialDeepEqual(item, b[index]))\n    )\n  }\n\n  return false\n}\n","import { AnyPathParams } from './route'\nimport { MatchLocation } from './router'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  if (str.charAt(0) === '0') return str\n  return +str * 0 === 0 ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","/**\n * @tanstack/store/src/index.ts\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nclass Store {\n  listeners = new Set();\n  _batching = false;\n  _flushing = 0;\n  constructor(initialState, options) {\n    this.state = initialState;\n    this.options = options;\n  }\n  subscribe = listener => {\n    this.listeners.add(listener);\n    const unsub = this.options?.onSubscribe?.(listener, this);\n    return () => {\n      this.listeners.delete(listener);\n      unsub?.();\n    };\n  };\n  setState = updater => {\n    const previous = this.state;\n    this.state = this.options?.updateFn ? this.options.updateFn(previous)(updater) : updater(previous);\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.();\n\n    // Attempt to flush\n    this._flush();\n  };\n  _flush = () => {\n    if (this._batching) return;\n    const flushId = ++this._flushing;\n    this.listeners.forEach(listener => {\n      if (this._flushing !== flushId) return;\n      listener();\n    });\n  };\n  batch = cb => {\n    if (this._batching) return cb();\n    this._batching = true;\n    cb();\n    this._batching = false;\n    this._flush();\n  };\n}\n\nexport { Store };\n//# sourceMappingURL=index.js.map\n","/**\n * @tanstack/react-store/src/index.tsx\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { useSyncExternalStoreWithSelector } from 'use-sync-external-store/shim/with-selector';\nexport * from '@tanstack/store';\n\nfunction useStore(store, selector = d => d) {\n  // const isMountedRef = React.useRef(false)\n  // const [state, setState] = React.useState<{ ref: TSelected }>({\n  //   ref: undefined!,\n  // })\n\n  const slice = useSyncExternalStoreWithSelector(store.subscribe, () => store.state, () => store.state, selector, shallow);\n\n  // if (!isMountedRef.current) {\n  //   state.ref = slice\n  // }\n\n  // if (slice !== state.ref) {\n  //   setState({ ref: slice })\n  // }\n\n  // React.useEffect(() => {\n  //   isMountedRef.current = true\n  //   return () => {\n  //     isMountedRef.current = false\n  //   }\n  // }, [])\n\n  // return state.ref\n\n  return slice;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n  const keysA = Object.keys(objA);\n  if (keysA.length !== Object.keys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport { shallow, useStore };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\nimport { NoInfer, useStore } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport {\n  LinkOptions,\n  ToOptions,\n  ResolveRelativePath,\n  NavigateOptions,\n} from './link'\nimport { AnyRoute } from './route'\nimport { RouteByPath, AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport { AnyRouteMatch, RouteMatch } from './routeMatch'\nimport {\n  RegisteredRoutesInfo,\n  MatchRouteOptions,\n  RegisteredRouter,\n  RouterOptions,\n  RouterState,\n  Router,\n} from './router'\nimport { functionalUpdate, last } from './utils'\n\n//\n\nexport { useStore }\n\n//\n\ntype ReactNode = any\n\nexport type SyncRouteComponent<TProps = {}> = (props: TProps) => ReactNode\n\nexport type RouteComponent<TProps = {}> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport function lazy<T extends Record<string, SyncRouteComponent>>(\n  importer: () => Promise<T>,\n  exportName: keyof T = 'default',\n): RouteComponent {\n  const lazyComp = React.lazy(async () => {\n    const moduleExports = await importer()\n    const component = moduleExports[exportName]\n    return { default: component }\n  })\n\n  let preloaded: Promise<SyncRouteComponent>\n\n  const finalComp = lazyComp as unknown as RouteComponent\n\n  finalComp.preload = async () => {\n    if (!preloaded) {\n      await importer()\n    }\n  }\n\n  return finalComp\n}\n\nexport type LinkPropsOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = LinkOptions<RegisteredRoutesInfo, TFrom, TTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n\nexport type MakeUseMatchRouteOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> & MatchRouteOptions\n\nexport type MakeMatchRouteOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = ToOptions<RegisteredRoutesInfo, TFrom, TTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ReactNode\n      | ((\n          params: RouteByPath<\n            RegisteredRoutesInfo,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['__types']['allParams'],\n        ) => ReactNode)\n  }\n\nexport type MakeLinkPropsOptions<\n  TFrom extends string = '/',\n  TTo extends string = '',\n> = LinkPropsOptions<TFrom, TTo> & React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type MakeLinkOptions<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = LinkPropsOptions<TFrom, TTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type PromptProps = {\n  message: string\n  condition?: boolean | any\n  children?: ReactNode\n}\n\n//\n\nexport function useLinkProps<\n  TFrom extends string = '/',\n  TTo extends string = '',\n>(\n  options: MakeLinkPropsOptions<TFrom, TTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const router = useRouterContext()\n\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    // fromCurrent,\n    hash,\n    search,\n    params,\n    to = '.',\n    preload,\n    preloadDelay,\n    replace,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  const linkInfo = router.buildLink(options as any)\n\n  if (linkInfo.type === 'external') {\n    const { href } = linkInfo\n    return { href }\n  }\n\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next,\n  } = linkInfo\n\n  const reactHandleClick = (e: Event) => {\n    if (React.startTransition) {\n      // This is a hack for react < 18\n      React.startTransition(() => {\n        handleClick(e)\n      })\n    } else {\n      handleClick(e)\n    }\n  }\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled ? undefined : next.href,\n    onClick: composeHandlers([onClick, reactHandleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkFn<\n  TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TDefaultTo extends string = '',\n> {\n  <\n    TFrom extends RegisteredRoutesInfo['routePaths'] = TDefaultFrom,\n    TTo extends string = TDefaultTo,\n  >(\n    props: MakeLinkOptions<TFrom, TTo> & React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkFn = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n\nexport function Navigate<\n  TFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(props: NavigateOptions<RegisteredRoutesInfo, TFrom, TTo>): null {\n  const router = useRouterContext()\n\n  React.useLayoutEffect(() => {\n    router.navigate(props as any)\n  }, [])\n\n  return null\n}\n\ntype MatchesContextValue = AnyRouteMatch[]\n\nexport const matchesContext = React.createContext<MatchesContextValue>(null!)\nexport const routerContext = React.createContext<{ router: RegisteredRouter }>(\n  null!,\n)\n\nexport type MatchesProviderProps = {\n  value: MatchesContextValue\n  children: ReactNode\n}\n\nexport type RouterProps<\n  TRouteConfig extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = RouterOptions<TRouteConfig, TDehydrated> & {\n  router: Router<TRouteConfig, TRoutesInfo>\n}\n\n// const useDeferredValue = React.useDeferredValue || ((d) => d)\nconst useDeferredValue = <T,>(d: T) => d\n\nexport function RouterProvider<\n  TRouteConfig extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteConfig, TRoutesInfo, TDehydrated>) {\n  router.update(rest)\n\n  const matches = useDeferredValue(\n    useStore(router.__store, (s) => {\n      return s.matches\n    }),\n  )\n\n  React.useEffect(router.mount, [router])\n\n  return (\n    <routerContext.Provider value={{ router: router as any }}>\n      <matchesContext.Provider value={[undefined!, ...matches]}>\n        <CatchBoundary\n          errorComponent={ErrorComponent}\n          onCatch={() => {\n            warning(\n              false,\n              `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`,\n            )\n          }}\n        >\n          <Outlet />\n        </CatchBoundary>\n      </matchesContext.Provider>\n    </routerContext.Provider>\n  )\n}\n\nexport function useRouterContext(): RegisteredRouter {\n  const value = React.useContext(routerContext)\n  warning(value, 'useRouter must be used inside a <Router> component!')\n\n  useStore(value.router.__store)\n\n  return value.router\n}\n\nexport function useRouter<T = RouterState>(\n  track?: (state: Router['__store']['state']) => T,\n): RegisteredRouter {\n  const router = useRouterContext()\n  useStore(router.__store, track as any)\n  return router\n}\n\nexport function useMatches(): RouteMatch[] {\n  return React.useContext(matchesContext)\n}\n\nexport function useMatch<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TRouteMatch = RouteMatch<\n    RegisteredRoutesInfo,\n    RegisteredRoutesInfo['routesById'][TFrom]\n  >,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  track?: (match: TRouteMatch) => any\n}): TStrict extends true ? TRouteMatch : TRouteMatch | undefined {\n  const router = useRouterContext()\n  const nearestMatch = useMatches()[0]!\n  const matches = useDeferredValue(router.state.matches)\n  const match = opts?.from\n    ? matches.find((d) => d.route.id === opts?.from)\n    : nearestMatch\n\n  invariant(\n    match,\n    `Could not find ${\n      opts?.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'\n    }`,\n  )\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatch.route.id == match?.route.id,\n      `useMatch(\"${\n        match?.route.id as string\n      }\") is being called in a component that is meant to render the '${\n        nearestMatch.route.id\n      }' route. Did you mean to 'useMatch(\"${\n        match?.route.id as string\n      }\", { strict: false })' or 'useRoute(\"${\n        match?.route.id as string\n      }\")' instead?`,\n    )\n  }\n\n  useStore(match!.__store as any, (d) => opts?.track?.(match as any) ?? match)\n\n  return match as any\n}\n\nexport type RouteFromIdOrRoute<T> = T extends RegisteredRoutesInfo['routeUnion']\n  ? T\n  : T extends keyof RegisteredRoutesInfo['routesById']\n  ? RegisteredRoutesInfo['routesById'][T]\n  : T extends string\n  ? keyof RegisteredRoutesInfo['routesById']\n  : never\n\nexport function useLoader<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TLoader = RegisteredRoutesInfo['routesById'][TFrom]['__types']['loader'],\n  TSelected = TLoader,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  track?: (search: TLoader) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  const { track, ...matchOpts } = opts as any\n  const match = useMatch(matchOpts)\n  useStore(match.__store, (d: any) => opts?.track?.(d.loader) ?? d.loader)\n  return (match as unknown as RouteMatch).state.loader as any\n}\n\nexport function useSearch<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'],\n  TStrict extends boolean = true,\n  TSearch = RegisteredRoutesInfo['routesById'][TFrom]['__types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(opts?: {\n  from: TFrom\n  strict?: TStrict\n  track?: (search: TSearch) => TSelected\n}): TStrict extends true ? TSelected : TSelected | undefined {\n  const { track, ...matchOpts } = (opts ?? {}) as any\n  const match = useMatch(matchOpts)\n  useStore(match.__store, (d: any) => opts?.track?.(d.search) ?? d.search)\n\n  return (match as unknown as RouteMatch).state.search as any\n}\n\nexport function useParams<\n  TFrom extends keyof RegisteredRoutesInfo['routesById'] = '/',\n  TDefaultSelected = RegisteredRoutesInfo['allParams'] &\n    RegisteredRoutesInfo['routesById'][TFrom]['__types']['allParams'],\n  TSelected = TDefaultSelected,\n>(opts?: {\n  from: TFrom\n  track?: (search: TDefaultSelected) => TSelected\n}): TSelected {\n  const router = useRouterContext()\n  return useStore(router.__store, (d) => {\n    const params = last(d.matches)?.params as any\n    return opts?.track?.(params) ?? params\n  })\n\n  // return last(router.state.matches)?.params as any\n}\n\nexport function useNavigate<\n  TDefaultFrom extends RegisteredRoutesInfo['routePaths'] = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const router = useRouterContext()\n  return React.useCallback(\n    <\n      TFrom extends RegisteredRoutesInfo['routePaths'] = TDefaultFrom,\n      TTo extends string = '',\n    >(\n      opts?: NavigateOptions<RegisteredRoutesInfo, TFrom, TTo>,\n    ) => {\n      return router.navigate({ ...defaultOpts, ...(opts as any) })\n    },\n    [],\n  )\n}\n\nexport function useMatchRoute() {\n  const router = useRouterContext()\n\n  return React.useCallback(\n    <TFrom extends string = '/', TTo extends string = ''>(\n      opts: MakeUseMatchRouteOptions<TFrom, TTo>,\n    ) => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport function MatchRoute<TFrom extends string = '/', TTo extends string = ''>(\n  props: MakeMatchRouteOptions<TFrom, TTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props)\n\n  if (!params) {\n    return null\n  }\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return params ? props.children : null\n}\n\nexport function Outlet() {\n  const matches = useMatches().slice(1)\n  const match = matches[0]\n\n  if (!match) {\n    return null\n  }\n\n  return <SubOutlet matches={matches} match={match} />\n}\n\nfunction SubOutlet({\n  matches,\n  match,\n}: {\n  matches: RouteMatch[]\n  match: RouteMatch\n}) {\n  const router = useRouterContext()\n  useStore(match!.__store, (store) => [store.status, store.error])\n\n  const defaultPending = React.useCallback(() => null, [])\n\n  const PendingComponent = (match.pendingComponent ??\n    router.options.defaultPendingComponent ??\n    defaultPending) as any\n\n  const errorComponent =\n    match.errorComponent ?? router.options.defaultErrorComponent\n\n  const ResolvedSuspenseBoundary =\n    match.route.options.wrapInSuspense ?? !match.route.isRoot\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = errorComponent ? CatchBoundary : SafeFragment\n\n  // if (typeof document === 'undefined') {\n  //   if (match.state.loader) {\n  //     Object.keys(match.state.loader).forEach((key) => {\n  //       let value = match.state.loader[key]\n\n  //       if (value instanceof Promise || value.then) {\n  //         value = {\n  //           __isPromise: true,\n  //           key: key,\n  //         }\n  //       }\n\n  //       dehydrated[key] = value\n  //     })\n  //   }\n  // } else {\n  // }\n\n  return (\n    <matchesContext.Provider value={matches}>\n      <ResolvedSuspenseBoundary fallback={<PendingComponent />}>\n        <ResolvedCatchBoundary\n          key={match.route.id}\n          errorComponent={errorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${match.id}`)\n          }}\n        >\n          <Inner match={match} />\n          {/* {!match.route.isRoot\n            ? Object.keys(match.__promisesByKey).map((key) => {\n                return (\n                  <React.Suspense key={key}>\n                    <StreamScript\n                      match={match}\n                      promiseKey={key}\n                      promise={match.__promisesByKey[key]!}\n                    />\n                  </React.Suspense>\n                )\n              })\n            : null} */}\n        </ResolvedCatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchesContext.Provider>\n  )\n}\n\nexport function useInjectHtml() {\n  const router = useRouterContext()\n\n  return React.useCallback(\n    (html: string | (() => Promise<string> | string)) => {\n      router.injectHtml(html)\n    },\n    [],\n  )\n}\n\nexport function useDehydrate() {\n  const router = useRouterContext()\n\n  return React.useCallback(function dehydrate<T>(\n    key: any,\n    data: T | (() => Promise<T> | T),\n  ) {\n    return router.dehydrateData(key, data)\n  },\n  [])\n}\n\nexport function useHydrate() {\n  const router = useRouterContext()\n\n  return function hydrate<T = unknown>(key: any) {\n    return router.hydrateData(key) as T\n  }\n}\n\nfunction Inner(props: { match: RouteMatch }): any {\n  const router = useRouterContext()\n\n  if (props.match.state.status === 'error') {\n    throw props.match.state.error\n  }\n\n  if (props.match.state.status === 'pending') {\n    throw props.match.__loadPromise\n  }\n\n  if (props.match.state.status === 'success') {\n    let comp = props.match.component ?? router.options.defaultComponent\n\n    if (comp) {\n      return React.createElement(comp, {\n        useLoader: props.match.route.useLoader,\n        useMatch: props.match.route.useMatch,\n        useContext: props.match.route.useContext,\n        useSearch: props.match.route.useSearch,\n        useParams: props.match.route.useParams,\n      })\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\n// This is the messiest thing ever... I'm either seriously tired (likely) or\n// there has to be a better way to reset error boundaries when the\n// router's location key changes.\n\nclass CatchBoundary extends React.Component<{\n  children: any\n  errorComponent: any\n  onCatch: (error: any, info: any) => void\n}> {\n  state = {\n    error: false,\n    info: undefined,\n  }\n  componentDidCatch(error: any, info: any) {\n    this.props.onCatch(error, info)\n    console.error(error)\n    this.setState({\n      error,\n      info,\n    })\n  }\n  render() {\n    return (\n      <CatchBoundaryInner\n        {...this.props}\n        errorState={this.state}\n        reset={() => this.setState({})}\n      />\n    )\n  }\n}\n\nfunction CatchBoundaryInner(props: {\n  children: any\n  errorComponent: any\n  errorState: { error: unknown; info: any }\n  reset: () => void\n}) {\n  const [activeErrorState, setActiveErrorState] = React.useState(\n    props.errorState,\n  )\n  const router = useRouterContext()\n  const errorComponent = props.errorComponent ?? ErrorComponent\n  const prevKeyRef = React.useRef('' as any)\n\n  React.useEffect(() => {\n    if (activeErrorState) {\n      if (router.state.location.key !== prevKeyRef.current) {\n        // setActiveErrorState({} as any)\n      }\n    }\n\n    prevKeyRef.current = router.state.location.key\n  }, [activeErrorState, router.state.location.key])\n\n  React.useEffect(() => {\n    if (props.errorState.error) {\n      // setActiveErrorState(props.errorState)\n    }\n    // props.reset()\n  }, [props.errorState.error])\n\n  if (props.errorState.error && activeErrorState.error) {\n    return React.createElement(errorComponent, activeErrorState)\n  }\n\n  return props.children\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <strong style={{ fontSize: '1.2rem' }}>Something went wrong!</strong>\n      <div style={{ height: '.5rem' }} />\n      <div>\n        <pre\n          style={{\n            fontSize: '.7em',\n            border: '1px solid red',\n            borderRadius: '.25rem',\n            padding: '.5rem',\n            color: 'red',\n            overflow: 'auto',\n          }}\n        >\n          {error.message ? <code>{error.message}</code> : null}\n        </pre>\n      </div>\n    </div>\n  )\n}\n\nexport function useBlocker(\n  message: string,\n  condition: boolean | any = true,\n): void {\n  const router = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n\n    let unblock = router.history.block((retry, cancel) => {\n      if (window.confirm(message)) {\n        unblock()\n        retry()\n      }\n    })\n\n    return unblock\n  })\n}\n\nexport function Block({ message, condition, children }: PromptProps) {\n  useBlocker(message, condition)\n  return (children ?? null) as ReactNode\n}\n","import { ParsePathParams } from './link'\nimport { RouteMatch } from './routeMatch'\nimport { AnyRouter, RegisteredRoutesInfo, Router } from './router'\nimport {\n  IsAny,\n  NoInfer,\n  PickRequired,\n  PickUnsafe,\n  UnionToIntersection,\n} from './utils'\nimport invariant from 'tiny-invariant'\nimport { joinPaths, trimPath, trimPathRight } from './path'\nimport { AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport {\n  MakeLinkOptions,\n  RouteComponent,\n  useLoader,\n  useMatch,\n  useParams,\n  useSearch,\n} from './react'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\nexport type AnySearchSchema = {}\nexport type AnyContext = {}\nexport interface RouteMeta {}\nexport interface RouteContext {}\n\nexport type RouteOptionsBase<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RouteOptionsBaseIntersection<TCustomId, TPath> =\n  UnionToIntersection<RouteOptionsBase<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\ntype GetContextFn<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = (\n  opts: {\n    params: TAllParams\n    search: TFullSearchSchema\n  } & (TParentRoute extends undefined\n    ? {\n        context?: TAllParentContext\n        parentContext?: TParentContext\n      }\n    : {\n        context: TAllParentContext\n        parentContext: TParentContext\n      }),\n) => TRouteContext\n\nexport type ContextOptions<\n  TParentRoute,\n  TAllParams,\n  TFullSearchSchema,\n  TParentContext,\n  TAllParentContext,\n  TRouteContext,\n> = keyof PickRequired<RouteContext> extends never\n  ? {\n      getContext?: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n  : {\n      getContext: GetContextFn<\n        TParentRoute,\n        TAllParams,\n        TFullSearchSchema,\n        TParentContext,\n        TAllParentContext,\n        TRouteContext\n      >\n    }\n\nexport type RouteProps<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TFullPath extends ResolveFullPath<\n    TParentRoute,\n    TPath,\n    RoutePrefix<TParentRoute['fullPath'], TPath>\n  >,\n  TCustomId extends string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath>,\n  TLoader,\n  TSearchSchema extends AnySearchSchema,\n  TFullSearchSchema extends AnySearchSchema,\n  TAllParams,\n  TParentContext,\n  TAllParentContext extends IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  >,\n  TRouteContext,\n  TContext,\n  TRouterContext extends AnyContext,\n> = {\n  useMatch: () => RouteMatch<\n    AnyRoutesInfo,\n    Route<\n      TParentRoute,\n      TPath,\n      TFullPath,\n      TCustomId,\n      TId,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      TRouterContext,\n      any,\n      any\n    >\n  >\n  useLoader: () => UseLoaderResult<TLoader>\n  useSearch: <\n    TStrict extends boolean = true,\n    TSearch = TFullSearchSchema,\n    TSelected = TSearch,\n  >(opts?: {\n    strict?: TStrict\n    track?: (search: TSearch) => TSelected\n  }) => TStrict extends true ? TSelected : TSelected | undefined\n  useParams: <\n    TDefaultSelected = TAllParams,\n    TSelected = TDefaultSelected,\n  >(opts?: {\n    track?: (search: TDefaultSelected) => TSelected\n  }) => TSelected\n  useContext: () => TContext\n  // navigate: <T extends TFullPath, TTo extends string = ''>(\n  //   opts?: MakeLinkOptions<T, TTo>,\n  // ) => Promise<void>\n}\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TLoader = unknown,\n  TParentSearchSchema extends {} = {},\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = TSearchSchema,\n  TParentParams extends AnyPathParams = {},\n  TParams = Record<ParsePathParams<TPath>, string>,\n  TAllParams = TParams,\n  TParentContext extends AnyContext = AnyContext,\n  TAllParentContext extends IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  > = IsAny<\n    TParentRoute['__types']['allParams'],\n    TParentContext,\n    TParentRoute['__types']['allParams'] & TParentContext\n  >,\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TAllParentContext,\n    TRouteContext\n  > = MergeFromParent<TAllParentContext, TRouteContext>,\n> = RouteOptionsBase<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  // Optionally call this function to get a unique key for this route.\n  // This is useful for routes that need to be uniquely identified\n  // by more than their by search params\n  getKey?: OnLoadFnKey<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    NoInfer<TRouteContext>,\n    TContext\n  >\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent<\n    RouteProps<\n      TParentRoute,\n      TPath,\n      ResolveFullPath<TParentRoute, TPath>,\n      TCustomId,\n      ResolveId<TParentRoute, TCustomId, TPath>,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      NoInfer<TRouteContext>\n    >\n  > //\n  // The content to be rendered when the route encounters an error\n  errorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }> //\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: RouteComponent<\n    RouteProps<\n      TParentRoute,\n      TPath,\n      ResolveFullPath<TParentRoute, TPath>,\n      TCustomId,\n      ResolveId<TParentRoute, TCustomId, TPath>,\n      TLoader,\n      TSearchSchema,\n      TFullSearchSchema,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext,\n      NoInfer<TRouteContext>\n    >\n  > //\n  wrapInSuspense?: boolean\n\n  // This async function is called before a route is loaded.\n  // If an error is thrown here, the route's loader will not be called.\n  // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onLoadError` function.\n  // If thrown during a preload event, the error will be logged to the console.\n  beforeLoad?: (opts: {\n    router: AnyRouter\n    match: RouteMatch\n  }) => Promise<void> | void\n  // This function will be called if the route's loader throws an error **during an attempted navigation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  onBeforeLoadError?: (err: any) => void\n  validateSearch?: SearchSchemaValidator<TSearchSchema, TParentSearchSchema>\n  // This function will be called if the route's validateSearch option throws an error **during an attempted validation**.\n  // If you want to redirect due to an error, call `router.navigate()` from within this function.\n  // If you want to display the errorComponent, rethrow the error\n  onValidateSearchError?: (err: any) => void\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  loader?: OnLoadFn<\n    TLoader,\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    NoInfer<TRouteContext>,\n    TContext\n  >\n  onLoadError?: (err: any) => void\n  onError?: (err: any) => void\n  // This function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onLoaded?: (matchContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) =>\n    | void\n    | undefined\n    | ((match: { params: TAllParams; search: TFullSearchSchema }) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: {\n    params: TAllParams\n    search: TFullSearchSchema\n  }) => void\n} & MetaOptions &\n  ContextOptions<\n    TParentRoute,\n    TAllParams,\n    TFullSearchSchema,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext\n  > &\n  (\n    | {\n        // Parse params optionally receives path params as strings and returns them in a parsed format (like a number or boolean)\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<TParams>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  ) &\n  (PickUnsafe<TParentParams, ParsePathParams<TPath>> extends never // Detect if an existing path param is being redefined\n    ? { test?: PickUnsafe<TParentParams, ParsePathParams<TPath>> }\n    : 'Cannot redefined path params in child routes!')\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn, TParentSchema> =\n  | SearchSchemaValidatorObj<TReturn, TParentSchema>\n  | SearchSchemaValidatorFn<TReturn, TParentSchema>\n\nexport type SearchSchemaValidatorObj<TReturn, TParentSchema> = {\n  parse?: SearchSchemaValidatorFn<TReturn, TParentSchema>\n}\n\nexport type SearchSchemaValidatorFn<TReturn, TParentSchema> = (\n  searchObj: Record<string, unknown>,\n) => {} extends TParentSchema\n  ? TReturn\n  : keyof TReturn extends keyof TParentSchema\n  ? {\n      error: 'Top level search params cannot be redefined by child routes!'\n      keys: keyof TReturn & keyof TParentSchema\n    }\n  : TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type OnLoadFn<\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  loaderContext: LoaderContext<\n    TSearchSchema,\n    TFullSearchSchema,\n    TAllParams,\n    TContext,\n    TAllContext\n  >,\n) => Promise<TLoader> | TLoader\n\nexport type OnLoadFnKey<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> = (\n  loaderContext: {\n    params: TAllParams\n    search: TFullSearchSchema\n  },\n  // loaderContext: LoaderContext<\n  //   TSearchSchema,\n  //   TFullSearchSchema,\n  //   TAllParams,\n  //   TContext,\n  //   TAllContext\n  // >,\n) => any\n\nexport interface LoaderContext<\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = {},\n  TAllParams = {},\n  TContext extends AnyContext = AnyContext,\n  TAllContext extends AnyContext = AnyContext,\n> {\n  params: TAllParams\n  routeSearch: TSearchSchema\n  search: TFullSearchSchema\n  signal?: AbortSignal\n  preload: boolean\n  routeContext: TContext\n  context: TAllContext\n  // serverOnly: <\n  //   TServer extends object | (() => object),\n  //   TClient extends object | (() => object),\n  // >(\n  //   server: TServer,\n  //   client: TClient,\n  // ) => (TServer extends () => infer TReturn ? TReturn : TServer) &\n  //   (TClient extends () => infer TReturn ? TReturn : TClient)\n}\n\nexport type UnloaderFn<TPath extends string> = (\n  routeMatch: RouteMatch<any, Route>,\n) => void\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\ntype ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  isRoot: true\n  __types: {\n    searchSchema: infer TSearchSchema\n  }\n}\n  ? TSearchSchema\n  : TRoute extends {\n      __types: {\n        fullSearchSchema: infer TFullSearchSchema\n      }\n    }\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> =\n  InferFullSearchSchema<TParentRoute> & TSearchSchema\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\ntype MergeFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type UseLoaderResult<T> = T extends Record<PropertyKey, infer U>\n  ? {\n      [K in keyof T]: UseLoaderResultPromise<T[K]>\n    }\n  : UseLoaderResultPromise<T>\n\nexport type UseLoaderResultPromise<T> = T extends Promise<infer U>\n  ? StreamedPromise<U>\n  : T\n\nexport type StreamedPromise<T> = {\n  promise: Promise<T>\n  status: 'resolved' | 'pending'\n  data: T\n  resolve: (value: T) => void\n}\n\nexport class Route<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TPath extends string = '/',\n  TFullPath extends ResolveFullPath<TParentRoute, TPath> = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends string = string,\n  TId extends ResolveId<TParentRoute, TCustomId, TPath> = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TFullSearchSchema extends AnySearchSchema = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends Record<ParsePathParams<TPath>, any> = Record<\n    ParsePathParams<TPath>,\n    string\n  >,\n  TAllParams extends MergeFromParent<\n    TParentRoute['__types']['allParams'],\n    TParams\n  > = MergeFromParent<TParentRoute['__types']['allParams'], TParams>,\n  TParentContext extends TParentRoute['__types']['routeContext'] = TParentRoute['__types']['routeContext'],\n  TAllParentContext extends TParentRoute['__types']['context'] = TParentRoute['__types']['context'],\n  TRouteContext extends RouteContext = RouteContext,\n  TContext extends MergeFromParent<\n    TParentRoute['__types']['context'],\n    TRouteContext\n  > = MergeFromParent<TParentRoute['__types']['context'], TRouteContext>,\n  TRouterContext extends AnyContext = AnyContext,\n  TChildren extends unknown = unknown,\n  TRoutesInfo extends DefaultRoutesInfo = DefaultRoutesInfo,\n> {\n  __types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    loader: TLoader\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    parentContext: TParentContext\n    allParentContext: TAllParentContext\n    routeContext: TRouteContext\n    context: TContext\n    children: TChildren\n    routesInfo: TRoutesInfo\n    routerContext: TRouterContext\n  }\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TLoader,\n    InferFullSearchSchema<TParentRoute>,\n    TSearchSchema,\n    InferFullSearchSchema<TParentRoute> & TSearchSchema,\n    TParentRoute['__types']['allParams'],\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TLoader,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n  }\n\n  init = (opts: { originalIndex: number; router: AnyRouter }) => {\n    this.originalIndex = opts.originalIndex\n    this.router = opts.router\n\n    const allOptions = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TLoader,\n      InferFullSearchSchema<TParentRoute>,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParentRoute['__types']['allParams'],\n      TParams,\n      TAllParams,\n      TParentContext,\n      TAllParentContext,\n      TRouteContext,\n      TContext\n    > &\n      RouteOptionsBaseIntersection<TCustomId, TPath>\n\n    const isRoot = !allOptions?.path && !allOptions?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : allOptions.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = allOptions?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TLoader,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TParentContext,\n    TAllParentContext,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TNewChildren,\n    TRoutesInfo\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  useMatch = <TStrict extends boolean = true, TSelected = TContext>(opts?: {\n    strict?: TStrict\n    track?: (search: TContext) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n\n  useLoader = <TStrict extends boolean = true, TSelected = TLoader>(opts?: {\n    strict?: TStrict\n    track?: (search: TLoader) => TSelected\n  }): TStrict extends true\n    ? UseLoaderResult<TSelected>\n    : UseLoaderResult<TSelected> | undefined => {\n    return useLoader({ ...opts, from: this.id }) as any\n  }\n\n  useContext = <TStrict extends boolean = true, TSelected = TContext>(opts?: {\n    strict?: TStrict\n    track?: (search: TContext) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useMatch({ ...opts, from: this.id }).context\n  }\n\n  useSearch = <\n    TStrict extends boolean = true,\n    TSelected = TFullSearchSchema,\n  >(opts?: {\n    strict?: TStrict\n    track?: (search: TFullSearchSchema) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useSearch({ ...opts, from: this.id })\n  }\n\n  useParams = <TStrict extends boolean = true, TSelected = TAllParams>(opts?: {\n    strict?: TStrict\n    track?: (search: TAllParams) => TSelected\n  }): TStrict extends true ? TSelected : TSelected | undefined => {\n    return useParams({ ...opts, from: this.id })\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any, any>\n\nexport class RootRoute<\n  TLoader = unknown,\n  TSearchSchema extends AnySearchSchema = {},\n  TContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n> extends Route<\n  any,\n  '/',\n  '/',\n  string,\n  RootRouteId,\n  TLoader,\n  TSearchSchema,\n  TSearchSchema,\n  {},\n  {},\n  TRouterContext,\n  TRouterContext,\n  MergeFromParent<TRouterContext, TContext>,\n  MergeFromParent<TRouterContext, TContext>,\n  TRouterContext,\n  any,\n  any\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute,\n        RootRouteId,\n        '',\n        TLoader,\n        {},\n        TSearchSchema,\n        NoInfer<TSearchSchema>,\n        {},\n        TRouterContext,\n        TRouterContext,\n        TContext,\n        NoInfer<TContext>\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n\n  static withRouterContext = <TRouterContext extends {}>() => {\n    return <\n      TLoader = unknown,\n      TSearchSchema extends AnySearchSchema = {},\n      TContext extends {} = {},\n    >(\n      options?: Omit<\n        RouteOptions<\n          AnyRoute,\n          RootRouteId,\n          '',\n          TLoader,\n          {},\n          TSearchSchema,\n          NoInfer<TSearchSchema>,\n          {},\n          TRouterContext,\n          TRouterContext,\n          TContext,\n          TRouterContext & TContext\n        >,\n        'path' | 'id' | 'getParentRoute' | 'caseSensitive'\n      >,\n    ) =>\n      new RootRoute<TLoader, TSearchSchema, TContext, TRouterContext>(\n        options as any,\n      )\n  }\n}\n\ntype ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed extends RoutePrefix<TParentRoute['fullPath'], TPath> = RoutePrefix<\n    TParentRoute['fullPath'],\n    TPath\n  >,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n  ? TPrefix extends RootRouteId\n    ? TPath extends '/'\n      ? '/'\n      : `/${TrimPath<TPath>}`\n    : `${TPrefix}/${TPath}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n  : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n    ? TrimPathLeft<U>\n    : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\n// const rootRoute = new RootRoute({\n//   validateSearch: () => null as unknown as { root?: boolean },\n// })\n\n// const aRoute = new Route({\n//   getParentRoute: () => rootRoute,\n//   path: 'a',\n//   validateSearch: () => null as unknown as { a?: string },\n// })\n\n// const bRoute = new Route({\n//   getParentRoute: () => aRoute,\n//   path: 'b',\n// })\n\n// const rootIsRoot = rootRoute.isRoot\n// //    ^?\n// const aIsRoot = aRoute.isRoot\n// //    ^?\n\n// const rId = rootRoute.id\n// //    ^?\n// const aId = aRoute.id\n// //    ^?\n// const bId = bRoute.id\n// //    ^?\n\n// const rPath = rootRoute.fullPath\n// //    ^?\n// const aPath = aRoute.fullPath\n// //    ^?\n// const bPath = bRoute.fullPath\n// //    ^?\n\n// const rSearch = rootRoute.__types.fullSearchSchema\n// //    ^?\n// const aSearch = aRoute.__types.fullSearchSchema\n// //    ^?\n// const bSearch = bRoute.__types.fullSearchSchema\n// //    ^?\n\n// const config = rootRoute.addChildren([aRoute.addChildren([bRoute])])\n// //    ^?\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(JSON.stringify)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(stringify: (search: any) => string) {\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else if (val && typeof val === 'object' && val !== null) {\n          try {\n            search[key] = stringify(val)\n          } catch (err) {\n            // silent\n          }\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n","import { Store } from '@tanstack/react-store'\nimport invariant from 'tiny-invariant'\n\n//\n\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ToOptions,\n  ResolveRelativePath,\n} from './link'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport {\n  Route,\n  AnySearchSchema,\n  AnyRoute,\n  RootRoute,\n  AnyContext,\n  AnyRootRoute,\n  AnyPathParams,\n} from './route'\nimport {\n  RoutesInfo,\n  AnyRoutesInfo,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport { AnyRouteMatch, RouteMatch, RouteMatchState } from './routeMatch'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport {\n  functionalUpdate,\n  last,\n  NoInfer,\n  pick,\n  PickAsRequired,\n  Timeout,\n  Updater,\n  replaceEqualDeep,\n  partialDeepEqual,\n} from './utils'\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  RouterHistory,\n} from './history'\nimport { RouteComponent } from './react'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? Router<TRoute, TRoutesInfo>\n  : Router\n\nexport type RegisteredRoutesInfo = Register extends {\n  router: Router<infer TRoute, infer TRoutesInfo>\n}\n  ? TRoutesInfo\n  : AnyRoutesInfo\n\nexport interface LocationState {}\n\nexport interface ParsedLocation<\n  TSearchObj extends AnySearchSchema = {},\n  TState extends LocationState = LocationState,\n> {\n  href: string\n  pathname: string\n  search: TSearchObj\n  searchStr: string\n  state: TState\n  hash: string\n  key?: string\n}\n\nexport interface FromLocation {\n  pathname: string\n  search?: unknown\n  key?: string\n  hash?: string\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\ntype RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['__types']['routerContext']\n    ? {\n        context?: TRouteTree['__types']['routerContext']\n      }\n    : {\n        context: TRouteTree['__types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent\n  defaultErrorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }>\n  defaultPendingComponent?: RouteComponent\n  defaultLoaderMaxAge?: number\n  defaultLoaderGcMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  onRouteChange?: () => void\n  fetchServerDataFn?: FetchServerDataFn\n  context?: TRouteTree['__types']['routerContext']\n  Wrap?: React.ComponentType<{ children: React.ReactNode }>\n  dehydrate?: () => TDehydrated\n  hydrate?: (dehydrated: TDehydrated) => void\n}\n\ntype FetchServerDataFn = (ctx: {\n  router: AnyRouter\n  routeMatch: RouteMatch\n}) => Promise<any>\n\nexport interface RouterState<\n  TRoutesInfo extends AnyRoutesInfo = AnyRoutesInfo,\n  TState extends LocationState = LocationState,\n> {\n  status: 'idle' | 'pending'\n  matches: RouteMatch<TRoutesInfo, TRoutesInfo['routeIntersection']>[]\n  location: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  resolvedLocation: ParsedLocation<TRoutesInfo['fullSearchSchema'], TState>\n  lastUpdated: number\n}\n\nexport type ListenerFn = () => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: LocationState\n  key?: string\n  from?: string\n  fromCurrent?: boolean\n  __matches?: RouteMatch[]\n}\n\nexport type MatchCacheEntry = {\n  gc: number\n  match: RouteMatch\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n  fromCurrent?: boolean\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport interface DehydratedRouterState\n  extends Pick<RouterState, 'status' | 'location' | 'lastUpdated'> {\n  // matches: DehydratedRouteMatch[]\n}\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type MatchCache = Record<string, MatchCacheEntry>\n\ninterface DehydratedRouteMatch {\n  id: string\n  promiseKeys: string[]\n  // state: Pick<RouteMatchState<any, any>, 'status'>\n}\n\nexport const defaultFetchServerDataFn: FetchServerDataFn = async ({\n  router,\n  routeMatch,\n}) => {\n  const next = router.buildNext({\n    to: '.',\n    search: (d: any) => ({\n      ...(d ?? {}),\n      __data: {\n        matchId: routeMatch.id,\n      },\n    }),\n  })\n\n  const res = await fetch(next.href, {\n    method: 'GET',\n    signal: routeMatch.abortController.signal,\n  })\n\n  if (res.ok) {\n    return res.json()\n  }\n\n  throw new Error('Failed to fetch match data')\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRoutesInfo extends AnyRoutesInfo = RoutesInfo<TRouteTree>,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  types!: {\n    // Super secret internal stuff\n    RootRoute: TRouteTree\n    RoutesInfo: TRoutesInfo\n  }\n\n  options: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  context!: NonNullable<TRouteTree['__types']['routerContext']>\n  history!: RouterHistory\n  #unsubHistory?: () => void\n  basepath!: string\n  // __location: Location<TRoutesInfo['fullSearchSchema']>\n  routeTree!: RootRoute\n  routesById!: RoutesById<TRoutesInfo>\n  routesByPath!: RoutesByPath<TRoutesInfo>\n  flatRoutes!: TRoutesInfo['routesByFullPath'][keyof TRoutesInfo['routesByFullPath']][]\n  navigateTimeout: undefined | Timeout\n  nextAction: undefined | 'push' | 'replace'\n  navigationPromise: undefined | Promise<void>\n\n  __store: Store<RouterState<TRoutesInfo>>\n  state: RouterState<TRoutesInfo>\n  startedLoadingAt = Date.now()\n  resolveNavigation: () => void = () => {}\n\n  constructor(options?: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n      fetchServerDataFn: options?.fetchServerDataFn ?? defaultFetchServerDataFn,\n    }\n\n    this.__store = new Store<RouterState<TRoutesInfo>>(\n      getInitialRouterState(),\n      {\n        onUpdate: () => {\n          this.state = this.__store.state\n        },\n      },\n    )\n    this.state = this.__store.state\n\n    this.update(options)\n\n    const next = this.buildNext({\n      hash: true,\n      fromCurrent: true,\n      search: true,\n      state: true,\n    })\n\n    if (this.state.location.href !== next.href) {\n      this.#commitLocation({ ...next, replace: true })\n    }\n  }\n\n  reset = () => {\n    this.__store.setState((s) => Object.assign(s, getInitialRouterState()))\n  }\n\n  mount = () => {\n    // Mount only does anything on the client\n    if (!isServer) {\n      // If the router matches are empty, start loading the matches\n      if (!this.state.matches.length) {\n        this.safeLoad()\n      }\n    }\n\n    return () => {}\n  }\n\n  update = (opts?: RouterOptions<any, any>): this => {\n    Object.assign(this.options, opts)\n\n    this.context = this.options.context\n\n    if (\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      if (this.#unsubHistory) {\n        this.#unsubHistory()\n      }\n\n      this.history =\n        this.options.history ??\n        (isServer ? createMemoryHistory() : createBrowserHistory()!)\n\n      const parsedLocation = this.#parseLocation()\n\n      this.__store.setState((s) => ({\n        ...s,\n        resolvedLocation: parsedLocation,\n        location: parsedLocation,\n      }))\n\n      this.#unsubHistory = this.history.listen(() => {\n        this.safeLoad({\n          next: this.#parseLocation(this.state.location),\n        })\n      })\n    }\n\n    const { basepath, routeTree } = this.options\n\n    this.basepath = `/${trimPath(basepath ?? '') ?? ''}`\n\n    if (routeTree && routeTree !== this.routeTree) {\n      this.#buildRouteTree(routeTree)\n    }\n\n    return this\n  }\n\n  buildNext = (opts: BuildNextOptions): ParsedLocation => {\n    const next = this.#buildLocation(opts)\n\n    const __matches = this.matchRoutes(next.pathname, next.search)\n\n    return this.#buildLocation({\n      ...opts,\n      __matches,\n    })\n  }\n\n  cancelMatches = () => {\n    ;[...this.state.matches].forEach((match) => {\n      match.cancel()\n    })\n  }\n\n  safeLoad = (opts?: { next?: ParsedLocation }) => {\n    this.load(opts).catch((err) => {\n      console.warn(err)\n      invariant(false, 'Encountered an error during router.load()! â˜ï¸.')\n    })\n  }\n\n  load = async (opts?: { next?: ParsedLocation }): Promise<void> => {\n    this.#createNavigationPromise()\n\n    let now = Date.now()\n    const startedAt = now\n    this.startedLoadingAt = startedAt\n\n    // Cancel any pending matches\n    this.cancelMatches()\n\n    let matches!: RouteMatch<any, any>[]\n\n    this.__store.batch(() => {\n      if (opts?.next) {\n        // Ingest the new location\n        this.__store.setState((s) => ({\n          ...s,\n          location: opts.next!,\n        }))\n      }\n\n      // Match the routes\n      matches = this.matchRoutes(\n        this.state.location.pathname,\n        this.state.location.search,\n        {\n          strictParseParams: true,\n          debug: true,\n        },\n      )\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'pending',\n        matches,\n      }))\n    })\n\n    matches.forEach((match) => {\n      match.__commit()\n    })\n\n    // Load the matches\n    await this.loadMatches(matches, this.state.location)\n\n    if (this.startedLoadingAt !== startedAt) {\n      // Ignore side-effects of outdated side-effects\n      return this.navigationPromise\n    }\n\n    const previousMatches = this.state.matches\n\n    const exiting: AnyRouteMatch[] = [],\n      staying: AnyRouteMatch[] = []\n\n    previousMatches.forEach((d) => {\n      if (matches.find((dd) => dd.id === d.id)) {\n        staying.push(d)\n      } else {\n        exiting.push(d)\n      }\n    })\n\n    const entering = matches.filter((d) => {\n      return !previousMatches.find((dd) => dd.id === d.id)\n    })\n\n    now = Date.now()\n\n    exiting.forEach((d) => {\n      d.__onExit?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n\n      // Clear non-loading error states when match leaves\n      if (d.state.status === 'error') {\n        this.__store.setState((s) => ({\n          ...s,\n          status: 'idle',\n          error: undefined,\n        }))\n      }\n    })\n\n    staying.forEach((d) => {\n      d.route.options.onTransition?.({\n        params: d.params,\n        search: d.state.routeSearch,\n      })\n    })\n\n    entering.forEach((d) => {\n      d.__onExit = d.route.options.onLoaded?.({\n        params: d.params,\n        search: d.state.search,\n      })\n    })\n\n    const prevLocation = this.state.location\n\n    this.__store.setState((s) => ({\n      ...s,\n      status: 'idle',\n      resolvedLocation: s.location,\n      matches,\n    }))\n\n    if (prevLocation!.href !== this.state.location.href) {\n      this.options.onRouteChange?.()\n    }\n\n    this.resolveNavigation()\n  }\n\n  getRoute = <TId extends keyof TRoutesInfo['routesById']>(\n    id: TId,\n  ): TRoutesInfo['routesById'][TId] => {\n    const route = this.routesById[id]\n\n    invariant(route, `Route with id \"${id as string}\" not found`)\n\n    return route\n  }\n\n  loadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.location,\n  ): Promise<RouteMatch[]> => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, next.search, {\n      strictParseParams: true,\n    })\n    await this.loadMatches(matches, next)\n    return matches\n  }\n\n  preloadRoute = async (\n    navigateOpts: BuildNextOptions = this.state.location,\n  ) => {\n    const next = this.buildNext(navigateOpts)\n    const matches = this.matchRoutes(next.pathname, next.search, {\n      strictParseParams: true,\n    })\n\n    await this.loadMatches(matches, next, {\n      preload: true,\n    })\n    return matches\n  }\n\n  matchRoutes = (\n    pathname: string,\n    search: AnySearchSchema,\n    opts?: { strictParseParams?: boolean; debug?: boolean },\n  ): RouteMatch[] => {\n    // If there's no route tree, we can't match anything\n    if (!this.flatRoutes.length) {\n      return []\n    }\n\n    let routeParams: AnyPathParams = {}\n\n    let foundRoute = this.flatRoutes.find((route) => {\n      const matchedParams = matchPathname(this.basepath, pathname, {\n        to: route.fullPath,\n        caseSensitive:\n          route.options.caseSensitive ?? this.options.caseSensitive,\n      })\n\n      if (matchedParams) {\n        routeParams = matchedParams\n        return true\n      }\n\n      return false\n    })\n\n    if (!foundRoute) {\n      return []\n    }\n\n    let matchedRoutes: AnyRoute[] = [foundRoute]\n\n    while (foundRoute?.parentRoute) {\n      foundRoute = foundRoute.parentRoute\n      if (foundRoute) matchedRoutes.unshift(foundRoute)\n    }\n\n    // Alright, by now we should have all of our\n    // matching routes and their param pairs, let's\n    // Turn them into actual `Match` objects and\n    // accumulate the params into a single params bag\n    let allParams = {}\n\n    // Existing matches are matches that are already loaded along with\n    // pending matches that are still loading\n    const existingMatches = [...this.state.matches] as AnyRouteMatch[]\n\n    const matches = matchedRoutes\n      .map((route) => {\n        let parsedParams\n        try {\n          parsedParams =\n            route.options.parseParams?.(routeParams!) ?? routeParams\n        } catch (err) {\n          if (opts?.strictParseParams) {\n            throw err\n          }\n        }\n\n        // Add the parsed params to the accumulated params bag\n        Object.assign(allParams, parsedParams)\n\n        const interpolatedPath = interpolatePath(route.path, allParams)\n        const matchId =\n          interpolatePath(route.id, allParams, true) +\n          (route.options.getKey?.({\n            params: allParams,\n            search,\n          }) ?? '')\n\n        // Waste not, want not. If we already have a match for this route,\n        // reuse it. This is important for layout routes, which might stick\n        // around between navigation actions that only change leaf routes.\n        const existingMatch = existingMatches.find((d) => d.id === matchId)\n\n        if (existingMatch) {\n          return existingMatch\n        }\n\n        return new RouteMatch(this, route, {\n          id: matchId,\n          params: allParams,\n          pathname: joinPaths([this.basepath, interpolatedPath]),\n        }) as AnyRouteMatch\n      })\n      .filter((d, i, all) => {\n        // Filter out any duplicate matches\n        // I honesty don't know why this is necessary, but it is and it's safe for now\n        // Someday someone will figure out why my logic is wrong and fix it to just\n        // not create duplicate matches in the first place\n        return all.findIndex((dd) => dd.id === d.id) === i\n      })\n\n    return matches\n  }\n\n  loadMatches = async (\n    resolvedMatches: RouteMatch[],\n    location: ParsedLocation,\n    opts?: {\n      preload?: boolean\n      // filter?: (match: RouteMatch<any, any>) => any\n    },\n  ) => {\n    let firstBadMatchIndex: number | undefined\n\n    // Check each match middleware to see if the route can be accessed\n    try {\n      await Promise.all(\n        resolvedMatches.map(async (match, index) => {\n          try {\n            await match.route.options.beforeLoad?.({\n              router: this as any,\n              match,\n            })\n          } catch (err) {\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            const errorHandler =\n              match.route.options.onBeforeLoadError ??\n              match.route.options.onError\n            try {\n              errorHandler?.(err)\n            } catch (errorHandlerErr) {\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n\n              match.__store.setState((s) => ({\n                ...s,\n                error: errorHandlerErr,\n                status: 'error',\n                updatedAt: Date.now(),\n              }))\n              return\n            }\n\n            match.__store.setState((s) => ({\n              ...s,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }))\n          }\n        }),\n      )\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.navigate(err as any)\n        }\n        return\n      }\n\n      throw err // we should never end up here\n    }\n\n    const validResolvedMatches = resolvedMatches.slice(0, firstBadMatchIndex)\n    const matchPromises = validResolvedMatches.map(async (match, index) => {\n      const parentMatch = validResolvedMatches[index - 1]\n\n      match.__load({ preload: opts?.preload, location, parentMatch })\n\n      await match.__loadPromise\n\n      if (parentMatch) {\n        await parentMatch.__loadPromise\n      }\n    })\n\n    await Promise.all(matchPromises)\n  }\n\n  reload = () => {\n    this.navigate({\n      fromCurrent: true,\n      replace: true,\n      search: true,\n    } as any)\n  }\n\n  resolvePath = (from: string, path: string) => {\n    return resolvePath(this.basepath!, from, cleanPath(path))\n  }\n\n  navigate = async <TFrom extends string = '/', TTo extends string = ''>({\n    from,\n    to = '' as any,\n    search,\n    hash,\n    replace,\n    params,\n  }: NavigateOptions<TRoutesInfo, TFrom, TTo>) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n    const toString = String(to)\n    const fromString = typeof from === 'undefined' ? from : String(from)\n    let isExternal\n\n    try {\n      new URL(`${toString}`)\n      isExternal = true\n    } catch (e) {}\n\n    invariant(\n      !isExternal,\n      'Attempting to navigate to external url with this.navigate!',\n    )\n\n    return this.#commitLocation({\n      from: fromString,\n      to: toString,\n      search,\n      hash,\n      replace,\n      params,\n    })\n  }\n\n  matchRoute = <\n    TFrom extends string = '/',\n    TTo extends string = '',\n    TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  >(\n    location: ToOptions<TRoutesInfo, TFrom, TTo>,\n    opts?: MatchRouteOptions,\n  ): false | TRoutesInfo['routesById'][TResolved]['__types']['allParams'] => {\n    location = {\n      ...location,\n      to: location.to\n        ? this.resolvePath(location.from ?? '', location.to)\n        : undefined,\n    } as any\n\n    const next = this.buildNext(location)\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const baseLocation = opts?.pending\n      ? this.state.location\n      : this.state.resolvedLocation\n\n    if (!baseLocation) {\n      return false\n    }\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n\n    if (opts?.includeSearch ?? true) {\n      return partialDeepEqual(baseLocation.search, next.search) ? match : false\n    }\n\n    return match\n  }\n\n  buildLink = <TFrom extends string = '/', TTo extends string = ''>({\n    from,\n    to = '.' as any,\n    search,\n    params,\n    hash,\n    target,\n    replace,\n    activeOptions,\n    preload,\n    preloadDelay: userPreloadDelay,\n    disabled,\n  }: LinkOptions<TRoutesInfo, TFrom, TTo>): LinkInfo => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to,\n      }\n    } catch (e) {}\n\n    const nextOpts = {\n      from,\n      to,\n      search,\n      params,\n      hash,\n      replace,\n    }\n\n    const next = this.buildNext(nextOpts)\n\n    preload = preload ?? this.options.defaultPreload\n    const preloadDelay =\n      userPreloadDelay ?? this.options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = this.state.location.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? this.state.location.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? this.state.location.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(this.state.location.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        this.#commitLocation(nextOpts as any)\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        this.preloadRoute(nextOpts).catch((err) => {\n          console.warn(err)\n          console.warn('Error preloading route! â˜ï¸')\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      this.preloadRoute(nextOpts).catch((err) => {\n        console.warn(err)\n        console.warn('Error preloading route! â˜ï¸')\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          this.preloadRoute(nextOpts).catch((err) => {\n            console.warn(err)\n            console.warn('Error preloading route! â˜ï¸')\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  }\n\n  dehydrate = (): DehydratedRouter => {\n    return {\n      state: {\n        ...pick(this.state, ['location', 'status', 'lastUpdated']),\n        // matches: this.state.matches.map((m) => ({\n        //   id: m.id,\n        //   promiseKeys: Object.keys(m.__promisesByKey),\n        // })),\n      },\n    }\n  }\n\n  hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n    let _ctx = __do_not_use_server_ctx\n    // Client hydrates from window\n    if (typeof document !== 'undefined') {\n      _ctx = window.__TSR_DEHYDRATED__\n    }\n\n    invariant(\n      _ctx,\n      'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n    )\n\n    const ctx = _ctx\n\n    this.options.hydrate?.(ctx.payload as any)\n\n    this.__store.setState((s) => {\n      return {\n        ...s,\n        ...ctx.router.state,\n        matches: s.matches,\n        resolvedLocation: ctx.router.state.location,\n      }\n    })\n\n    await this.load()\n\n    // this.state.matches.forEach((m) => {\n    //   m.__promiseKeys =\n    //     ctx.router.state.matches.find((d) => d.id === m.id)?.promiseKeys ?? []\n    // })\n\n    return\n  }\n\n  injectedHtml: (string | (() => Promise<string> | string))[] = []\n\n  injectHtml = async (html: string | (() => Promise<string> | string)) => {\n    this.injectedHtml.push(html)\n  }\n\n  dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n    if (typeof document === 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      this.injectHtml(async () => {\n        const data =\n          typeof getData === 'function' ? await (getData as any)() : getData\n        return `<script>window[\"__TSR__DEHYRATED__${escapeJSON(\n          strKey,\n        )}\"] = ${JSON.stringify(data)}</script>`\n      })\n\n      return () => this.hydrateData<T>(key)\n    }\n\n    return () => undefined\n  }\n\n  hydrateData = <T = unknown>(key: any) => {\n    if (typeof document !== 'undefined') {\n      const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n      return window[`__TSR__DEHYRATED__${strKey}` as any] as T\n    }\n\n    return undefined\n  }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   this.state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n\n  #buildRouteTree = (routeTree: TRouteTree) => {\n    this.routeTree = routeTree as any\n    this.routesById = {} as any\n    this.routesByPath = {} as any\n    this.flatRoutes = [] as any\n\n    const recurseRoutes = (routes: AnyRoute[]) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i, router: this })\n\n        const existingRoute = (this.routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(this.routesById as any)[route.id] = route\n\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath)\n          if (\n            !this.routesByPath[trimmedFullPath] ||\n            route.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = route\n          }\n        }\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([routeTree])\n\n    this.flatRoutes = (Object.values(this.routesByPath) as AnyRoute[])\n      .map((d, i) => {\n        const trimmed = trimPath(d.fullPath)\n        const parsed = parsePathname(trimmed)\n\n        while (parsed.length > 1 && parsed[0]?.value === '/') {\n          parsed.shift()\n        }\n\n        const score = parsed.map((d) => {\n          if (d.type === 'param') {\n            return 0.5\n          }\n\n          if (d.type === 'wildcard') {\n            return 0.25\n          }\n\n          return 1\n        })\n\n        return { child: d, trimmed, parsed, index: i, score }\n      })\n      .sort((a, b) => {\n        let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0\n\n        if (isIndex !== 0) return isIndex\n\n        const length = Math.min(a.score.length, b.score.length)\n\n        // Sort by length of score\n        if (a.score.length !== b.score.length) {\n          return b.score.length - a.score.length\n        }\n\n        // Sort by min available score\n        for (let i = 0; i < length; i++) {\n          if (a.score[i] !== b.score[i]) {\n            return b.score[i]! - a.score[i]!\n          }\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < length; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n          }\n        }\n\n        // Sort by length of trimmed full path\n        if (a.trimmed !== b.trimmed) {\n          return a.trimmed > b.trimmed ? 1 : -1\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      }) as any\n  }\n\n  #parseLocation = (previousLocation?: ParsedLocation): ParsedLocation => {\n    let { pathname, search, hash, state } = this.history.location\n\n    const parsedSearch = this.options.parseSearch(search)\n\n    return {\n      pathname: pathname,\n      searchStr: search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: hash.split('#').reverse()[0] ?? '',\n      href: `${pathname}${search}${hash}`,\n      state: state as LocationState,\n      key: state?.key || '__init__',\n    }\n  }\n\n  #buildLocation = (dest: BuildNextOptions = {}): ParsedLocation => {\n    dest.fromCurrent = dest.fromCurrent ?? dest.to === ''\n\n    const fromPathname = dest.fromCurrent\n      ? this.state.location.pathname\n      : dest.from ?? this.state.location.pathname\n\n    let pathname = resolvePath(\n      this.basepath ?? '/',\n      fromPathname,\n      `${dest.to ?? ''}`,\n    )\n\n    const fromMatches = this.matchRoutes(\n      this.state.location.pathname,\n      this.state.location.search,\n      {\n        strictParseParams: true,\n      },\n    )\n\n    const prevParams = { ...last(fromMatches)?.params }\n\n    let nextParams =\n      (dest.params ?? true) === true\n        ? prevParams\n        : functionalUpdate(dest.params!, prevParams)\n\n    if (nextParams) {\n      dest.__matches\n        ?.map((d) => d.route.options.stringifyParams)\n        .filter(Boolean)\n        .forEach((fn) => {\n          nextParams = { ...nextParams!, ...fn!(nextParams!) }\n        })\n    }\n\n    pathname = interpolatePath(pathname, nextParams ?? {})\n\n    const preSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.preSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    const postSearchFilters =\n      dest.__matches\n        ?.map((match) => match.route.options.postSearchFilters ?? [])\n        .flat()\n        .filter(Boolean) ?? []\n\n    // Pre filters first\n    const preFilteredSearch = preSearchFilters?.length\n      ? preSearchFilters?.reduce(\n          (prev, next) => next(prev),\n          this.state.location.search,\n        )\n      : this.state.location.search\n\n    // Then the link/navigate function\n    const destSearch =\n      dest.search === true\n        ? preFilteredSearch // Preserve resolvedFrom true\n        : dest.search\n        ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n        : preSearchFilters?.length\n        ? preFilteredSearch // Preserve resolvedFrom filters\n        : {}\n\n    // Then post filters\n    const postFilteredSearch = postSearchFilters?.length\n      ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n      : destSearch\n\n    const search = replaceEqualDeep(\n      this.state.location.search,\n      postFilteredSearch,\n    )\n\n    const searchStr = this.options.stringifySearch(search)\n\n    const hash =\n      dest.hash === true\n        ? this.state.location.hash\n        : functionalUpdate(dest.hash!, this.state.location.hash)\n\n    const hashStr = hash ? `#${hash}` : ''\n\n    const nextState =\n      dest.state === true\n        ? this.state.location.state\n        : functionalUpdate(dest.state, this.state.location.state)!\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      state: nextState,\n      hash,\n      href: this.history.createHref(`${pathname}${searchStr}${hashStr}`),\n      key: dest.key,\n    }\n  }\n\n  #commitLocation = async (\n    location: BuildNextOptions & { replace?: boolean },\n  ) => {\n    const next = this.buildNext(location)\n    const id = '' + Date.now() + Math.random()\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!location.replace) {\n      nextAction = 'push'\n    }\n\n    const isSameUrl = this.state.location.href === next.href\n\n    if (isSameUrl && !next.key) {\n      nextAction = 'replace'\n    }\n\n    const href = `${next.pathname}${next.searchStr}${\n      next.hash ? `#${next.hash}` : ''\n    }`\n\n    this.history[nextAction === 'push' ? 'push' : 'replace'](href, {\n      id,\n      ...next.state,\n    })\n\n    return this.#createNavigationPromise()\n  }\n\n  #createNavigationPromise = () => {\n    const previousNavigationResolve = this.resolveNavigation\n\n    this.navigationPromise = new Promise((resolve) => {\n      this.resolveNavigation = () => {\n        resolve()\n        previousNavigationResolve()\n      }\n    })\n\n    return this.navigationPromise\n  }\n}\n\n// Detect if we're in the DOM\nconst isServer = typeof window === 'undefined' || !window.document.createElement\n\nfunction getInitialRouterState(): RouterState<any, any> {\n  return {\n    status: 'idle',\n    resolvedLocation: null!,\n    location: null!,\n    matches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport type AnyRedirect = Redirect<any, any, any>\n\nexport type Redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n> = NavigateOptions<TRoutesInfo, TFrom, TTo> & {\n  code?: number\n}\n\nexport function redirect<\n  TRoutesInfo extends AnyRoutesInfo = RegisteredRoutesInfo,\n  TFrom extends TRoutesInfo['routePaths'] = '/',\n  TTo extends string = '',\n>(opts: Redirect<TRoutesInfo, TFrom, TTo>): Redirect<TRoutesInfo, TFrom, TTo> {\n  ;(opts as any).isRedirect = true\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n\nfunction escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n","import { Store } from '@tanstack/react-store'\n//\nimport { RouteComponent } from './react'\nimport { AnyRoute, Route, StreamedPromise } from './route'\nimport { AnyRoutesInfo, DefaultRoutesInfo } from './routeInfo'\nimport { AnyRouter, isRedirect, ParsedLocation, Router } from './router'\nimport { replaceEqualDeep } from './utils'\n\nexport interface RouteMatchState<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = Route,\n> {\n  routeSearch: TRoute['__types']['searchSchema']\n  search: TRoutesInfo['fullSearchSchema'] &\n    TRoute['__types']['fullSearchSchema']\n  status: 'pending' | 'success' | 'error'\n  error?: unknown\n  updatedAt: number\n  loader: TRoute['__types']['loader']\n}\n\nconst componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport interface PendingRouteMatchInfo {\n  state: RouteMatchState<any, any>\n  routeContext: {}\n  context: {}\n}\n\nexport interface AnyRouteMatch extends RouteMatch<any, any> {}\n\nexport class RouteMatch<\n  TRoutesInfo extends AnyRoutesInfo = DefaultRoutesInfo,\n  TRoute extends AnyRoute = AnyRoute,\n> {\n  route!: TRoute\n  router!: Router<TRoutesInfo['routeTree'], TRoutesInfo>\n  __store!: Store<RouteMatchState<TRoutesInfo, TRoute>>\n  state!: RouteMatchState<TRoutesInfo, TRoute>\n  id!: string\n  pathname!: string\n  params!: TRoute['__types']['allParams']\n\n  routeContext?: TRoute['__types']['routeContext']\n  context!: TRoute['__types']['context']\n\n  component?: RouteComponent<{\n    useLoader: TRoute['useLoader']\n    useMatch: TRoute['useMatch']\n    useContext: TRoute['useContext']\n    useSearch: TRoute['useSearch']\n    useParams: TRoute['useParams']\n  }>\n  errorComponent?: RouteComponent<{\n    error: Error\n    info: { componentStack: string }\n  }>\n  pendingComponent?: RouteComponent\n  abortController = new AbortController()\n  parentMatch?: RouteMatch\n  pendingInfo?: PendingRouteMatchInfo\n\n  // __promiseKeys: string[] = []\n  // __promisesByKey: Record<string, StreamedPromise<any>> = {}\n  __loadPromise?: Promise<void>\n  __loadPromiseResolve?: () => void\n  __onExit?:\n    | void\n    | ((matchContext: {\n        params: TRoute['__types']['allParams']\n        search: TRoute['__types']['fullSearchSchema']\n      }) => void)\n\n  constructor(\n    router: AnyRouter,\n    route: TRoute,\n    opts: {\n      id: string\n      params: TRoute['__types']['allParams']\n      pathname: string\n    },\n  ) {\n    Object.assign(this, {\n      route,\n      router,\n      id: opts.id,\n      pathname: opts.pathname,\n      params: opts.params,\n      __store: new Store<RouteMatchState<TRoutesInfo, TRoute>>(\n        {\n          updatedAt: 0,\n          routeSearch: {},\n          search: {} as any,\n          status: 'pending',\n          loader: undefined,\n        },\n        {\n          onUpdate: () => {\n            this.state = this.__store.state\n          },\n        },\n      ),\n    })\n\n    this.state = this.__store.state\n\n    componentTypes.map(async (type) => {\n      const component = this.route.options[type]\n\n      this[type] = component as any\n    })\n\n    this.__loadPromise = new Promise((r) => {\n      this.__loadPromiseResolve = r\n    })\n\n    if (this.state.status === 'pending' && !this.#hasLoaders()) {\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'success',\n      }))\n      this.__loadPromiseResolve?.()\n    }\n  }\n\n  #hasLoaders = () => {\n    return !!(\n      this.route.options.loader ||\n      componentTypes.some((d) => this.route.options[d]?.preload)\n    )\n  }\n\n  __commit = () => {\n    const { routeSearch, search, context, routeContext } = this.#resolveInfo({\n      location: this.router.state.location,\n    })\n    this.context = context\n    this.routeContext = routeContext\n    this.__store.setState((s) => ({\n      ...s,\n      routeSearch: replaceEqualDeep(s.routeSearch, routeSearch),\n      search: replaceEqualDeep(s.search, search),\n    }))\n  }\n\n  cancel = () => {\n    this.abortController?.abort()\n  }\n\n  #resolveSearchInfo = (opts: {\n    location: ParsedLocation\n  }): { routeSearch: {}; search: {} } => {\n    // Validate the search params and stabilize them\n    const parentSearchInfo = this.parentMatch\n      ? this.parentMatch.#resolveSearchInfo(opts)\n      : { search: opts.location.search, routeSearch: opts.location.search }\n\n    try {\n      const validator =\n        typeof this.route.options.validateSearch === 'object'\n          ? this.route.options.validateSearch.parse\n          : this.route.options.validateSearch\n\n      const routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n      const search = {\n        ...parentSearchInfo.search,\n        ...routeSearch,\n      }\n\n      return {\n        routeSearch,\n        search,\n      }\n    } catch (err: any) {\n      if (isRedirect(err)) {\n        throw err\n      }\n\n      const errorHandler =\n        this.route.options.onValidateSearchError ?? this.route.options.onError\n      errorHandler?.(err)\n      const error = new (Error as any)('Invalid search params found', {\n        cause: err,\n      })\n      error.code = 'INVALID_SEARCH_PARAMS'\n\n      throw error\n    }\n  }\n\n  #resolveInfo = (opts: { location: ParsedLocation }) => {\n    const { search, routeSearch } = this.#resolveSearchInfo(opts)\n\n    try {\n      const routeContext =\n        this.route.options.getContext?.({\n          parentContext: this.parentMatch?.routeContext ?? {},\n          context:\n            this.parentMatch?.context ?? this.router?.options.context ?? {},\n          params: this.params,\n          search,\n        }) || ({} as any)\n\n      const context = {\n        ...(this.parentMatch?.context ?? this.router?.options.context),\n        ...routeContext,\n      } as any\n\n      return {\n        routeSearch,\n        search,\n        context,\n        routeContext,\n      }\n    } catch (err) {\n      this.route.options.onError?.(err)\n      throw err\n    }\n  }\n\n  __load = async (opts: {\n    parentMatch: RouteMatch | undefined\n    preload?: boolean\n    location: ParsedLocation\n  }): Promise<void> => {\n    this.parentMatch = opts.parentMatch\n\n    let info\n\n    try {\n      info = this.#resolveInfo(opts)\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (!opts?.preload) {\n          this.router.navigate(err as any)\n        }\n        return\n      }\n\n      this.__store.setState((s) => ({\n        ...s,\n        status: 'error',\n        error: err,\n      }))\n\n      // Do not proceed with loading the route\n      return\n    }\n\n    const { routeSearch, search, context, routeContext } = info\n\n    const loaderOpts = {\n      params: this.params,\n      routeSearch,\n      search,\n      signal: this.abortController.signal,\n      preload: !!opts?.preload,\n      routeContext,\n      context,\n    }\n\n    this.__loadPromise = Promise.resolve().then(async () => {\n      const loadId = '' + Date.now() + Math.random()\n      this.#latestId = loadId\n\n      const checkLatest = () => {\n        return loadId !== this.#latestId ? this.__loadPromise : undefined\n      }\n\n      let latestPromise\n\n      const componentsPromise = (async () => {\n        // then run all component and data loaders in parallel\n        // For each component type, potentially load it asynchronously\n\n        await Promise.all(\n          componentTypes.map(async (type) => {\n            const component = this.route.options[type]\n\n            if (component?.preload) {\n              await component.preload()\n            }\n          }),\n        )\n      })()\n\n      const loaderPromise = Promise.resolve().then(() => {\n        if (this.route.options.loader) {\n          return this.route.options.loader(loaderOpts)\n        }\n        return\n      })\n\n      try {\n        const [_, loader] = await Promise.all([\n          componentsPromise,\n          loaderPromise,\n        ])\n        if ((latestPromise = checkLatest())) return await latestPromise\n\n        // Object.keys(loader ?? {}).forEach((key) => {\n        //   const value = loader[key]\n        //   if (value instanceof Promise || value?.then) {\n        //     // if (this.__promisesByKey[key]) {\n        //     //   return\n        //     // }\n\n        //     if (typeof document === 'undefined') {\n        //       this.__promisesByKey[key] = {\n        //         status: 'pending',\n        //         promise: value,\n        //         data: undefined,\n        //         resolve: () => {},\n        //       }\n\n        //       value.then((d: any) => {\n        //         this.__promisesByKey[key]!.status = 'resolved'\n        //         this.__promisesByKey[key]!.data = d\n        //       })\n        //     } else {\n        //       const promise = createPromise()\n        //       this.__promisesByKey[key] = {\n        //         status: 'pending',\n        //         promise,\n        //         data: undefined,\n        //         resolve: (d: any) => {\n        //           // @ts-ignore\n        //           promise.resolve()\n        //           this.__promisesByKey[key]!.status = 'resolved'\n        //           this.__promisesByKey[key]!.data = d\n        //         },\n        //       }\n\n        //       if (!this.__promiseKeys.includes(key)) {\n        //         value.then(this.__promisesByKey[key]!.resolve)\n        //       }\n        //     }\n\n        //     loader[key] = this.__promisesByKey[key]\n        //   }\n        // })\n\n        if (!opts.preload) {\n          this.__store.setState((s) => ({\n            ...s,\n            error: undefined,\n            status: 'success',\n            updatedAt: Date.now(),\n            loader,\n          }))\n        }\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!opts?.preload) {\n            this.router.navigate(err as any)\n          }\n          return\n        }\n\n        const errorHandler =\n          this.route.options.onLoadError ?? this.route.options.onError\n        try {\n          errorHandler?.(err)\n        } catch (errorHandlerErr) {\n          if (isRedirect(errorHandlerErr)) {\n            if (!opts?.preload) {\n              this.router.navigate(errorHandlerErr as any)\n            }\n            return\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            error: errorHandlerErr,\n            status: 'error',\n            updatedAt: Date.now(),\n          }))\n          return\n        }\n\n        this.__store.setState((s) => ({\n          ...s,\n          error: err,\n          status: 'error',\n          updatedAt: Date.now(),\n        }))\n      } finally {\n        this.__loadPromiseResolve?.()\n        delete this.__loadPromise\n      }\n    })\n\n    return this.__loadPromise\n  }\n\n  #latestId = ''\n}\n\ntype ResolvablePromise<T> = Promise<T> & { resolve: (data: T) => void }\n\nfunction createPromise<T>() {\n  let resolve: any\n\n  const promise = new Promise((r) => {\n    resolve = r\n  }) as ResolvablePromise<T>\n\n  promise.resolve = (d: any) => {\n    resolve(d)\n  }\n\n  return promise\n}\n"],"names":["invariant","condition","message","Error","warning","popStateEvent","beforeUnloadEvent","beforeUnloadListener","event","preventDefault","returnValue","stopBlocking","removeEventListener","capture","createHistory","opts","location","getLocation","unsub","listeners","Set","blockers","queue","tryFlush","length","shift","onUpdate","queueTask","task","push","forEach","listener","listen","cb","size","add","delete","path","state","pushState","replace","replaceState","go","index","back","forward","createHref","str","block","addEventListener","filter","b","createBrowserHistory","getHref","window","pathname","search","hash","parseLocation","history","key","createRandomKey","n","createMemoryHistory","initialEntries","entries","initialIndex","currentState","Math","min","href","hashIndex","indexOf","searchIndex","substring","slice","undefined","random","toString","last","arr","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","replaceEqualDeep","prev","_next","next","array","Array","isArray","isPlainObject","prevSize","Object","nextItems","nextSize","copy","equalItems","i","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","call","partialDeepEqual","a","some","every","item","joinPaths","paths","cleanPath","Boolean","join","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","toSegment","value","pop","map","d","segments","type","split","part","charAt","interpolatePath","params","leaveWildcards","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","routeSegments","startsWith","unshift","max","baseSegment","routeSegment","isLastBaseSegment","isLastRouteSegment","caseSensitive","toLowerCase","fuzzy","encode","pfx","k","tmp","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","concat","Store","_batching","_flushing","initialState","options","this","subscribe","onSubscribe","setState","updateFn","_flush","flushId","batch","useStore","store","selector","useSyncExternalStoreWithSelector","shallow","objA","objB","is","keysA","useLinkProps","router","useRouterContext","children","target","activeProps","className","inactiveProps","activeOptions","disabled","preload","preloadDelay","style","onClick","onFocus","onMouseEnter","onMouseLeave","onTouchStart","rest","linkInfo","buildLink","handleClick","handleFocus","handleEnter","handleLeave","handleTouchStart","isActive","composeHandlers","handlers","e","persist","handler","defaultPrevented","resolvedActiveProps","resolvedInactiveProps","React","startTransition","role","Link","forwardRef","props","ref","linkProps","createElement","_extends","matchesContext","createContext","routerContext","useContext","__store","useRouter","track","useMatches","useMatch","nearestMatch","matches","match","find","route","id","strict","useLoader","matchOpts","loader","useSearch","useParams","useMatchRoute","useCallback","pending","matchRoute","Outlet","SubOutlet","status","error","defaultPending","PendingComponent","pendingComponent","defaultPendingComponent","errorComponent","defaultErrorComponent","ResolvedSuspenseBoundary","wrapInSuspense","isRoot","Suspense","SafeFragment","ResolvedCatchBoundary","CatchBoundary","Provider","fallback","onCatch","Inner","__loadPromise","comp","component","defaultComponent","Component","info","componentDidCatch","console","render","CatchBoundaryInner","errorState","reset","activeErrorState","setActiveErrorState","useState","ErrorComponent","prevKeyRef","useRef","useEffect","current","padding","maxWidth","fontSize","height","border","borderRadius","color","overflow","useBlocker","unblock","retry","cancel","confirm","rootRouteId","Route","getParentRoute","init","originalIndex","allOptions","parentRoute","customId","fullPath","addChildren","context","RootRoute","super","static","defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","err","val","defaultFetchServerDataFn","async","routeMatch","buildNext","__data","matchId","res","fetch","method","signal","abortController","ok","json","isServer","document","getInitialRouterState","resolvedLocation","lastUpdated","Date","now","isRedirect","componentTypes","RouteMatch","AbortController","assign","updatedAt","routeSearch","Promise","r","__loadPromiseResolve","hasLoaders","s","__commit","routeContext","resolveInfo","abort","resolveSearchInfo","parentSearchInfo","parentMatch","validateSearch","onValidateSearchError","onError","cause","code","getContext","parentContext","__load","navigate","loaderOpts","resolve","then","loadId","latestId","checkLatest","latestPromise","componentsPromise","all","loaderPromise","_","errorHandler","onLoadError","errorHandlerErr","useLayoutEffect","unsubHistory","startedLoadingAt","resolveNavigation","defaultPreloadDelay","stringifySearch","parseSearch","fetchServerDataFn","update","fromCurrent","commitLocation","mount","safeLoad","parsedLocation","routeTree","buildRouteTree","buildLocation","__matches","matchRoutes","cancelMatches","load","catch","warn","createNavigationPromise","startedAt","strictParseParams","debug","loadMatches","navigationPromise","previousMatches","exiting","staying","dd","entering","__onExit","onTransition","onLoaded","prevLocation","onRouteChange","getRoute","routesById","loadRoute","navigateOpts","preloadRoute","flatRoutes","routeParams","foundRoute","matchedParams","matchedRoutes","allParams","existingMatches","parsedParams","parseParams","interpolatedPath","getKey","existingMatch","findIndex","resolvedMatches","firstBadMatchIndex","beforeLoad","onBeforeLoadError","validResolvedMatches","matchPromises","reload","String","fromString","isExternal","URL","baseLocation","includeSearch","userPreloadDelay","nextOpts","defaultPreload","currentPathSplit","pathIsFuzzyEqual","pathTest","exact","hashTest","includeHash","searchTest","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","button","preloadTimeout","setTimeout","clearTimeout","dehydrate","hydrate","_ctx","__do_not_use_server_ctx","__TSR_DEHYDRATED__","ctx","payload","injectedHtml","injectHtml","html","dehydrateData","getData","strKey","data","jsonString","hydrateData","routesByPath","recurseRoutes","routes","trimmedFullPath","endsWith","values","trimmed","parsed","score","child","sort","isIndex","rank","previousLocation","parsedSearch","reverse","dest","fromPathname","prevParams","nextParams","stringifyParams","fn","preSearchFilters","flat","postSearchFilters","preFilteredSearch","destSearch","postFilteredSearch","hashStr","navigateTimeout","nextAction","previousNavigationResolve","importer","exportName","finalComp","lazy","default","defaultOpts"],"mappings":"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"}